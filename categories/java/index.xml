<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 王子滔的学习笔记</title>
    <link>https://wangzitao6.github.io/categories/java/index.xml</link>
    <description>Recent content in java on 王子滔的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://wangzitao6.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Integer的IntegerCache</title>
      <link>https://wangzitao6.github.io/2019-08-26-integer%E7%9A%84integercache/</link>
      <pubDate>Mon, 26 Aug 2019 10:23:46 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-26-integer%E7%9A%84integercache/</guid>
      <description>&lt;p&gt;首先我们来看这样一个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int m = 10;
int n = 10;
System.out.println(m == n);

int j = 128;
int k = 128;
System.out.println(j == k);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;true
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现这样的一个结果大家都意外。&lt;/p&gt;

&lt;p&gt;下面我们再看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer a = 10;
Integer b = 10;
System.out.println(a == b);

Integer c = 128;
Integer d = 128;
System.out.println(c == d);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为，Integer是包装类型，是Object对象，因此==比较的是Integer指向的内存地址。然而-128~127直接的Integer数据直接缓存进入常量池（IntegerCache），所以这个区间的比较返回true，其他区间返回false。当然，new的Integer对象不适用。&lt;/p&gt;

&lt;p&gt;看下Integer源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(String s) throws NumberFormatException {
    return Integer.valueOf(parseInt(s, 10));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法。&lt;/br&gt;
我们
Integer a = 10 或者 Integer c = 200 都进行了一次自动装箱。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer a = 10;
//等价于：
Integer a = Integer.valueOf(10);

Integer c = 128
//等价于：
Integer a = Integer.valueOf(128);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer在赋值时自动装箱，调用valueOf(),其中valueOf源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到如果这个数值在cache数组的范围内（low和high之间），就返回cache缓存数组的中的数据，否则产生一个新的Integer值。其IntegerCache源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty(&amp;quot;java.lang.Integer.IntegerCache.high&amp;quot;);
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k &amp;lt; cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high &amp;gt;= 127;
    }

    private IntegerCache() {}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常这个范围是-128-127，然而这个范围的最大值是可变的，可以通过-XX:AutoBoxCacheMax=&lt;size&gt;参数去修改这个值，在JVM初始化的时候，这个值被写入sun.misc.VM class系统私有配置文件中，并加载。&lt;/p&gt;

&lt;p&gt;所以这就是为什么在阿里巴巴Java开发手册的OOP规约中强制使用equals比较两个Integer的值&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;4.7【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。
说明： 对于 Integer var=?在-128 至 127 之间的赋值， Integer 对象是在
IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行
判断。
但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，
推荐使用 equals 方法进行判断&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。
有 ByteCache 用于缓存 Byte 对象
有 ShortCache 用于缓存 Short 对象
有 LongCache 用于缓存 Long 对象
有 CharacterCache 用于缓存 Character 对象
Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java位运算</title>
      <link>https://wangzitao6.github.io/2019-08-24-java%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sat, 24 Aug 2019 15:09:25 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-24-java%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>

&lt;h2 id=&#34;单位换算&#34;&gt;单位换算&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;bit：位
一个二进制数据0或1，是1bit；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;byte：字节
1 byte = 8 bit , 存储空间的基本计量单位；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个英文字符占一个字节
1 字母 = 1 byte = 8 bit；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个汉字占2个字节
1 汉字 = 2 byte = 16 bit；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;支持的数据类型&#34;&gt;支持的数据类型&lt;/h2&gt;

&lt;p&gt;首先明确一点，Java中的位运算是针对整型的数据类型进行运算的，所以操作数必须是一下五种之一。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;所占位数（bit）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;数据存储方式&#34;&gt;数据存储方式&lt;/h2&gt;

&lt;p&gt;计算机中存储的数据最终是以二进制存储(补码存储)，如int类型的十进制数字10表示为32bit的二进制：&lt;/p&gt;

&lt;p&gt;0000 0000 0000 0000 0000 0000 0000 1010&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：数据在计算机中都是以反码形式存在。正数的的原码与反码相同。
    有关原码、反码、补码的知识，请看另一个章节&lt;a href=&#34;https://wangzitao6.github.io/2019-08-23-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/&#34;&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;位运算符&#34;&gt;位运算符&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对应位同为1时，才为1，否则全为0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;按位或(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对应位只要有1时，即为1，否则全为0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;按位非(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对每位进行取反&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;只要对应为不同即为1&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;左移(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;左移 左边最高位丢弃，右边补齐0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;右移(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;最高位是0，左边补齐0；最高为是1，左边补齐1&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;无符号右移(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;无论操作数是正数还是负数，高位都是补0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;按位与&#34;&gt;按位与 &amp;amp;&lt;/h3&gt;

&lt;p&gt;规则：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 对应位同为1时，才为1，否则全为0（对应位只要有0，全为0，否则为1） &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 127;
int b = 128;
System.out.println(&amp;quot;127 &amp;amp; 128 的结果是：&amp;quot;+(a &amp;amp; b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127 &amp;amp; 128 的结果是：0

解析: 
127的二进制(补码)：00000000 00000000 00000000 01111111
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 &amp;amp; 规则结果：  00000000 00000000 00000000 00000000
所以结果为0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位或&#34;&gt;按位或 |&lt;/h3&gt;

&lt;p&gt;规则： &lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 对应位只要有1时，即为1，否则全为0（对应位只有全是0时，结果才是0，否则为1） &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 127;
int b = 128;
System.out.println(&amp;quot;127 | 128 的结果是：&amp;quot;+(a | b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127 | 128 的结果是：255

解析: 
127的二进制(补码)：00000000 00000000 00000000 01111111
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 | 规则结果：  00000000 00000000 00000000 11111111
最高为0，为正数，原码补码一样，所以结果为255
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位非&#34;&gt;按位非 ~&lt;/h3&gt;

&lt;p&gt;规则： &lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对每位进行取反 &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 128;
System.out.println(&amp;quot;~128 的结果是：&amp;quot; + ~ a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~128 的结果是：-129

解析: 
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 ~ 规则结果：  11111111 11111111 11111111 01111111
最高为1，为负数。
补码：11111111 11111111 11111111 01111111
反码：11111111 11111111 11111111 01111110
原码：10000000 00000000 00000000 10000001
结果为 -129
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位异或&#34;&gt;按位异或 ^&lt;/h3&gt;

&lt;p&gt;规则： &lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 只要对应为不同即为1。 &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 127;
int b = 128;
System.out.println(&amp;quot;127 ^ 128 的结果是：&amp;quot; + (a ^  b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127 ^ 128 的结果是：255

解析: 
127的二进制(补码)：00000000 00000000 00000000 01111111
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 | 规则结果：  00000000 00000000 00000000 11111111
最高为0，为正数，原码补码一样，所以结果为255
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;位移动运算符&#34;&gt;位移动运算符&lt;/h3&gt;

&lt;h4 id=&#34;左移&#34;&gt;左移 &amp;lt;&amp;lt;&lt;/h4&gt;

&lt;p&gt;规则：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; &amp;lt;&amp;lt; :左移 左边最高位丢弃，右边补齐0; &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左移的规则只记住一点：丢弃最高位，0补最低位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通用格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value &amp;lt;&amp;lt; num 
num : 指要移位值   
value : 指移动的位数。
意思是value向左位移num位，左移num位，相当于乘以2^num
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 1;
System.out.println(&amp;quot;1 &amp;lt;&amp;lt; 2 的结果是：&amp;quot; + (a &amp;lt;&amp;lt; 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果(图片来自于网络)：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/26/%E5%B7%A6%E7%A7%BB2.png&#34; alt=&#34;左移&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 &amp;lt;&amp;lt; 2 的结果是：4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;右移&#34;&gt;右移 &amp;gt;&amp;gt;&lt;/h4&gt;

&lt;p&gt;规则：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; &amp;gt;&amp;gt;:右移, 最高位是0(正数时)，左边补齐0；最高为是1(正数时)，左边补齐1，保持为负数；&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;m&amp;gt;&amp;gt;n即相当于m除以2的n次方，得到的为整数时，即为结果。如果结果为小数，此时会出现两种情况：&lt;/p&gt;

&lt;p&gt;1 如果m为正数，得到的商会无条件 的舍弃小数位；&lt;/p&gt;

&lt;p&gt;2 如果m为负数，舍弃小数部分，然后把整数部分加+1得到位移后的值。&lt;/p&gt;

&lt;p&gt;通用格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value &amp;gt;&amp;gt; num 
num : 指要移位值   
value : 指移动的位数。
意思是value向左位移num位，左移num位，相当于除以2^num
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 12;
System.out.println(&amp;quot;12 &amp;gt;&amp;gt; 2 的结果是：&amp;quot; + (a &amp;gt;&amp;gt; 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果(图片来自于网络，图中稍有错误，其中10应该为12)：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/26/%E5%8F%B3%E7%A7%BB.png&#34; alt=&#34;右移&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 &amp;lt;&amp;lt; 2 的结果是：4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;无符号右移&#34;&gt;无符号右移 &amp;gt;&amp;gt;&amp;gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;无符号右移&amp;gt;&amp;gt;&amp;gt; 与 右移&amp;gt;&amp;gt; 的区别就是无论操作数是正数还是负数，高位都是补0&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 12;
System.out.println(&amp;quot;12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：&amp;quot; + (a &amp;gt;&amp;gt;&amp;gt; 2));

int b = -12;
System.out.println(&amp;quot;-12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：&amp;quot; + (b &amp;gt;&amp;gt;&amp;gt; 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：3
-12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：1073741821

解析: 
12 &amp;gt;&amp;gt;&amp;gt; 2 跟 12 &amp;gt;&amp;gt; 2 过程一样，上面有过程，我们说下 -12 &amp;gt;&amp;gt;&amp;gt; 2
-12的原码：        10000000 00000000 00000000 00001100
-12的二进制(补码): 11111111 11111111 11111111 11110100
右移2位：           11111111 11111111 11111111 11110100
补齐：            0011111111 11111111 11111111 111101
注意这个补齐因为是无符号的，最高位补0，结果为正数
最高为0，为正数，原码补码一样，所以结果为的结果是：1073741821
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Int类型强制转换byte类型</title>
      <link>https://wangzitao6.github.io/2019-08-24-int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2byte%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 24 Aug 2019 11:13:05 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-24-int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2byte%E7%B1%BB%E5%9E%8B/</guid>
      <description>

&lt;h2 id=&#34;java中为什么int类型的-129转换成byte类型的会变成127&#34;&gt;java中为什么int类型的-129转换成byte类型的会变成127&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;int类型一般是4个字节，一个字节有8位，这样int型数据二进制的完整形式有32位，而byte表示一个字节，于是byte类型数据二进制的完整形式有8位。&lt;/strong&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;二进制数据在计算机内是以二进制存储的，要注意一点，计算机在存储某个数据时，是存储的数据的补码，说明一下补码与原码关系，正数补码与原码相同，负数补码是原码减1后取反。
&lt;/br&gt;&lt;br /&gt;
根据上面阐述，129的原码是00000000 00000000 00000000 10000001 ，负数最高位取1，那么-129便是10000000 00000000 00000000 10000001 ，补码计算：取反为11111111 11111111 11111111 01111110（最高位是符号位，不参与取反），加1为11111111 11111111 11111111 01111111 ，现在转换为byte，只有8位，于是只能保留低8位，前面24位丢去，得到01111111，符号位为0,代表正数，原码、反码、补码一致。原码也是01111111。这就对应着十进制的127.&lt;/p&gt;

&lt;h2 id=&#34;int类型的129转换成byte类型的会变成-127&#34;&gt;int类型的129转换成byte类型的会变成-127&lt;/h2&gt;

&lt;p&gt;129为正数，原码补码反码相同：00000000 00000000 00000000 10000001
现在转换为byte，只有8位，于是只能保留低8位，前面24位丢去，得到10000001，&lt;/p&gt;

&lt;p&gt;补码为10000001， 开头为1 为负数   反码与补码不一样  为补码减1  得到反码：10000000
负数反码转成原码  符号位不变，其他位取反 得到原码：11111111
为 -127&lt;/p&gt;

&lt;h2 id=&#34;int类型的128转换成byte类型的会变成-128&#34;&gt;int类型的128转换成byte类型的会变成-128&lt;/h2&gt;

&lt;p&gt;128为正数，原码补码反码相同：00000000 00000000 00000000 10000000
现在转换为byte，只有8位，于是只能保留低8位，前面24位丢去，得到10000000，
因为补码为10000000，所以为-128&lt;/p&gt;

&lt;p&gt;在规定中，8位二进制码能表示的反码范围是-127~127。
-128没有反码。
那么，为什么规定-128没有反码呢?下面解释。
首先看-0，[-0]原码=1000 000，其中1是符号位，根据反码规定，算出[-0]反码=1111 1111，
再看-128，[-128]原码=1000 000，假如让-128也有反码，根据反码规定，则[-128]反码=1111 1111，
你会发现，-128的反码和-0的反码相同，所以为了避免面混淆，有了-0，便不能有-128，这是反码规则决定的。&lt;/p&gt;

&lt;p&gt;-128的原码是10000000。
补码是反码+1：依然是10000000。（因为加1进位了，但是只有8位，所以进位无法显示）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>原码 补码 反码</title>
      <link>https://wangzitao6.github.io/2019-08-23-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/</link>
      <pubDate>Fri, 23 Aug 2019 16:28:33 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-23-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/</guid>
      <description>

&lt;h2 id=&#34;java数据类型&#34;&gt;Java数据类型&lt;/h2&gt;

&lt;p&gt;了解原码、补码、反码之前，我们先看下java的数据类型：&lt;/p&gt;

&lt;p&gt;Java基本类型共有八种，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;boolean：只有true和false两个取值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;char：16位，存储Unicode码，用单引号赋值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上各种类型占用内存：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;大小/位&lt;/th&gt;
&lt;th&gt;大小范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte(位)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-128~127&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;short(短整数)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;-32768~32767&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int(整数)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;-2147483648~2147483647&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;long(长整数)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;-9223372036854775808~9223372036854775807&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float(单精度)&lt;/td&gt;
&lt;td&gt;浮点型&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;1.4E-45~3.4028235E38&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;double(双精度)&lt;/td&gt;
&lt;td&gt;浮点型&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;4.9E-324~1.7976931348623157E308&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;char(字符)&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;0~65535&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;布尔型&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;true或false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;byte占用一个字节，取值范围是-128~127,因为在二进制中，最高位是符号位，0表示正、1表示负，其他位是数据位。 byte共占8个bit，最大值为01111111，转成十进制为127，最小值为10000000，1是符号位，表示负数，转成十进制为128。所以最小值为-128 ，具体为什么是-128？二进制和十进制如何在底层转换？将涉及到原码、反码、补码，我们往下继续看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原码-补码-反码&#34;&gt;原码 补码 反码&lt;/h2&gt;

&lt;h3 id=&#34;机器数和真值&#34;&gt;机器数和真值&lt;/h3&gt;

&lt;p&gt;我们先了解下数据在计算机中是怎么表示的&lt;/p&gt;

&lt;h4 id=&#34;机器数&#34;&gt;机器数&lt;/h4&gt;

&lt;p&gt;　一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.比如，十进制中的数 &lt;strong&gt;3&lt;/strong&gt; ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。&lt;/p&gt;

&lt;h4 id=&#34;真值&#34;&gt;真值&lt;/h4&gt;

&lt;p&gt;因为第一位是符号位，所以机器数的形式值就不等于真正的数值。
例如上面的有符号数10000011，其最高位1代表负，其真正数值是-3而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。&lt;/br&gt;
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1&lt;/p&gt;

&lt;h3 id=&#34;原码概念&#34;&gt;原码概念&lt;/h3&gt;

&lt;p&gt;数值X的原码记为[x]原，如果机器字长为n(即采用n个二进制位表示数据)。则&lt;font color = &#34;red&#34;&gt;最高位是符号位。0表示正号，1表示负号&lt;/font&gt;，其余的n-1位表示数值的绝对值。&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;数值零的原码表示有两种形式:[+0]原=0000 0000   ,-[0]原=1000 0000.&lt;/p&gt;

&lt;p&gt;例子：若机器字长n等于8，则&lt;/p&gt;

&lt;p&gt;[+1]原=0000 00001           [-1]原=1000 00001  &lt;/p&gt;

&lt;p&gt;[+127]原=0111 1111          [-127]原=1111 1111&lt;/p&gt;

&lt;p&gt;[+45]原=0010 1101           [-45]原=1010 1101    &lt;/p&gt;

&lt;p&gt;可见，原码，在计算数值上出问题了，当然，你也可以实验下，原码在计算正数和正数的时候，它是一点问题都没有的，但是出现负数的时候就出现问题了。所以才会有我下面将的问题：反码&lt;/p&gt;

&lt;h3 id=&#34;反码概念&#34;&gt;反码概念&lt;/h3&gt;

&lt;p&gt;数值X的反码记作[x]反，如果机器字长为n，则&lt;font color = &#34;red&#34;&gt;最高位是符号位，0表示正号，1表示负号&lt;/font&gt;，&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;正数的反码与原码相同，负数的反码 则是其绝对值按位求反&lt;/strong&gt;&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;数值0的反码表示有两种形式：[+0]反=0000 0000   ,-[0]反=1111 1111.&lt;/p&gt;

&lt;p&gt;例子：若机器字长n等于8，则&lt;/p&gt;

&lt;p&gt;[+1]反=0000 00001           [-1]反=1111 1110 &lt;/p&gt;

&lt;p&gt;[+127]反=0111 1111          [-127]反=1000 0000&lt;/p&gt;

&lt;p&gt;[+45]反=0010 1101           [-45]反=1101 0010  &lt;/p&gt;

&lt;p&gt;在看反码计算的问题：&lt;/p&gt;

&lt;p&gt;1+（-1）=0   |  （0000 0001）反+（1111 1110）反=（1111 1111）反=（1000 0000）原=【-0】  可以看到，虽然是-0，但是问题还不是很大&lt;/p&gt;

&lt;p&gt;1+（-2）=-1  |  （0000 0001）反+（1111 1101）反=（1111 1110）反=（1000 0001）原=【-1】  可以看到，没有问题&lt;/p&gt;

&lt;p&gt;-1+（2）=1   |  （1111 1110）反+（0000 0010）反=（0000 0000）反=（0000 0000）原=【0】  可以看到，问题发生了，因为溢出，导致结果变为0了。&lt;/p&gt;

&lt;p&gt;所以，看以看到，用反码表示，问题依然没有解决，所以，出现了下面的补码&lt;/p&gt;

&lt;h3 id=&#34;补码概念&#34;&gt;补码概念&lt;/h3&gt;

&lt;p&gt;数值X的补码记作[x]补，如果机器字长为n，则&lt;font color = &#34;red&#34;&gt;最高位是符号位，0表示正号，1表示负号&lt;/font&gt;，&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;正数的补码与原码反码都相同，负数的补码则等于其反码的末尾加1&lt;/strong&gt;&lt;/font&gt;。&lt;/br&gt;
数值0的补码表示有唯一的编码：[+0]补=0000 0000   ,-[0]补=0000 0000.&lt;/p&gt;

&lt;p&gt;例子：若机器字长n等于8，则&lt;/p&gt;

&lt;p&gt;[+1]补=0000 00001           [-1]补=1111 1111  &lt;/br&gt;
[+127]补=0111 1111          [-127]补=1000 0001&lt;/br&gt;
[+45]补=0010 1101           [-45]补=1101 0011  &lt;/br&gt;&lt;/p&gt;

&lt;p&gt;在看补码计算的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1+（-1）=0  |  （0000 0001）补+（1111 1111）补=（0000 0000）补=（0000 0000）原=【0】  可以看到。没有问题

1+（-2）=-1 |  （0000 0001）补+（1111 1110）补=（1111 1111）补=（1000 0001）原=【-1】  可以看到，没有问题

-1+（2）=1  |  （1111 1111）补+（0000 0010）补=（0000 0001）补 =（0000 0001）原=【1】  可以看到，没有问题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的计算，我们发现，用补码的方式，就不存在在原码和反码中存在的计算问题了。其实，这也是&lt;font color = &#34;red&#34;&gt;计算机表达带符号整数用补码&lt;/font&gt;的原因。如果，你觉得我举得例子太少，缺少代表行，你可以自己试试。不过，放心补码一定是不会存在原码和反码的问题的。&lt;/p&gt;

&lt;p&gt;明白了计算机中补数的道理，那么就明白补码的问题了。还是用例子说明：&lt;/p&gt;

&lt;p&gt;在计算机中计算十进制 1+（-2）。&lt;/p&gt;

&lt;p&gt;1的原码是：0000 0001&lt;/p&gt;

&lt;p&gt;-2的原码是：1000 0010&lt;/p&gt;

&lt;p&gt;-2的补码是：1111 1110   这个二进制换做无符号的整数大小就是254，而8位二进制数的M=2^8=256。（很多文章中把M写成2^7，这根本就是不对的，根本没有解决符号位的问题）&lt;/p&gt;

&lt;p&gt;你发现什么了没，当换成补码后，-2和254就是补数的关系。&lt;/p&gt;

&lt;p&gt;也就是1+（-2）  等价于了 1+254了。&lt;/p&gt;

&lt;p&gt;这样做，好处在什么地方，你自己都可以看得到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;利用补数和溢出的原理，减法变成了加法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;符号位不在是约束计算的问题，不会存在原码中的问题了，因为变成补码后，虽然最高位依然是1，但是这个1就不在是最为符号位了，而是作为一个普通的二进制位，参与运算了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;补码计算规则&#34;&gt;补码计算规则&lt;/h4&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;正数：原码 = 补码 = 反码&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;负数：反码 = 符号不变，其它位取反&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;补码 = 反码 + 1&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;十进制数&lt;/th&gt;
&lt;th&gt;原码&lt;/th&gt;
&lt;th&gt;反码&lt;/th&gt;
&lt;th&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;td&gt;0101 0101&lt;/td&gt;
&lt;td&gt;0101 0101&lt;/td&gt;
&lt;td&gt;0101 0101&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-85&lt;/td&gt;
&lt;td&gt;1101 0101&lt;/td&gt;
&lt;td&gt;1010 1010&lt;/td&gt;
&lt;td&gt;1010 1011&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;0000 1001&lt;/td&gt;
&lt;td&gt;0000 1001&lt;/td&gt;
&lt;td&gt;0000 1001&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-9&lt;/td&gt;
&lt;td&gt;1000 1001&lt;/td&gt;
&lt;td&gt;1111 0110&lt;/td&gt;
&lt;td&gt;1111 0111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;请计算出 -1 + 1：&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 1 原码  :  0000 0000 0000 0001&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 -1 原码  : 1000 0000 0000 0001&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 -1 反码  :  1111  1111  1111  1110&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 -1 补码  :  1111  1111  1111  1111&lt;/strong&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;计算-1+1即得 ,即-1补码+1的补码&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;1111 1111 1111 1111 + 0000 0000 0000 0001 = 0000 0000 0000 0000&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;结果即为0&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>设计模式之单例模式</title>
      <link>https://wangzitao6.github.io/2018-11-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F</link>
      <pubDate>Mon, 12 Nov 2018 15:11:17 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-11-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F</guid>
      <description>

&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;

&lt;p&gt;首先我们来考虑下，&lt;strong&gt;如何设计一个类，在系统中只能生成该类的一个实体?&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;懒汉-线程不安全&#34;&gt;懒汉，线程不安全&lt;/h3&gt;

&lt;p&gt;面对这个问题，我们可以想到把构造函数私有化，以禁止他人创建实例，我们可以写一个静态的实例，在需要的时候创建它。我们可以得到以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// version 1.0
public class Singleton {
    private static Singleton singleton = null;

    private Singleton() {  }

    public static Singleton getInstance() {
        if (singleton== null) {
            singleton= new Singleton();
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所形成的实例保存在自己类中的私有成员中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们取实例时，只需要使用Singleton.getInstance()就行了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;懒汉-线程安全&#34;&gt;懒汉，线程安全&lt;/h3&gt;

&lt;p&gt;上述代码在单线程下运行时没有问题的，但是放在多线程环境下就可能出问题。比如：当系统中不存在Singleton实例时，两个线程同时运行到判断 if (singleton== null) 时，那么两个线程都会通过判断并创建实例。就不符合单例模式的要求了。为了保护多线程环境下运行，我们需要加上同步锁，得到以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// version 2.0
public class Singleton
{
    private static Singleton singleton = null;

    private Singleton() {  }

    public static Singleton getInstance() {
        //加上同步锁
        synchronized (Singleton.class) {
            if (singleton== null) {
                singleton= new Singleton();
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，假如出现当系统中不存在Singleton实例时，两个线程同时运行到判断 if (singleton== null) 的情况时，两个线程想同时创建一个实例时，但由于在同一个时刻只有一个线程可以得到同步锁，当第一个线程加上锁时，第二个线程只有等待，第一个线程判断Singleton实例是否已经创建，发现没有实例，创建一个后释放锁，第二个线程加上同步锁，运行以上过程，发现实例已经被创建出来了，就不会重复创建了，这样可以保证我们在单线程环境中也只有一个实例。&lt;/p&gt;

&lt;p&gt;但是version 2.0版本还是有点小问题，我们每次调用getInstance()获取实例时，都会视图加上一个同步锁，而加锁是非常耗时的一个操作，在美有必要时我们应该尽量避免。&lt;/p&gt;

&lt;h3 id=&#34;双重校验锁&#34;&gt;双重校验锁&lt;/h3&gt;

&lt;p&gt;我们只是在没有创建实例前需要加锁，以保证只有一个实例，当实例创建后，已经不需要加锁了。所以我们可以改善代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// version 3.0
public class Singleton
{
    private static Singleton singleton = null;

    private Singleton()  {    }

    public static Singleton getInstance() {
        if (singleton== null)  {
            synchronized (Singleton.class) {
                if (singleton== null)  {
                    singleton= new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只需要在实例没有创建时需要加锁操作，实例创建后，不需要加锁，只有在Singleton == null时才会加锁，其他时候不需要，所以version 3.0 的效率要高于 version 2.0。&lt;/p&gt;

&lt;h3 id=&#34;双重校验锁-volatile&#34;&gt;双重校验锁+volatile&lt;/h3&gt;

&lt;p&gt;由于singleton = new Singleton()并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.给 singleton 分配内存
2.调用 Singleton 的构造函数来初始化成员变量，形成实例
3.将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。&lt;/p&gt;

&lt;p&gt;对此，我们只需要把singleton声明成 volatile 就可以了。下面我们优化代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// version 4.0
public class Singleton
{
    private volatile static Singleton singleton = null;

    private Singleton()  {    }

    public static Singleton getInstance()   {
        if (singleton== null)  {
            synchronized (Singleton.class) {
                if (singleton== null)  {
                    singleton= new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 volatile 有两个功用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.这个变量不会在多个线程中存在复本，直接从内存读取。

2.这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。&lt;/p&gt;

&lt;p&gt;上面的代码比较复杂，我们能不能找一种更为优雅的方式?&lt;/p&gt;

&lt;h3 id=&#34;饿汉&#34;&gt;饿汉&lt;/h3&gt;

&lt;p&gt;答案是可以的，我们可以在声明实例的时候就初始化，单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// version 5.0
public class Singleton
{
    private volatile static Singleton singleton = new Singleton();

    private Singleton()  {    }

    public static Singleton getInstance()   {
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是由于 static 和 final 变量，当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。&lt;/p&gt;

&lt;p&gt;于是，这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，初始化一些配置参数），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。&lt;/p&gt;

&lt;h3 id=&#34;静态内部类-推荐&#34;&gt;静态内部类（推荐）&lt;/h3&gt;

&lt;p&gt;对于上述我们不能控制类加载时机的问题，我们会想，如果什么时候调用 getInstance() 什么时候加载类就好了，因此我们可以优化代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// version 6.0
public class Singleton {
    //创建一个私有静态内部类 SingletonHolder 
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton (){ }

    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;

&lt;h3 id=&#34;枚举-推荐&#34;&gt;枚举（推荐）&lt;/h3&gt;

&lt;p&gt;在《Effective Java》最后推荐了这样一个写法，简直有点颠覆，不仅超级简单，而且保证了线程安全。这里引用一下，此方法无偿提供了序列化机制，绝对防止多次实例化，及时面对复杂的序列化或者反射攻击。单元素枚举类型已经成为实现Singleton的最佳方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//version 7.0
public enum Singleton{
   INSTANCE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;枚举法探究&#34;&gt;枚举法探究&lt;/h4&gt;

&lt;p&gt;很多人会对枚举法实现的单例模式很不理解。这里需要深入理解的是两个点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;枚举类实现其实省略了private类型的构造函数&lt;/li&gt;
&lt;li&gt;枚举类的域(field)其实是相应的enum类型的一个实例对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于第一点实际上enum内部是如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Singleton {
    INSTANCE;
    // 这里隐藏了一个空的私有构造方法
    private Singleton () {
        System.out.println(&amp;quot;do something&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你这时候在另一个class中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    System.out.println(Singleton.INSTANCE);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以看到:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do something
INSTANCE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一个标准的enum单例模式，最优秀的写法还是实现接口的形式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 定义单例模式中需要完成的代码逻辑
public interface MySingleton {
    void doSomething();
}

public enum Singleton implements MySingleton {
    INSTANCE {
        @Override
        public void doSomething() {
            System.out.println(&amp;quot;complete singleton&amp;quot;);
        }
    };

    public static MySingleton getInstance() {
        return Singleton.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HashMap实现原理</title>
      <link>https://wangzitao6.github.io/2019-09-12-hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 12 Sep 2018 11:49:31 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-09-12-hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;什么是哈希表&#34;&gt;什么是哈希表&lt;/h2&gt;

&lt;p&gt;哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;线性链表&lt;/strong&gt;：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们知道，数据结构的物理存储结构只有两种：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;顺序存储结构&lt;/font&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;链式存储结构&lt;/font&gt;&lt;/strong&gt;（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。&lt;/p&gt;

&lt;p&gt;　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;存储位置 = f(关键字)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　其中，这个函数f一般称为&lt;strong&gt;哈希函数&lt;/strong&gt;，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/29/29-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。&lt;/p&gt;

&lt;h3 id=&#34;哈希冲突&#34;&gt;哈希冲突&lt;/h3&gt;

&lt;p&gt;　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，&lt;strong&gt;当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞&lt;/strong&gt;。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:&lt;strong&gt;开放定址法&lt;/strong&gt;（发生冲突，继续寻找下一块未被占用的存储地址），&lt;strong&gt;再散列函数法&lt;/strong&gt;，&lt;strong&gt;链地址法&lt;/strong&gt;，而HashMap即是采用了链地址法，也就是&lt;strong&gt;数组+链表&lt;/strong&gt;的方式，&lt;/p&gt;

&lt;h2 id=&#34;hashmap实现原理&#34;&gt;HashMap实现原理&lt;/h2&gt;

&lt;p&gt;HashMap的主干是一个Node数组。Node是HashMap的基本组成单元，每一个Node包含一个key-value键值对。&lt;/p&gt;

&lt;p&gt;Node是HashMap中的一个静态内部类。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    final int hash; //对key的hashcode值进行hash运算后得到的值，存储在Node，避免重复计算
    final K key;
    V value;
    Node&amp;lt;K,V&amp;gt; next;//存储指向下一个Node的引用，单链表结构

    Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
     /**省略此处代码**/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，HashMap的整体结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/29/29-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单来说，HashMap由数组+链表组成的，&lt;font color = &#34;red&#34;&gt;数组是HashMap的主体&lt;/font&gt;，&lt;font color = &#34;red&#34;&gt;链表则是主要为了解决哈希冲突而存在的&lt;/font&gt;，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好&lt;/strong&gt;。(&lt;font color = &#34;red&#34;&gt;jdk 8 之前，其内部是由数组+链表来实现的，而 jdk 8 对于链表长度超过 8 的链表将转储为红黑树&lt;/font&gt;，本文讨论的是jdk8格式的。)&lt;/p&gt;

&lt;p&gt;其他几个重要字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//默认的容量，即默认的数组长度 16
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;

//最大的容量，即数组可定义的最大长度 
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是上述提到的数组，数组的元素都是 Node 类型，数组中的每个 Node 元素都是一个链表的头结点，通过它可以访问连接在其后面的所有结点。其实你也应该发现，上述的容量指的就是这个数组的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//HashMap的主干数组，可以看到就是一个Node数组，初始值为空数组{}
transient Node&amp;lt;K,V&amp;gt;[] table;

//实际存储的键值对个数
transient int size;

//用于迭代防止结构性破坏的标量，由于HashMap非线程安全，
//在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），
//需要抛出异常ConcurrentModificationException
transient int modCount;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这几个属性是相关的，threshold 代表的是一个阈值。伴随着元素不断的被添加进数组，一旦数组中的元素数量达到这个阈值，那么表明数组应该被扩容而不应该继续任由元素加入。而这个阈值的具体值则由负载因子（loadFactor）和数组容量来决定。
公式：&lt;code&gt;threshold = capacity * loadFactor&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//map中实际存储的key-value键值对的个数
transient int size;

//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；
//当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。
//HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;

//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;

//HashMap 中默认负载因子为 0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，有关 HashMap 的基本属性大致介绍如上。下面我们看看它的几个重载的构造函数。HashMap有4个构造器，其他构造器如果用户没有传入&lt;code&gt;initialCapacity&lt;/code&gt; 和&lt;code&gt;loadFactor&lt;/code&gt;这两个参数，会使用默认值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;initialCapacity&lt;/code&gt;默认为16，&lt;code&gt;loadFactory&lt;/code&gt;默认为0.75&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public HashMap(int initialCapacity, float loadFactor) {
    　//此处对传入的初始容量进行校验，最大范围 0 &amp;lt; MAXIMUM_CAPACITY &amp;lt;= 1&amp;lt;&amp;lt;30
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; + initialCapacity);
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个最基本的构造函数，需要调用方传入两个参数，&lt;code&gt;initialCapacity&lt;/code&gt; 和 &lt;code&gt;loadFactor&lt;/code&gt;。程序的大部分代码在判断传入参数的合法性，&lt;code&gt;initialCapacity&lt;/code&gt; 小于零将抛出异常，大于 &lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt; 将被限定为 &lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt;。&lt;code&gt;loadFactor&lt;/code&gt; 如果小于等于零或者非数字类型也会抛出异常。&lt;/p&gt;

&lt;p&gt;整个构造函数的核心在对 &lt;code&gt;threshold&lt;/code&gt;的初始化操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可以看到，当在实例化HashMap实例时，如果给定了&lt;code&gt;initialCapacity&lt;/code&gt;，由于HashMap的&lt;code&gt;capacity&lt;/code&gt;都是2的幂，因此这个方法用于找到大于等于&lt;code&gt;initialCapacity&lt;/code&gt;的最小的2的幂（&lt;code&gt;initialCapacity&lt;/code&gt;如果就是2的幂，则返回的还是这个数）。&lt;/p&gt;

&lt;p&gt;下面分析这个算法：
首先，为什么要对cap做减1操作。&lt;code&gt;int n = cap - 1;&lt;/code&gt;
这是为了防止cap已经是2的幂。&lt;strong&gt;如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍&lt;/strong&gt;。如果不懂，要看完后面的几个无符号右移之后再回来看看。
下面看看这几个无符号右移操作：
如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是1（最后有个n+1的操作）。
这里只讨论n不等于0的情况。&lt;/p&gt;

&lt;p&gt;第一次右移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 1;(相当于: n=n|n &amp;gt;&amp;gt;&amp;gt; 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n=000...01xxxxxxx
右移一位后为 n &amp;gt;&amp;gt;&amp;gt; 1 = 000...001xxxxxx  = 000...011xxxxxx
那么n|n &amp;gt;&amp;gt;&amp;gt; 1 = 000...01xxxxxxx|000...001xxxxxx  = 000...011xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二次右移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这个n已经经过了n |= n &amp;gt;&amp;gt;&amp;gt; 1; 操作。假设此时n=16,二进制为000011xxxxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如000&amp;hellip;01111xxxx 。
第三次右移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如000&amp;hellip;011111111 。&lt;/p&gt;

&lt;p&gt;所以从宏观上看，传入的容量无论是处于任何范围，最终都会被打造成比该值大并且比最近的一个 2 的 n 次幂小一的值。为什么这么做？因为 2 的 n 次幂小一的值在二进制角度看全为 1，将有利于 HashMap 中的元素搜索，这一点我们后续将介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以此类推&lt;/strong&gt;
注意，容量最大也就是32bit的正数，因此最后&lt;code&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 16;&lt;/code&gt; ，最多也就32个1，但是这时已经大于了&lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt; ，所以取值到&lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt; 。
举一个例子说明下吧。
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/29/29-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个算法着实牛逼啊！&lt;/p&gt;

&lt;p&gt;那么通过该方法，我们将获得一个 2 的整数次幂的容量的值，此处存放至&lt;code&gt;threshold&lt;/code&gt;，实际上我们获取的是一个有关数组容量的值，不应该存放至&lt;code&gt;阈值 threshold&lt;/code&gt; 中，但在后续实际初始化数组的时候并不会受到影响，这里可能是写 jdk 的大神偷了一次懒吧。&lt;/p&gt;

&lt;p&gt;注意，得到的这个&lt;code&gt;capacity&lt;/code&gt;却被赋值给了&lt;code&gt;阈值 threshold&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.threshold = tableSizeFor(initialCapacity);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始以为这个是个Bug，感觉应该这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。
但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算&lt;/p&gt;

&lt;h2 id=&#34;put-方法的具体实现&#34;&gt;put 方法的具体实现&lt;/h2&gt;

&lt;p&gt;put 方法的源码分析是本篇的一个重点，因为通过该方法我们可以窥探到 HashMap 在内部是如何进行数据存储的，所谓的数组+链表+红黑树的存储结构是如何形成的，又是在何种情况下将链表转换成红黑树来优化性能的。带着一系列的疑问，我们看这个 put 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加一个元素只需要传入一个键和一个值即可，putVal 方法是关键，我已经在该方法中进行了基本的注释，具体的细节稍后详细说明，先从这些注释中大体上建立一个直观的感受。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    //Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt;数组
    //Node&amp;lt;K,V&amp;gt; p,   单链表中存储指向下一个Node的引用
    //n,主干数组的长度
    //i, index索引
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;

    //如果 table 还未被初始化，那么初始化它
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

    //根据键的 hash 值找到该键对应到数组中存储的索引,i = (n - 1) &amp;amp; hash
    //如果 tab[i]为 null，那么说明此索引位置并没有被占用,创建节点
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);

    //tab[i]不为 null，说明此处已经被占用，只需要将构建一个节点插入到这个链表的尾部即可
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;

        //当前结点和将要插入的结点的 hash 和 key 相同，说明这是一次修改操作
        if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;

        //如果 p 这个头结点是红黑树结点的话，以红黑树的插入形式进行插入
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        
        // p 这个头结点属于链表，遍历此条链表，将构建一个节点插入到该链表的尾部
        else {
            for (int binCount = 0; ; ++binCount) {

                //在链表的最后插入
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);

                    //如果插入后链表长度大于等于 8 ，将链表裂变成红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }

                //遍历的过程中，如果发现与某个结点的 hash和key，这依然是一次修改操作 
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //e 不是 null，说明当前的 put 操作是一次修改操作并且e指向的就是需要被修改的结点
        if (e != null) { 
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    //如果添加后，数组容量达到阈值，进行扩容
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从整体上来看，该方法的大致处理逻辑已如上述注释说明，下面我们针对其中的细节进行详细的解释。&lt;/p&gt;

&lt;p&gt;首先，我们看 resize 这个方法是如何对 table 进行初始化的，代码比较多，分两部分进行解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//第一部分
final Node&amp;lt;K,V&amp;gt;[] resize() {
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;

        //拿到旧数组的长度，为0时初始化，其他时扩容
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        
        //说明旧数组已经被初始化完成了，此处需要给旧数组扩容
        if (oldCap &amp;gt; 0) {
            //极限的限定，达到容量限定的极限将不再扩容
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //未达到极限，将数组容量扩大两倍，阈值也扩大两倍
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; 
        }
        //数组未初始化，但阈值不为 0，为什么不为 0 ？
        //上述提到 jdk 大神偷懒的事情就指的这，构造函数根据传入的容量打造了一个合适的数组容量暂存在阈值中
        //这里直接使用
        else if (oldThr &amp;gt; 0) 
            newCap = oldThr;
        //数组未初始化并且阈值也为0，说明一切都以默认值进行构造
        else {
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //这里也是在他偷懒的后续弥补
        //newCap = oldThr 之后并没有计算阈值，所以 newThr = 0
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
****************后续代码......****************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分代码结束后，无论是初始化数组还是扩容，总之，必需的数组容量和阈值都已经计算完成了。下面看后续的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;****************第二部分代码.....****************
//根据新的容量初始化一个数组
Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
table = newTab;
//旧数组不为 null，这次的 resize 是一次扩容行为
if (oldTab != null) {
    //将旧数组中的每个节点位置相对静止地拷贝值新数组中
    for (int j = 0; j &amp;lt; oldCap; ++j) {
        Node&amp;lt;K,V&amp;gt; e;
        //获取头结点
        if ((e = oldTab[j]) != null) {
            oldTab[j] = null;
            //说明链表或者红黑树只有一个头结点，转移至新表
            if (e.next == null)
                newTab[e.hash &amp;amp; (newCap - 1)] = e;
            //如果 e 是红黑树结点，红黑树分裂，转移至新表
            else if (e instanceof TreeNode)
                ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
            //这部分是将链表中的各个节点原序地转移至新表中，我们后续会详细说明
            else { 
                Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                Node&amp;lt;K,V&amp;gt; next;
                do {
                    next = e.next;
                    if ((e.hash &amp;amp; oldCap) == 0) {
                        if (loTail == null)
                            loHead = e;
                        else
                            loTail.next = e;
                        loTail = e;
                    }
                    else {
                        if (hiTail == null)
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                    }
                } while ((e = next) != null);
                if (loTail != null) {
                    loTail.next = null;
                    newTab[j] = loHead;
                }
                if (hiTail != null) {
                    hiTail.next = null;
                newTab[j + oldCap] = hiHead;
                }
            }
        }
    }
}
//不论你是扩容还是初始化，都可以返回 newTab
return newTab;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于第二部分的代码段来说，主要完成的是将旧链表中的各个节点按照原序地复制到新数组中。关于头结点是红黑树的情况我们暂时不去涉及，下面重点介绍下链表的拷贝和优化代码块，这部分代码不再重复贴出，此处直接进行分析，有需要的可以参照上述列出的代码块或者自己的 jdk 进行理解。&lt;/p&gt;

&lt;p&gt;这部分其实是一个优化操作，将当前链表上的一些结点移出来向刚扩容的另一半存储空间放。&lt;/p&gt;

&lt;p&gt;一般我们有如下公式：&lt;code&gt;index = e.hash &amp;amp; (oldCap - 1)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：
e.hash = 010101110010101000101
oldCap = 　10000 
index = 01010111001010100 0101　&amp;amp; 1111 = 0101

newCap = 1000 00
newIndex = 0101011100101010 00101　&amp;amp; 11111 = 00101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随便举个例子，此时的 e 在容量扩大两倍以后的索引值没有变化，所以这部分结点是不需要移动的，那么程序如何判断扩容前后的 index 是否相等呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//oldCap 一定是 100...000 的形式
if ((e.hash &amp;amp; oldCap) == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果原 oldCap 为 10000 的话，那么扩容后的 newCap 则为 100000，会比原来多出一位。所以我们只要知道原索引值的前一位是 0 还是 1 即可，如果是 0，那么它和新容量与后还是 0 并不改变索引的值，如果是 1 的话，那么索引值会增加 oldCap。&lt;/p&gt;

&lt;p&gt;这样就分两步拆分当前链表，一条链表是不需要移动的，依然保存在当前索引值的结点上，另一条则需要变动到 index + oldCap 的索引位置上。&lt;/p&gt;

&lt;p&gt;这里我们只介绍了普通链表的分裂情况，至于红黑树的裂变其实是类似的，依然分出一些结点到 index + oldCap 的索引位置上，只不过遍历的方式不同而已。&lt;/p&gt;

&lt;p&gt;这样，我们对于 resize 这个扩容的方法已经解析完成了，下面接着看 putVal 方法，篇幅比较长，该方法的源码已经在介绍 resize 之前贴出，建议读者根据自己的 jdk 对照着理解。&lt;/p&gt;

&lt;p&gt;上面我们说到，如果在 put 一个元素的时候判断内部的 table 数组还未初始化，那么调用 resize 根据相应的参数信息初始化数组。接下来的这个判断语句就很简单了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
   tab[i] = newNode(hash, key, value, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据键的 hash 值找到对应的索引位置，如果该位置为 null，说明还没有头结点，于是 newNode 并存储在该位置上。&lt;/p&gt;

&lt;p&gt;否则的话说明该位置已经有头结点了，或者说已经存在一个链表或红黑树了，那么我们要做的只是新建一个节点添加到链表或者红黑树的最后位置即可。&lt;/p&gt;

&lt;p&gt;第一步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (p.hash == hash &amp;amp;&amp;amp;((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
      e = p;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p 指向当前节点，如果我们要插入的节点的键以及键所对应的 hash 值和 p 节点完全一样的话，那么说明这次 put 是一次修改操作，新建一个引用指向这个需要修改的节点。&lt;/p&gt;

&lt;p&gt;第二步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if (p instanceof TreeNode)
     e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前 p 节点是红黑树结点，那么需要调用不同于链表的的添加节点的方法来添加一个节点到红黑树中。（主要是维持平衡，建议读者去了解下红黑树，此处没有深谈是限于它的复杂度和文章篇幅）。&lt;/p&gt;

&lt;p&gt;第三步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else {
     for (int binCount = 0; ; ++binCount) {
     if ((e = p.next) == null) {
         p.next = newNode(hash, key, value, null);
         if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) 
             treeifyBin(tab, hash);
         break;
     }
    if (e.hash == hash &amp;amp;&amp;amp;((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
         break;
    p = e;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要处理的是向普通链表的末尾添加一个新的结点，e 不断地往后移动，如果发现 e 为 null，那么说明已经到链表的末尾了，那么新建一个节点添加到链表的末尾即可，因为 p 是 e 的父节点，所以直接让 p.next 指向新节点即可。添加之后，如果发现链表长度超过 8，那么将链表转储成红黑树。&lt;/p&gt;

&lt;p&gt;在遍历的过程中，如果发现 e 所指向的当前结点和我们即将插入的节点信息完全匹配，那么也说明这是一次修改操作，由于 e 已经指向了该需要被修改的结点，所以直接 break 即可。&lt;/p&gt;

&lt;p&gt;那么最终，无论是第一步中找到的头节点即需要被修改的节点，还是第三步在遍历中找到的需要被修改的节点，它们的引用都是 e，此时我们只需要用传入的 Value 值替换 e 指向的节点的 value 即可。正如这段代码一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (e != null) { // existing mapping for key
     V oldValue = e.value;
     if (!onlyIfAbsent || oldValue == null)
          e.value = value;
     afterNodeAccess(e);
     return oldValue;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 e 为 null，那更简单了，说明此次 put 是添加新元素并且新元素也已经在上述代码中被添加到 HashMap 中了，我们只需要关心下，新加入一个元素后是否达到数组的阈值，如果是则调用 resize 方法扩大数组容量。该方法已经详细阐述过，此处不再赘述。&lt;/p&gt;

&lt;p&gt;所以，这个 put 方法是集添加与修改一体的一个方法，如果执行的是添加操作则会返回 null，是修改操作则会返回旧结点的 value 值。&lt;/p&gt;

&lt;p&gt;那么至此，我们对添加操作的内部实现想必已经了解的不错了，接下来看看删除操作的内部实现。&lt;/p&gt;

&lt;h2 id=&#34;remove-方法的具体实现&#34;&gt;remove 方法的具体实现&lt;/h2&gt;

&lt;p&gt;删除操作就是一个查找+删除的过程，相对于添加操作其实容易一些，但那是你基于上述添加方法理解的不错的前提下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V remove(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据键值删除指定节点，这是一个最常见的操作了。显然，removeNode 方法是核心。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;
    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
        (p = tab[index = (n - 1) &amp;amp; hash]) != null) {
        Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key ||
                         (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||(value != null &amp;amp;&amp;amp; value.equals(v)))) {
            if (node instanceof TreeNode)                                                                     ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除操作需要保证在表不为空的情况下进行，并且 p 节点根据键的 hash 值对应到数组的索引，在该索引处必定有节点，如果为 null ，那么间接说明此键所对应的结点并不存在于整个 HashMap 中，这是不合法的，所以首先要在这两个大前提下才能进行删除结点的操作。&lt;/p&gt;

&lt;p&gt;第一步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (p.hash == hash &amp;amp;&amp;amp;((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
     node = p;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要删除的结点就是这个头节点，让 node 引用指向它。否则说明待删除的结点在当前 p 所指向的头节点的链表或红黑树中，于是需要我们遍历查找。&lt;/p&gt;

&lt;p&gt;第二步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if ((e = p.next) != null) {
     if (p instanceof TreeNode)
          node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
     else {
         do {
              if (e.hash == hash &amp;amp;&amp;amp;((k = e.key) == key ||(key != null &amp;amp;&amp;amp; key.equals(k)))) {
                     node = e;
              break;
         }
         p = e;
         } while ((e = e.next) != null);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果头节点是红黑树结点，那么调用红黑树自己的遍历方法去得到这个待删结点。否则就是普通链表，我们使用 do while 循环去遍历找到待删结点。找到节点之后，接下来就是删除操作了。&lt;/p&gt;

&lt;p&gt;第三步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||(value != null &amp;amp;&amp;amp; value.equals(v)))) {
       if (node instanceof TreeNode)
                    ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
       else if (node == p)
            tab[index] = node.next;
       else
            p.next = node.next;
       ++modCount;
       --size;
       afterNodeRemoval(node);
       return node;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除操作也很简单，如果是红黑树结点的删除，直接调用红黑树的删除方法进行删除即可，如果是待删结点就是一个头节点，那么用它的 next 结点顶替它作为头节点存放在 table[index] 中，如果删除的是普通链表中的一个节点，用该结点的前一个节点直接跳过该待删结点指向它的 next 结点即可。&lt;/p&gt;

&lt;p&gt;最后，如果 removeNode 方法删除成功将返回被删结点，否则返回 null。&lt;/p&gt;

&lt;p&gt;这样，相对复杂的 put 和 remove 方法的内部实现，我们已经完成解析了。下面看看其他常用的方法实现，它们或多或少都于这两个方法有所关联。&lt;/p&gt;

&lt;h2 id=&#34;其他常用的方法介绍&#34;&gt;其他常用的方法介绍&lt;/h2&gt;

&lt;p&gt;除了常用的 put 和 remove 两个方法外，HashMap 中还有一些好用的方法，下面我们简单的学习下它们。&lt;/p&gt;

&lt;h3 id=&#34;clear&#34;&gt;clear&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void clear() {
    Node&amp;lt;K,V&amp;gt;[] tab;
    modCount++;
    if ((tab = table) != null &amp;amp;&amp;amp; size &amp;gt; 0) {
        size = 0;
        for (int i = 0; i &amp;lt; tab.length; ++i)
            tab[i] = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法调用结束后将清除 HashMap 中存储的所有元素。&lt;/p&gt;

&lt;h3 id=&#34;keyset&#34;&gt;keySet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//实例属性 keySet
transient volatile Set&amp;lt;K&amp;gt;        keySet;

public Set&amp;lt;K&amp;gt; keySet() {
    Set&amp;lt;K&amp;gt; ks;
    return (ks = keySet) == null ? (keySet = new KeySet()) : ks;
}
final class KeySet extends AbstractSet&amp;lt;K&amp;gt; {
    public final int size()                 { return size; }
    public final void clear()               { HashMap.this.clear(); }
    public final Iterator&amp;lt;K&amp;gt; iterator()     { return new KeyIterator(); }
    public final boolean contains(Object o) { return containsKey(o); }
    public final boolean remove(Object key) {
        return removeNode(hash(key), key, null, false, true) != null;
    }
    public final Spliterator&amp;lt;K&amp;gt; spliterator() {
        return new KeySpliterator&amp;lt;&amp;gt;(HashMap.this, 0, -1, 0, 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashMap 中定义了一个 keySet 的实例属性，它保存的是整个 HashMap 中所有键的集合。上述所列出的 KeySet 类是 Set 的一个实现类，它负责为我们提供有关 HashMap 中所有对键的操作。&lt;/p&gt;

&lt;p&gt;可以看到，KeySet 中的所有的实例方法都依赖当前的 HashMap 实例，也就是说，我们对返回的 keySet 集中的任意一个操作都会直接映射到当前 HashMap 实例中，例如你执行删除一个键的操作，那么 HashMap 中将会少一个节点。&lt;/p&gt;

&lt;h3 id=&#34;values&#34;&gt;values&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Collection&amp;lt;V&amp;gt; values() {
    Collection&amp;lt;V&amp;gt; vs;
    return (vs = values) == null ? (values = new Values()) : vs;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;values 方法其实和 keySet 方法类似，它返回了所有节点的 value 属性所构成的 Collection 集合，此处不再赘述。&lt;/p&gt;

&lt;h3 id=&#34;entryset&#34;&gt;entrySet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet() {
    Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; es;
    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它返回的是所有节点的集合，或者说是所有的键值对集合。&lt;/p&gt;

&lt;h3 id=&#34;get&#34;&gt;get&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get 方法的内部实现其实是我们介绍过的 put 方法中的一部分，所以此处也不再赘述。&lt;/p&gt;

&lt;p&gt;参考文档：
&lt;a href=&#34;https://blog.csdn.net/fan2012huan/article/details/51097331&#34;&gt;HashMap源码注解 之 静态工具方法hash()、tableSizeFor()&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>