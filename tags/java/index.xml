<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 王子滔的学习笔记</title>
    <link>https://wangzitao6.github.io/tags/java/index.xml</link>
    <description>Recent content in java on 王子滔的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://wangzitao6.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java常量池理解与总结</title>
      <link>https://wangzitao6.github.io/2018-07-03-java%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Sep 2019 16:47:28 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-07-03-java%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/</guid>
      <description>

&lt;h2 id=&#34;什么是常量&#34;&gt;什么是常量&lt;/h2&gt;

&lt;p&gt;用final修饰的成员变量表示常量，值一但确定就无法修改。
final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量&lt;/p&gt;

&lt;h2 id=&#34;jvm常量池&#34;&gt;JVM常量池&lt;/h2&gt;

&lt;p&gt;常量池大体可以分为两种：&lt;strong&gt;静态常量池&lt;/strong&gt;和&lt;strong&gt;运行时常量池&lt;/strong&gt;。
* 静态常量池，也就是*.class文件中的常量池，主要存放编译期生成的各种字面量和符号引用。字面量（Literal）相当于java层面的常量概念，比如字符串和final声明的常量等。符号引用（Symbolic References）可以理解为编译原理方面的，包括：类和接口的全限定名、字段名和描述符、方法名称和描述符。
* 运行时常量池。存在于方法区，个人理解就是在类被加载之后，原来的静态常量池存放到方法区的运行时常量池。除此之外，运行时常量池一个重要特征就是动态性。&lt;/p&gt;

&lt;h3 id=&#34;静态常量池-class文件中的常量池&#34;&gt;静态常量池（Class文件中的常量池）&lt;/h3&gt;

&lt;p&gt;常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类和接口的全限定名&lt;/li&gt;
&lt;li&gt;字段名称和描述符&lt;/li&gt;
&lt;li&gt;方法名称和描述符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###　方法区中的运行时常量池&lt;/p&gt;

&lt;p&gt;运行时常量池是方法区的一部分。
CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项&lt;strong&gt;信息是常量池，用于存放编译期生成的各种字面量和符号引用&lt;/strong&gt;，这部分内容将在类加载后进入方法区的运行时常量池中存放。&lt;/p&gt;

&lt;p&gt;运行时常量池相对于CLass文件常量池的另外一个重要特征是&lt;strong&gt;具备动态性&lt;/strong&gt;，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。&lt;/p&gt;

&lt;h3 id=&#34;常量池的好处&#34;&gt;常量池的好处&lt;/h3&gt;

&lt;p&gt;常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
1. 节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
2. 节省运行时间：比较字符串时，&amp;rdquo;\==&amp;ldquo;比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。&lt;/p&gt;

&lt;p&gt;##　8种基本类型的包装类和常量池&lt;/p&gt;

&lt;h3 id=&#34;java基本类型&#34;&gt;Java基本类型&lt;/h3&gt;

&lt;p&gt;java中基本类型的包装类的大部分都实现了常量池技术,即Byte,Short,Integer,Long,Character,Boolean；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  Integer i1 = 40;
  Integer i2 = 40;
  System.out.println(i1==i2);//输出TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Integer 缓存代码 ：
public static Integer valueOf(int i) {
        assert IntegerCache.high &amp;gt;= 127;
        if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
  Integer i1 = 400;
  Integer i2 = 400;
  System.out.println(i1==i2);//输出false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;java浮点类型&#34;&gt;Java浮点类型&lt;/h3&gt;

&lt;p&gt;两种浮点数类型的包装类Float,Double并没有实现常量池技术。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   Double i1=1.2;
   Double i2=1.2;
   System.out.println(i1==i2);//输出false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用常量池的场景
(1)&lt;code&gt;Integer i1=40&lt;/code&gt;；Java在编译的时候会直接将代码封装成&lt;code&gt;Integer i1=Integer.valueOf(40)&lt;/code&gt;;，从而使用常量池中的对象。
(2)&lt;code&gt;Integer i1 = new Integer(40)&lt;/code&gt;;这种情况下会创建新的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  Integer i1 = 40;
  Integer i2 = new Integer(40);
  System.out.println(i1==i2);//输出false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer比较更丰富的一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println(&amp;quot;i1=i2   &amp;quot; + (i1 == i2));
  System.out.println(&amp;quot;i1=i2+i3   &amp;quot; + (i1 == i2 + i3));
  System.out.println(&amp;quot;i1=i4   &amp;quot; + (i1 == i4));
  System.out.println(&amp;quot;i4=i5   &amp;quot; + (i4 == i5));
  System.out.println(&amp;quot;i4=i5+i6   &amp;quot; + (i4 == i5 + i6));   
  System.out.println(&amp;quot;40=i5+i6   &amp;quot; + (40 == i5 + i6));  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。
Java中的自动装箱与拆箱&lt;/p&gt;

&lt;h2 id=&#34;string类和常量池&#34;&gt;String类和常量池&lt;/h2&gt;

&lt;h3 id=&#34;string对象创建方式&#34;&gt;String对象创建方式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String str1 = &amp;quot;abcd&amp;quot;;
String str2 = new String(&amp;quot;abcd&amp;quot;);
System.out.println(str1==str2);//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。
&lt;strong&gt;只要使用new方法，便需要创建新的对象&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;连接表达式&#34;&gt;连接表达式 +&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。&lt;/br&gt;&lt;/li&gt;
&lt;li&gt;对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String str1 = &amp;quot;str&amp;quot;;
String str2 = &amp;quot;ing&amp;quot;;

String str3 = &amp;quot;str&amp;quot; + &amp;quot;ing&amp;quot;;
String str4 = str1 + str2;
System.out.println(str3 == str4);//false

String str5 = &amp;quot;string&amp;quot;;
System.out.println(str3 == str5);//true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/88aa19fc21c6&#34;&gt;java基础：字符串的拼接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;特例1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final String A = &amp;quot;ab&amp;quot;; // 常量A
public static final String B = &amp;quot;cd&amp;quot;; // 常量B
public static void main(String[] args) {
     String s = A + B;  // 将两个常量用+连接对s进行初始化 
     String t = &amp;quot;abcd&amp;quot;;   
    if (s == t) {   
         System.out.println(&amp;quot;s等于t，它们是同一个对象&amp;quot;);   
     } else {   
         System.out.println(&amp;quot;s不等于t，它们不是同一个对象&amp;quot;);   
     }   
 } 
结果为:
s等于t，它们是同一个对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s=A+B; 等同于：String s=&amp;ldquo;ab&amp;rdquo;+&amp;ldquo;cd&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;特例2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final String A; // 常量A
public static final String B;    // 常量B
static {   
     A = &amp;quot;ab&amp;quot;;   
     B = &amp;quot;cd&amp;quot;;   
 }   
 public static void main(String[] args) {   
    // 将两个常量用+连接对s进行初始化   
     String s = A + B;   
     String t = &amp;quot;abcd&amp;quot;;   
    if (s == t) {   
         System.out.println(&amp;quot;s等于t，它们是同一个对象&amp;quot;);   
     } else {   
         System.out.println(&amp;quot;s不等于t，它们不是同一个对象&amp;quot;);   
     }   
 } 
 结果：
 s不等于t，它们不是同一个对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。&lt;/p&gt;

&lt;h3 id=&#34;string-s1-new-string-xyz&#34;&gt;String s1 = new String(&amp;ldquo;xyz&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;String s1 = new String(&amp;quot;xyz&amp;quot;);&lt;/code&gt; &lt;strong&gt;创建了几个对象？&lt;/strong&gt;
考虑类加载阶段和实际执行时。&lt;/br&gt;
1. 类加载对一个类只会进行一次。&amp;rdquo;xyz&amp;rdquo;在类加载时就已经创建并驻留了（如果该类被加载之前已经有&amp;rdquo;xyz&amp;rdquo;字符串被驻留过则不需要重复创建用于驻留的&amp;rdquo;xyz&amp;rdquo;实例）。驻留的字符串是放在全局共享的字符串常量池中的。&lt;/br&gt;
2. 在这段代码后续被运行的时候，&amp;rdquo;xyz&amp;rdquo;字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s1 持有。
这条语句创建了2个对象。&lt;/p&gt;

&lt;h3 id=&#34;java-lang-string-intern&#34;&gt;java.lang.String.intern()&lt;/h3&gt;

&lt;p&gt;运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。
String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {    
      String s1 = new String(&amp;quot;计算机&amp;quot;);
      String s2 = s1.intern();
      String s3 = &amp;quot;计算机&amp;quot;;
      System.out.println(&amp;quot;s1 == s2? &amp;quot; + (s1 == s2));
      System.out.println(&amp;quot;s3 == s2? &amp;quot; + (s3 == s2));
  }
结果为：
s1 == s2? false
s3 == s2? true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串比较更丰富的一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Test {
 public static void main(String[] args) {   
      String hello = &amp;quot;Hello&amp;quot;, lo = &amp;quot;lo&amp;quot;;
      System.out.println((hello == &amp;quot;Hello&amp;quot;) + &amp;quot; &amp;quot;);
      System.out.println((Other.hello == hello) + &amp;quot; &amp;quot;);
      System.out.println((other.Other.hello == hello) + &amp;quot; &amp;quot;);
      System.out.println((hello == (&amp;quot;Hel&amp;quot;+&amp;quot;lo&amp;quot;)) + &amp;quot; &amp;quot;);
      System.out.println((hello == (&amp;quot;Hel&amp;quot;+lo)) + &amp;quot; &amp;quot;);
      System.out.println(hello == (&amp;quot;Hel&amp;quot;+lo).intern());
 }   
}

class Other { 
    static String hello = &amp;quot;Hello&amp;quot;; 
}

package other;
public class Other { 
    public static String hello = &amp;quot;Hello&amp;quot;; 
}
结果为：

true true true true false true
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在同包同类下,引用自同一String对象&lt;/li&gt;
&lt;li&gt;在同包不同类下,引用自同一String对象&lt;/li&gt;
&lt;li&gt;在不同包不同类下,依然引用自同一String对象&lt;/li&gt;
&lt;li&gt;在编译成.class时能够识别为同一字符串的,自动优化成常量,引用自同一String对象&lt;/li&gt;
&lt;li&gt;在运行时创建的字符串具有独立的内存地址,所以不引用自同一String对象&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Integer的IntegerCache</title>
      <link>https://wangzitao6.github.io/2019-08-26-integer%E7%9A%84integercache/</link>
      <pubDate>Mon, 26 Aug 2019 10:23:46 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-26-integer%E7%9A%84integercache/</guid>
      <description>&lt;p&gt;首先我们来看这样一个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int m = 10;
int n = 10;
System.out.println(m == n);

int j = 128;
int k = 128;
System.out.println(j == k);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;true
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现这样的一个结果大家都意外。&lt;/p&gt;

&lt;p&gt;下面我们再看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer a = 10;
Integer b = 10;
System.out.println(a == b);

Integer c = 128;
Integer d = 128;
System.out.println(c == d);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为，Integer是包装类型，是Object对象，因此==比较的是Integer指向的内存地址。然而-128~127直接的Integer数据直接缓存进入常量池（IntegerCache），所以这个区间的比较返回true，其他区间返回false。当然，new的Integer对象不适用。&lt;/p&gt;

&lt;p&gt;看下Integer源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(String s) throws NumberFormatException {
    return Integer.valueOf(parseInt(s, 10));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法。&lt;/br&gt;
我们
Integer a = 10 或者 Integer c = 200 都进行了一次自动装箱。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer a = 10;
//等价于：
Integer a = Integer.valueOf(10);

Integer c = 128
//等价于：
Integer a = Integer.valueOf(128);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer在赋值时自动装箱，调用valueOf(),其中valueOf源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到如果这个数值在cache数组的范围内（low和high之间），就返回cache缓存数组的中的数据，否则产生一个新的Integer值。其IntegerCache源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty(&amp;quot;java.lang.Integer.IntegerCache.high&amp;quot;);
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k &amp;lt; cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high &amp;gt;= 127;
    }

    private IntegerCache() {}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常这个范围是-128-127，然而这个范围的最大值是可变的，可以通过-XX:AutoBoxCacheMax=&lt;size&gt;参数去修改这个值，在JVM初始化的时候，这个值被写入sun.misc.VM class系统私有配置文件中，并加载。&lt;/p&gt;

&lt;p&gt;所以这就是为什么在阿里巴巴Java开发手册的OOP规约中强制使用equals比较两个Integer的值&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;4.7【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。
说明： 对于 Integer var=?在-128 至 127 之间的赋值， Integer 对象是在
IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行
判断。
但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，
推荐使用 equals 方法进行判断&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。
有 ByteCache 用于缓存 Byte 对象
有 ShortCache 用于缓存 Short 对象
有 LongCache 用于缓存 Long 对象
有 CharacterCache 用于缓存 Character 对象
Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java位运算</title>
      <link>https://wangzitao6.github.io/2019-08-24-java%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sat, 24 Aug 2019 15:09:25 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-24-java%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>

&lt;h2 id=&#34;单位换算&#34;&gt;单位换算&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;bit：位
一个二进制数据0或1，是1bit；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;byte：字节
1 byte = 8 bit , 存储空间的基本计量单位；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个英文字符占一个字节
1 字母 = 1 byte = 8 bit；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个汉字占2个字节
1 汉字 = 2 byte = 16 bit；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;支持的数据类型&#34;&gt;支持的数据类型&lt;/h2&gt;

&lt;p&gt;首先明确一点，Java中的位运算是针对整型的数据类型进行运算的，所以操作数必须是一下五种之一。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;所占位数（bit）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;数据存储方式&#34;&gt;数据存储方式&lt;/h2&gt;

&lt;p&gt;计算机中存储的数据最终是以二进制存储(补码存储)，如int类型的十进制数字10表示为32bit的二进制：&lt;/p&gt;

&lt;p&gt;0000 0000 0000 0000 0000 0000 0000 1010&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：数据在计算机中都是以反码形式存在。正数的的原码与反码相同。
    有关原码、反码、补码的知识，请看另一个章节&lt;a href=&#34;https://wangzitao6.github.io/2019-08-23-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/&#34;&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;位运算符&#34;&gt;位运算符&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对应位同为1时，才为1，否则全为0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;按位或(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对应位只要有1时，即为1，否则全为0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;按位非(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对每位进行取反&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;只要对应为不同即为1&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;左移(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;左移 左边最高位丢弃，右边补齐0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;右移(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;最高位是0，左边补齐0；最高为是1，左边补齐1&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;无符号右移(&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;无论操作数是正数还是负数，高位都是补0&lt;/font&gt;&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;按位与&#34;&gt;按位与 &amp;amp;&lt;/h3&gt;

&lt;p&gt;规则：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 对应位同为1时，才为1，否则全为0（对应位只要有0，全为0，否则为1） &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 127;
int b = 128;
System.out.println(&amp;quot;127 &amp;amp; 128 的结果是：&amp;quot;+(a &amp;amp; b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127 &amp;amp; 128 的结果是：0

解析: 
127的二进制(补码)：00000000 00000000 00000000 01111111
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 &amp;amp; 规则结果：  00000000 00000000 00000000 00000000
所以结果为0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位或&#34;&gt;按位或 |&lt;/h3&gt;

&lt;p&gt;规则： &lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 对应位只要有1时，即为1，否则全为0（对应位只有全是0时，结果才是0，否则为1） &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 127;
int b = 128;
System.out.println(&amp;quot;127 | 128 的结果是：&amp;quot;+(a | b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127 | 128 的结果是：255

解析: 
127的二进制(补码)：00000000 00000000 00000000 01111111
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 | 规则结果：  00000000 00000000 00000000 11111111
最高为0，为正数，原码补码一样，所以结果为255
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位非&#34;&gt;按位非 ~&lt;/h3&gt;

&lt;p&gt;规则： &lt;strong&gt;&lt;font color = &#34;red&#34;&gt;对每位进行取反 &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 128;
System.out.println(&amp;quot;~128 的结果是：&amp;quot; + ~ a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~128 的结果是：-129

解析: 
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 ~ 规则结果：  11111111 11111111 11111111 01111111
最高为1，为负数。
补码：11111111 11111111 11111111 01111111
反码：11111111 11111111 11111111 01111110
原码：10000000 00000000 00000000 10000001
结果为 -129
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位异或&#34;&gt;按位异或 ^&lt;/h3&gt;

&lt;p&gt;规则： &lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 只要对应为不同即为1。 &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 127;
int b = 128;
System.out.println(&amp;quot;127 ^ 128 的结果是：&amp;quot; + (a ^  b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127 ^ 128 的结果是：255

解析: 
127的二进制(补码)：00000000 00000000 00000000 01111111
128的二进制(补码)：00000000 00000000 00000000 10000000
根据 | 规则结果：  00000000 00000000 00000000 11111111
最高为0，为正数，原码补码一样，所以结果为255
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;位移动运算符&#34;&gt;位移动运算符&lt;/h3&gt;

&lt;h4 id=&#34;左移&#34;&gt;左移 &amp;lt;&amp;lt;&lt;/h4&gt;

&lt;p&gt;规则：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; &amp;lt;&amp;lt; :左移 左边最高位丢弃，右边补齐0; &lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左移的规则只记住一点：丢弃最高位，0补最低位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通用格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value &amp;lt;&amp;lt; num 
num : 指要移位值   
value : 指移动的位数。
意思是value向左位移num位，左移num位，相当于乘以2^num
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 1;
System.out.println(&amp;quot;1 &amp;lt;&amp;lt; 2 的结果是：&amp;quot; + (a &amp;lt;&amp;lt; 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果(图片来自于网络)：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/26/%E5%B7%A6%E7%A7%BB2.png&#34; alt=&#34;左移&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 &amp;lt;&amp;lt; 2 的结果是：4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;右移&#34;&gt;右移 &amp;gt;&amp;gt;&lt;/h4&gt;

&lt;p&gt;规则：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; &amp;gt;&amp;gt;:右移, 最高位是0(正数时)，左边补齐0；最高为是1(正数时)，左边补齐1，保持为负数；&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;m&amp;gt;&amp;gt;n即相当于m除以2的n次方，得到的为整数时，即为结果。如果结果为小数，此时会出现两种情况：&lt;/p&gt;

&lt;p&gt;1 如果m为正数，得到的商会无条件 的舍弃小数位；&lt;/p&gt;

&lt;p&gt;2 如果m为负数，舍弃小数部分，然后把整数部分加+1得到位移后的值。&lt;/p&gt;

&lt;p&gt;通用格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value &amp;gt;&amp;gt; num 
num : 指要移位值   
value : 指移动的位数。
意思是value向左位移num位，左移num位，相当于除以2^num
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 12;
System.out.println(&amp;quot;12 &amp;gt;&amp;gt; 2 的结果是：&amp;quot; + (a &amp;gt;&amp;gt; 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果(图片来自于网络，图中稍有错误，其中10应该为12)：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/26/%E5%8F%B3%E7%A7%BB.png&#34; alt=&#34;右移&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 &amp;lt;&amp;lt; 2 的结果是：4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;无符号右移&#34;&gt;无符号右移 &amp;gt;&amp;gt;&amp;gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;无符号右移&amp;gt;&amp;gt;&amp;gt; 与 右移&amp;gt;&amp;gt; 的区别就是无论操作数是正数还是负数，高位都是补0&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 12;
System.out.println(&amp;quot;12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：&amp;quot; + (a &amp;gt;&amp;gt;&amp;gt; 2));

int b = -12;
System.out.println(&amp;quot;-12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：&amp;quot; + (b &amp;gt;&amp;gt;&amp;gt; 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：3
-12 &amp;gt;&amp;gt;&amp;gt; 2 的结果是：1073741821

解析: 
12 &amp;gt;&amp;gt;&amp;gt; 2 跟 12 &amp;gt;&amp;gt; 2 过程一样，上面有过程，我们说下 -12 &amp;gt;&amp;gt;&amp;gt; 2
-12的原码：        10000000 00000000 00000000 00001100
-12的二进制(补码): 11111111 11111111 11111111 11110100
右移2位：           11111111 11111111 11111111 11110100
补齐：            0011111111 11111111 11111111 111101
注意这个补齐因为是无符号的，最高位补0，结果为正数
最高为0，为正数，原码补码一样，所以结果为的结果是：1073741821
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Int类型强制转换byte类型</title>
      <link>https://wangzitao6.github.io/2019-08-24-int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2byte%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 24 Aug 2019 11:13:05 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-24-int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2byte%E7%B1%BB%E5%9E%8B/</guid>
      <description>

&lt;h2 id=&#34;java中为什么int类型的-129转换成byte类型的会变成127&#34;&gt;java中为什么int类型的-129转换成byte类型的会变成127&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;int类型一般是4个字节，一个字节有8位，这样int型数据二进制的完整形式有32位，而byte表示一个字节，于是byte类型数据二进制的完整形式有8位。&lt;/strong&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;二进制数据在计算机内是以二进制存储的，要注意一点，计算机在存储某个数据时，是存储的数据的补码，说明一下补码与原码关系，正数补码与原码相同，负数补码是原码减1后取反。
&lt;/br&gt;&lt;br /&gt;
根据上面阐述，129的原码是00000000 00000000 00000000 10000001 ，负数最高位取1，那么-129便是10000000 00000000 00000000 10000001 ，补码计算：取反为11111111 11111111 11111111 01111110（最高位是符号位，不参与取反），加1为11111111 11111111 11111111 01111111 ，现在转换为byte，只有8位，于是只能保留低8位，前面24位丢去，得到01111111，符号位为0,代表正数，原码、反码、补码一致。原码也是01111111。这就对应着十进制的127.&lt;/p&gt;

&lt;h2 id=&#34;int类型的129转换成byte类型的会变成-127&#34;&gt;int类型的129转换成byte类型的会变成-127&lt;/h2&gt;

&lt;p&gt;129为正数，原码补码反码相同：00000000 00000000 00000000 10000001
现在转换为byte，只有8位，于是只能保留低8位，前面24位丢去，得到10000001，&lt;/p&gt;

&lt;p&gt;补码为10000001， 开头为1 为负数   反码与补码不一样  为补码减1  得到反码：10000000
负数反码转成原码  符号位不变，其他位取反 得到原码：11111111
为 -127&lt;/p&gt;

&lt;h2 id=&#34;int类型的128转换成byte类型的会变成-128&#34;&gt;int类型的128转换成byte类型的会变成-128&lt;/h2&gt;

&lt;p&gt;128为正数，原码补码反码相同：00000000 00000000 00000000 10000000
现在转换为byte，只有8位，于是只能保留低8位，前面24位丢去，得到10000000，
因为补码为10000000，所以为-128&lt;/p&gt;

&lt;p&gt;在规定中，8位二进制码能表示的反码范围是-127~127。
-128没有反码。
那么，为什么规定-128没有反码呢?下面解释。
首先看-0，[-0]原码=1000 000，其中1是符号位，根据反码规定，算出[-0]反码=1111 1111，
再看-128，[-128]原码=1000 000，假如让-128也有反码，根据反码规定，则[-128]反码=1111 1111，
你会发现，-128的反码和-0的反码相同，所以为了避免面混淆，有了-0，便不能有-128，这是反码规则决定的。&lt;/p&gt;

&lt;p&gt;-128的原码是10000000。
补码是反码+1：依然是10000000。（因为加1进位了，但是只有8位，所以进位无法显示）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>原码 补码 反码</title>
      <link>https://wangzitao6.github.io/2019-08-23-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/</link>
      <pubDate>Fri, 23 Aug 2019 16:28:33 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-23-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/</guid>
      <description>

&lt;h2 id=&#34;java数据类型&#34;&gt;Java数据类型&lt;/h2&gt;

&lt;p&gt;了解原码、补码、反码之前，我们先看下java的数据类型：&lt;/p&gt;

&lt;p&gt;Java基本类型共有八种，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;boolean：只有true和false两个取值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;char：16位，存储Unicode码，用单引号赋值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上各种类型占用内存：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;大小/位&lt;/th&gt;
&lt;th&gt;大小范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte(位)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-128~127&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;short(短整数)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;-32768~32767&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int(整数)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;-2147483648~2147483647&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;long(长整数)&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;-9223372036854775808~9223372036854775807&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float(单精度)&lt;/td&gt;
&lt;td&gt;浮点型&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;1.4E-45~3.4028235E38&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;double(双精度)&lt;/td&gt;
&lt;td&gt;浮点型&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;4.9E-324~1.7976931348623157E308&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;char(字符)&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;0~65535&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;布尔型&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;true或false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;byte占用一个字节，取值范围是-128~127,因为在二进制中，最高位是符号位，0表示正、1表示负，其他位是数据位。 byte共占8个bit，最大值为01111111，转成十进制为127，最小值为10000000，1是符号位，表示负数，转成十进制为128。所以最小值为-128 ，具体为什么是-128？二进制和十进制如何在底层转换？将涉及到原码、反码、补码，我们往下继续看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原码-补码-反码&#34;&gt;原码 补码 反码&lt;/h2&gt;

&lt;h3 id=&#34;机器数和真值&#34;&gt;机器数和真值&lt;/h3&gt;

&lt;p&gt;我们先了解下数据在计算机中是怎么表示的&lt;/p&gt;

&lt;h4 id=&#34;机器数&#34;&gt;机器数&lt;/h4&gt;

&lt;p&gt;　一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.比如，十进制中的数 &lt;strong&gt;3&lt;/strong&gt; ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。&lt;/p&gt;

&lt;h4 id=&#34;真值&#34;&gt;真值&lt;/h4&gt;

&lt;p&gt;因为第一位是符号位，所以机器数的形式值就不等于真正的数值。
例如上面的有符号数10000011，其最高位1代表负，其真正数值是-3而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。&lt;/br&gt;
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1&lt;/p&gt;

&lt;h3 id=&#34;原码概念&#34;&gt;原码概念&lt;/h3&gt;

&lt;p&gt;数值X的原码记为[x]原，如果机器字长为n(即采用n个二进制位表示数据)。则&lt;font color = &#34;red&#34;&gt;最高位是符号位。0表示正号，1表示负号&lt;/font&gt;，其余的n-1位表示数值的绝对值。&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;数值零的原码表示有两种形式:[+0]原=0000 0000   ,-[0]原=1000 0000.&lt;/p&gt;

&lt;p&gt;例子：若机器字长n等于8，则&lt;/p&gt;

&lt;p&gt;[+1]原=0000 00001           [-1]原=1000 00001  &lt;/p&gt;

&lt;p&gt;[+127]原=0111 1111          [-127]原=1111 1111&lt;/p&gt;

&lt;p&gt;[+45]原=0010 1101           [-45]原=1010 1101    &lt;/p&gt;

&lt;p&gt;可见，原码，在计算数值上出问题了，当然，你也可以实验下，原码在计算正数和正数的时候，它是一点问题都没有的，但是出现负数的时候就出现问题了。所以才会有我下面将的问题：反码&lt;/p&gt;

&lt;h3 id=&#34;反码概念&#34;&gt;反码概念&lt;/h3&gt;

&lt;p&gt;数值X的反码记作[x]反，如果机器字长为n，则&lt;font color = &#34;red&#34;&gt;最高位是符号位，0表示正号，1表示负号&lt;/font&gt;，&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;正数的反码与原码相同，负数的反码 则是其绝对值按位求反&lt;/strong&gt;&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;数值0的反码表示有两种形式：[+0]反=0000 0000   ,-[0]反=1111 1111.&lt;/p&gt;

&lt;p&gt;例子：若机器字长n等于8，则&lt;/p&gt;

&lt;p&gt;[+1]反=0000 00001           [-1]反=1111 1110 &lt;/p&gt;

&lt;p&gt;[+127]反=0111 1111          [-127]反=1000 0000&lt;/p&gt;

&lt;p&gt;[+45]反=0010 1101           [-45]反=1101 0010  &lt;/p&gt;

&lt;p&gt;在看反码计算的问题：&lt;/p&gt;

&lt;p&gt;1+（-1）=0   |  （0000 0001）反+（1111 1110）反=（1111 1111）反=（1000 0000）原=【-0】  可以看到，虽然是-0，但是问题还不是很大&lt;/p&gt;

&lt;p&gt;1+（-2）=-1  |  （0000 0001）反+（1111 1101）反=（1111 1110）反=（1000 0001）原=【-1】  可以看到，没有问题&lt;/p&gt;

&lt;p&gt;-1+（2）=1   |  （1111 1110）反+（0000 0010）反=（0000 0000）反=（0000 0000）原=【0】  可以看到，问题发生了，因为溢出，导致结果变为0了。&lt;/p&gt;

&lt;p&gt;所以，看以看到，用反码表示，问题依然没有解决，所以，出现了下面的补码&lt;/p&gt;

&lt;h3 id=&#34;补码概念&#34;&gt;补码概念&lt;/h3&gt;

&lt;p&gt;数值X的补码记作[x]补，如果机器字长为n，则&lt;font color = &#34;red&#34;&gt;最高位是符号位，0表示正号，1表示负号&lt;/font&gt;，&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;正数的补码与原码反码都相同，负数的补码则等于其反码的末尾加1&lt;/strong&gt;&lt;/font&gt;。&lt;/br&gt;
数值0的补码表示有唯一的编码：[+0]补=0000 0000   ,-[0]补=0000 0000.&lt;/p&gt;

&lt;p&gt;例子：若机器字长n等于8，则&lt;/p&gt;

&lt;p&gt;[+1]补=0000 00001           [-1]补=1111 1111  &lt;/br&gt;
[+127]补=0111 1111          [-127]补=1000 0001&lt;/br&gt;
[+45]补=0010 1101           [-45]补=1101 0011  &lt;/br&gt;&lt;/p&gt;

&lt;p&gt;在看补码计算的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1+（-1）=0  |  （0000 0001）补+（1111 1111）补=（0000 0000）补=（0000 0000）原=【0】  可以看到。没有问题

1+（-2）=-1 |  （0000 0001）补+（1111 1110）补=（1111 1111）补=（1000 0001）原=【-1】  可以看到，没有问题

-1+（2）=1  |  （1111 1111）补+（0000 0010）补=（0000 0001）补 =（0000 0001）原=【1】  可以看到，没有问题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的计算，我们发现，用补码的方式，就不存在在原码和反码中存在的计算问题了。其实，这也是&lt;font color = &#34;red&#34;&gt;计算机表达带符号整数用补码&lt;/font&gt;的原因。如果，你觉得我举得例子太少，缺少代表行，你可以自己试试。不过，放心补码一定是不会存在原码和反码的问题的。&lt;/p&gt;

&lt;p&gt;明白了计算机中补数的道理，那么就明白补码的问题了。还是用例子说明：&lt;/p&gt;

&lt;p&gt;在计算机中计算十进制 1+（-2）。&lt;/p&gt;

&lt;p&gt;1的原码是：0000 0001&lt;/p&gt;

&lt;p&gt;-2的原码是：1000 0010&lt;/p&gt;

&lt;p&gt;-2的补码是：1111 1110   这个二进制换做无符号的整数大小就是254，而8位二进制数的M=2^8=256。（很多文章中把M写成2^7，这根本就是不对的，根本没有解决符号位的问题）&lt;/p&gt;

&lt;p&gt;你发现什么了没，当换成补码后，-2和254就是补数的关系。&lt;/p&gt;

&lt;p&gt;也就是1+（-2）  等价于了 1+254了。&lt;/p&gt;

&lt;p&gt;这样做，好处在什么地方，你自己都可以看得到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;利用补数和溢出的原理，减法变成了加法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;符号位不在是约束计算的问题，不会存在原码中的问题了，因为变成补码后，虽然最高位依然是1，但是这个1就不在是最为符号位了，而是作为一个普通的二进制位，参与运算了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;补码计算规则&#34;&gt;补码计算规则&lt;/h4&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;正数：原码 = 补码 = 反码&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;负数：反码 = 符号不变，其它位取反&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;补码 = 反码 + 1&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;十进制数&lt;/th&gt;
&lt;th&gt;原码&lt;/th&gt;
&lt;th&gt;反码&lt;/th&gt;
&lt;th&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;td&gt;0101 0101&lt;/td&gt;
&lt;td&gt;0101 0101&lt;/td&gt;
&lt;td&gt;0101 0101&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-85&lt;/td&gt;
&lt;td&gt;1101 0101&lt;/td&gt;
&lt;td&gt;1010 1010&lt;/td&gt;
&lt;td&gt;1010 1011&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;0000 1001&lt;/td&gt;
&lt;td&gt;0000 1001&lt;/td&gt;
&lt;td&gt;0000 1001&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-9&lt;/td&gt;
&lt;td&gt;1000 1001&lt;/td&gt;
&lt;td&gt;1111 0110&lt;/td&gt;
&lt;td&gt;1111 0111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;请计算出 -1 + 1：&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 1 原码  :  0000 0000 0000 0001&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 -1 原码  : 1000 0000 0000 0001&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 -1 反码  :  1111  1111  1111  1110&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;十进制的 -1 补码  :  1111  1111  1111  1111&lt;/strong&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;计算-1+1即得 ,即-1补码+1的补码&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;1111 1111 1111 1111 + 0000 0000 0000 0001 = 0000 0000 0000 0000&lt;/strong&gt;&lt;/br&gt;
&lt;strong&gt;结果即为0&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HashMap实现原理</title>
      <link>https://wangzitao6.github.io/2019-09-12-hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 12 Sep 2018 11:49:31 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-09-12-hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;什么是哈希表&#34;&gt;什么是哈希表&lt;/h2&gt;

&lt;p&gt;哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;线性链表&lt;/strong&gt;：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们知道，数据结构的物理存储结构只有两种：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;顺序存储结构&lt;/font&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;链式存储结构&lt;/font&gt;&lt;/strong&gt;（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。&lt;/p&gt;

&lt;p&gt;　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;存储位置 = f(关键字)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　其中，这个函数f一般称为&lt;strong&gt;哈希函数&lt;/strong&gt;，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/29/29-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。&lt;/p&gt;

&lt;h3 id=&#34;哈希冲突&#34;&gt;哈希冲突&lt;/h3&gt;

&lt;p&gt;　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，&lt;strong&gt;当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞&lt;/strong&gt;。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:&lt;strong&gt;开放定址法&lt;/strong&gt;（发生冲突，继续寻找下一块未被占用的存储地址），&lt;strong&gt;再散列函数法&lt;/strong&gt;，&lt;strong&gt;链地址法&lt;/strong&gt;，而HashMap即是采用了链地址法，也就是&lt;strong&gt;数组+链表&lt;/strong&gt;的方式，&lt;/p&gt;

&lt;h2 id=&#34;hashmap实现原理&#34;&gt;HashMap实现原理&lt;/h2&gt;

&lt;p&gt;HashMap的主干是一个Node数组。Node是HashMap的基本组成单元，每一个Node包含一个key-value键值对。&lt;/p&gt;

&lt;p&gt;Node是HashMap中的一个静态内部类。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    final int hash; //对key的hashcode值进行hash运算后得到的值，存储在Node，避免重复计算
    final K key;
    V value;
    Node&amp;lt;K,V&amp;gt; next;//存储指向下一个Node的引用，单链表结构

    Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
     /**省略此处代码**/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，HashMap的整体结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/29/29-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单来说，HashMap由数组+链表组成的，&lt;font color = &#34;red&#34;&gt;数组是HashMap的主体&lt;/font&gt;，&lt;font color = &#34;red&#34;&gt;链表则是主要为了解决哈希冲突而存在的&lt;/font&gt;，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好&lt;/strong&gt;。(&lt;font color = &#34;red&#34;&gt;jdk 8 之前，其内部是由数组+链表来实现的，而 jdk 8 对于链表长度超过 8 的链表将转储为红黑树&lt;/font&gt;，本文讨论的是jdk8格式的。)&lt;/p&gt;

&lt;p&gt;其他几个重要字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//默认的容量，即默认的数组长度 16
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;

//最大的容量，即数组可定义的最大长度 
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是上述提到的数组，数组的元素都是 Node 类型，数组中的每个 Node 元素都是一个链表的头结点，通过它可以访问连接在其后面的所有结点。其实你也应该发现，上述的容量指的就是这个数组的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//HashMap的主干数组，可以看到就是一个Node数组，初始值为空数组{}
transient Node&amp;lt;K,V&amp;gt;[] table;

//实际存储的键值对个数
transient int size;

//用于迭代防止结构性破坏的标量，由于HashMap非线程安全，
//在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），
//需要抛出异常ConcurrentModificationException
transient int modCount;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这几个属性是相关的，threshold 代表的是一个阈值。伴随着元素不断的被添加进数组，一旦数组中的元素数量达到这个阈值，那么表明数组应该被扩容而不应该继续任由元素加入。而这个阈值的具体值则由负载因子（loadFactor）和数组容量来决定。
公式：&lt;code&gt;threshold = capacity * loadFactor&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//map中实际存储的key-value键值对的个数
transient int size;

//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；
//当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。
//HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;

//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;

//HashMap 中默认负载因子为 0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，有关 HashMap 的基本属性大致介绍如上。下面我们看看它的几个重载的构造函数。HashMap有4个构造器，其他构造器如果用户没有传入&lt;code&gt;initialCapacity&lt;/code&gt; 和&lt;code&gt;loadFactor&lt;/code&gt;这两个参数，会使用默认值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;initialCapacity&lt;/code&gt;默认为16，&lt;code&gt;loadFactory&lt;/code&gt;默认为0.75&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public HashMap(int initialCapacity, float loadFactor) {
    　//此处对传入的初始容量进行校验，最大范围 0 &amp;lt; MAXIMUM_CAPACITY &amp;lt;= 1&amp;lt;&amp;lt;30
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; + initialCapacity);
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个最基本的构造函数，需要调用方传入两个参数，&lt;code&gt;initialCapacity&lt;/code&gt; 和 &lt;code&gt;loadFactor&lt;/code&gt;。程序的大部分代码在判断传入参数的合法性，&lt;code&gt;initialCapacity&lt;/code&gt; 小于零将抛出异常，大于 &lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt; 将被限定为 &lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt;。&lt;code&gt;loadFactor&lt;/code&gt; 如果小于等于零或者非数字类型也会抛出异常。&lt;/p&gt;

&lt;p&gt;整个构造函数的核心在对 &lt;code&gt;threshold&lt;/code&gt;的初始化操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可以看到，当在实例化HashMap实例时，如果给定了&lt;code&gt;initialCapacity&lt;/code&gt;，由于HashMap的&lt;code&gt;capacity&lt;/code&gt;都是2的幂，因此这个方法用于找到大于等于&lt;code&gt;initialCapacity&lt;/code&gt;的最小的2的幂（&lt;code&gt;initialCapacity&lt;/code&gt;如果就是2的幂，则返回的还是这个数）。&lt;/p&gt;

&lt;p&gt;下面分析这个算法：
首先，为什么要对cap做减1操作。&lt;code&gt;int n = cap - 1;&lt;/code&gt;
这是为了防止cap已经是2的幂。&lt;strong&gt;如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍&lt;/strong&gt;。如果不懂，要看完后面的几个无符号右移之后再回来看看。
下面看看这几个无符号右移操作：
如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是1（最后有个n+1的操作）。
这里只讨论n不等于0的情况。&lt;/p&gt;

&lt;p&gt;第一次右移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 1;(相当于: n=n|n &amp;gt;&amp;gt;&amp;gt; 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n=000...01xxxxxxx
右移一位后为 n &amp;gt;&amp;gt;&amp;gt; 1 = 000...001xxxxxx  = 000...011xxxxxx
那么n|n &amp;gt;&amp;gt;&amp;gt; 1 = 000...01xxxxxxx|000...001xxxxxx  = 000...011xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二次右移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这个n已经经过了n |= n &amp;gt;&amp;gt;&amp;gt; 1; 操作。假设此时n=16,二进制为000011xxxxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如000&amp;hellip;01111xxxx 。
第三次右移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如000&amp;hellip;011111111 。&lt;/p&gt;

&lt;p&gt;所以从宏观上看，传入的容量无论是处于任何范围，最终都会被打造成比该值大并且比最近的一个 2 的 n 次幂小一的值。为什么这么做？因为 2 的 n 次幂小一的值在二进制角度看全为 1，将有利于 HashMap 中的元素搜索，这一点我们后续将介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以此类推&lt;/strong&gt;
注意，容量最大也就是32bit的正数，因此最后&lt;code&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 16;&lt;/code&gt; ，最多也就32个1，但是这时已经大于了&lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt; ，所以取值到&lt;code&gt;MAXIMUM_CAPACITY&lt;/code&gt; 。
举一个例子说明下吧。
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/08/29/29-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个算法着实牛逼啊！&lt;/p&gt;

&lt;p&gt;那么通过该方法，我们将获得一个 2 的整数次幂的容量的值，此处存放至&lt;code&gt;threshold&lt;/code&gt;，实际上我们获取的是一个有关数组容量的值，不应该存放至&lt;code&gt;阈值 threshold&lt;/code&gt; 中，但在后续实际初始化数组的时候并不会受到影响，这里可能是写 jdk 的大神偷了一次懒吧。&lt;/p&gt;

&lt;p&gt;注意，得到的这个&lt;code&gt;capacity&lt;/code&gt;却被赋值给了&lt;code&gt;阈值 threshold&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.threshold = tableSizeFor(initialCapacity);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始以为这个是个Bug，感觉应该这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。
但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算&lt;/p&gt;

&lt;h2 id=&#34;put-方法的具体实现&#34;&gt;put 方法的具体实现&lt;/h2&gt;

&lt;p&gt;put 方法的源码分析是本篇的一个重点，因为通过该方法我们可以窥探到 HashMap 在内部是如何进行数据存储的，所谓的数组+链表+红黑树的存储结构是如何形成的，又是在何种情况下将链表转换成红黑树来优化性能的。带着一系列的疑问，我们看这个 put 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加一个元素只需要传入一个键和一个值即可，putVal 方法是关键，我已经在该方法中进行了基本的注释，具体的细节稍后详细说明，先从这些注释中大体上建立一个直观的感受。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    //Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt;数组
    //Node&amp;lt;K,V&amp;gt; p,   单链表中存储指向下一个Node的引用
    //n,主干数组的长度
    //i, index索引
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;

    //如果 table 还未被初始化，那么初始化它
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

    //根据键的 hash 值找到该键对应到数组中存储的索引,i = (n - 1) &amp;amp; hash
    //如果 tab[i]为 null，那么说明此索引位置并没有被占用,创建节点
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);

    //tab[i]不为 null，说明此处已经被占用，只需要将构建一个节点插入到这个链表的尾部即可
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;

        //当前结点和将要插入的结点的 hash 和 key 相同，说明这是一次修改操作
        if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;

        //如果 p 这个头结点是红黑树结点的话，以红黑树的插入形式进行插入
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        
        // p 这个头结点属于链表，遍历此条链表，将构建一个节点插入到该链表的尾部
        else {
            for (int binCount = 0; ; ++binCount) {

                //在链表的最后插入
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);

                    //如果插入后链表长度大于等于 8 ，将链表裂变成红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }

                //遍历的过程中，如果发现与某个结点的 hash和key，这依然是一次修改操作 
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //e 不是 null，说明当前的 put 操作是一次修改操作并且e指向的就是需要被修改的结点
        if (e != null) { 
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    //如果添加后，数组容量达到阈值，进行扩容
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从整体上来看，该方法的大致处理逻辑已如上述注释说明，下面我们针对其中的细节进行详细的解释。&lt;/p&gt;

&lt;p&gt;首先，我们看 resize 这个方法是如何对 table 进行初始化的，代码比较多，分两部分进行解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//第一部分
final Node&amp;lt;K,V&amp;gt;[] resize() {
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;

        //拿到旧数组的长度，为0时初始化，其他时扩容
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        
        //说明旧数组已经被初始化完成了，此处需要给旧数组扩容
        if (oldCap &amp;gt; 0) {
            //极限的限定，达到容量限定的极限将不再扩容
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //未达到极限，将数组容量扩大两倍，阈值也扩大两倍
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; 
        }
        //数组未初始化，但阈值不为 0，为什么不为 0 ？
        //上述提到 jdk 大神偷懒的事情就指的这，构造函数根据传入的容量打造了一个合适的数组容量暂存在阈值中
        //这里直接使用
        else if (oldThr &amp;gt; 0) 
            newCap = oldThr;
        //数组未初始化并且阈值也为0，说明一切都以默认值进行构造
        else {
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //这里也是在他偷懒的后续弥补
        //newCap = oldThr 之后并没有计算阈值，所以 newThr = 0
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
****************后续代码......****************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分代码结束后，无论是初始化数组还是扩容，总之，必需的数组容量和阈值都已经计算完成了。下面看后续的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;****************第二部分代码.....****************
//根据新的容量初始化一个数组
Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
table = newTab;
//旧数组不为 null，这次的 resize 是一次扩容行为
if (oldTab != null) {
    //将旧数组中的每个节点位置相对静止地拷贝值新数组中
    for (int j = 0; j &amp;lt; oldCap; ++j) {
        Node&amp;lt;K,V&amp;gt; e;
        //获取头结点
        if ((e = oldTab[j]) != null) {
            oldTab[j] = null;
            //说明链表或者红黑树只有一个头结点，转移至新表
            if (e.next == null)
                newTab[e.hash &amp;amp; (newCap - 1)] = e;
            //如果 e 是红黑树结点，红黑树分裂，转移至新表
            else if (e instanceof TreeNode)
                ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
            //这部分是将链表中的各个节点原序地转移至新表中，我们后续会详细说明
            else { 
                Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                Node&amp;lt;K,V&amp;gt; next;
                do {
                    next = e.next;
                    if ((e.hash &amp;amp; oldCap) == 0) {
                        if (loTail == null)
                            loHead = e;
                        else
                            loTail.next = e;
                        loTail = e;
                    }
                    else {
                        if (hiTail == null)
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                    }
                } while ((e = next) != null);
                if (loTail != null) {
                    loTail.next = null;
                    newTab[j] = loHead;
                }
                if (hiTail != null) {
                    hiTail.next = null;
                newTab[j + oldCap] = hiHead;
                }
            }
        }
    }
}
//不论你是扩容还是初始化，都可以返回 newTab
return newTab;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于第二部分的代码段来说，主要完成的是将旧链表中的各个节点按照原序地复制到新数组中。关于头结点是红黑树的情况我们暂时不去涉及，下面重点介绍下链表的拷贝和优化代码块，这部分代码不再重复贴出，此处直接进行分析，有需要的可以参照上述列出的代码块或者自己的 jdk 进行理解。&lt;/p&gt;

&lt;p&gt;这部分其实是一个优化操作，将当前链表上的一些结点移出来向刚扩容的另一半存储空间放。&lt;/p&gt;

&lt;p&gt;一般我们有如下公式：&lt;code&gt;index = e.hash &amp;amp; (oldCap - 1)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：
e.hash = 010101110010101000101
oldCap = 　10000 
index = 01010111001010100 0101　&amp;amp; 1111 = 0101

newCap = 1000 00
newIndex = 0101011100101010 00101　&amp;amp; 11111 = 00101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随便举个例子，此时的 e 在容量扩大两倍以后的索引值没有变化，所以这部分结点是不需要移动的，那么程序如何判断扩容前后的 index 是否相等呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//oldCap 一定是 100...000 的形式
if ((e.hash &amp;amp; oldCap) == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果原 oldCap 为 10000 的话，那么扩容后的 newCap 则为 100000，会比原来多出一位。所以我们只要知道原索引值的前一位是 0 还是 1 即可，如果是 0，那么它和新容量与后还是 0 并不改变索引的值，如果是 1 的话，那么索引值会增加 oldCap。&lt;/p&gt;

&lt;p&gt;这样就分两步拆分当前链表，一条链表是不需要移动的，依然保存在当前索引值的结点上，另一条则需要变动到 index + oldCap 的索引位置上。&lt;/p&gt;

&lt;p&gt;这里我们只介绍了普通链表的分裂情况，至于红黑树的裂变其实是类似的，依然分出一些结点到 index + oldCap 的索引位置上，只不过遍历的方式不同而已。&lt;/p&gt;

&lt;p&gt;这样，我们对于 resize 这个扩容的方法已经解析完成了，下面接着看 putVal 方法，篇幅比较长，该方法的源码已经在介绍 resize 之前贴出，建议读者根据自己的 jdk 对照着理解。&lt;/p&gt;

&lt;p&gt;上面我们说到，如果在 put 一个元素的时候判断内部的 table 数组还未初始化，那么调用 resize 根据相应的参数信息初始化数组。接下来的这个判断语句就很简单了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
   tab[i] = newNode(hash, key, value, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据键的 hash 值找到对应的索引位置，如果该位置为 null，说明还没有头结点，于是 newNode 并存储在该位置上。&lt;/p&gt;

&lt;p&gt;否则的话说明该位置已经有头结点了，或者说已经存在一个链表或红黑树了，那么我们要做的只是新建一个节点添加到链表或者红黑树的最后位置即可。&lt;/p&gt;

&lt;p&gt;第一步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (p.hash == hash &amp;amp;&amp;amp;((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
      e = p;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p 指向当前节点，如果我们要插入的节点的键以及键所对应的 hash 值和 p 节点完全一样的话，那么说明这次 put 是一次修改操作，新建一个引用指向这个需要修改的节点。&lt;/p&gt;

&lt;p&gt;第二步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if (p instanceof TreeNode)
     e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前 p 节点是红黑树结点，那么需要调用不同于链表的的添加节点的方法来添加一个节点到红黑树中。（主要是维持平衡，建议读者去了解下红黑树，此处没有深谈是限于它的复杂度和文章篇幅）。&lt;/p&gt;

&lt;p&gt;第三步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else {
     for (int binCount = 0; ; ++binCount) {
     if ((e = p.next) == null) {
         p.next = newNode(hash, key, value, null);
         if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) 
             treeifyBin(tab, hash);
         break;
     }
    if (e.hash == hash &amp;amp;&amp;amp;((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
         break;
    p = e;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要处理的是向普通链表的末尾添加一个新的结点，e 不断地往后移动，如果发现 e 为 null，那么说明已经到链表的末尾了，那么新建一个节点添加到链表的末尾即可，因为 p 是 e 的父节点，所以直接让 p.next 指向新节点即可。添加之后，如果发现链表长度超过 8，那么将链表转储成红黑树。&lt;/p&gt;

&lt;p&gt;在遍历的过程中，如果发现 e 所指向的当前结点和我们即将插入的节点信息完全匹配，那么也说明这是一次修改操作，由于 e 已经指向了该需要被修改的结点，所以直接 break 即可。&lt;/p&gt;

&lt;p&gt;那么最终，无论是第一步中找到的头节点即需要被修改的节点，还是第三步在遍历中找到的需要被修改的节点，它们的引用都是 e，此时我们只需要用传入的 Value 值替换 e 指向的节点的 value 即可。正如这段代码一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (e != null) { // existing mapping for key
     V oldValue = e.value;
     if (!onlyIfAbsent || oldValue == null)
          e.value = value;
     afterNodeAccess(e);
     return oldValue;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 e 为 null，那更简单了，说明此次 put 是添加新元素并且新元素也已经在上述代码中被添加到 HashMap 中了，我们只需要关心下，新加入一个元素后是否达到数组的阈值，如果是则调用 resize 方法扩大数组容量。该方法已经详细阐述过，此处不再赘述。&lt;/p&gt;

&lt;p&gt;所以，这个 put 方法是集添加与修改一体的一个方法，如果执行的是添加操作则会返回 null，是修改操作则会返回旧结点的 value 值。&lt;/p&gt;

&lt;p&gt;那么至此，我们对添加操作的内部实现想必已经了解的不错了，接下来看看删除操作的内部实现。&lt;/p&gt;

&lt;h2 id=&#34;remove-方法的具体实现&#34;&gt;remove 方法的具体实现&lt;/h2&gt;

&lt;p&gt;删除操作就是一个查找+删除的过程，相对于添加操作其实容易一些，但那是你基于上述添加方法理解的不错的前提下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V remove(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据键值删除指定节点，这是一个最常见的操作了。显然，removeNode 方法是核心。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;
    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
        (p = tab[index = (n - 1) &amp;amp; hash]) != null) {
        Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key ||
                         (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||(value != null &amp;amp;&amp;amp; value.equals(v)))) {
            if (node instanceof TreeNode)                                                                     ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除操作需要保证在表不为空的情况下进行，并且 p 节点根据键的 hash 值对应到数组的索引，在该索引处必定有节点，如果为 null ，那么间接说明此键所对应的结点并不存在于整个 HashMap 中，这是不合法的，所以首先要在这两个大前提下才能进行删除结点的操作。&lt;/p&gt;

&lt;p&gt;第一步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (p.hash == hash &amp;amp;&amp;amp;((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
     node = p;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要删除的结点就是这个头节点，让 node 引用指向它。否则说明待删除的结点在当前 p 所指向的头节点的链表或红黑树中，于是需要我们遍历查找。&lt;/p&gt;

&lt;p&gt;第二步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if ((e = p.next) != null) {
     if (p instanceof TreeNode)
          node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
     else {
         do {
              if (e.hash == hash &amp;amp;&amp;amp;((k = e.key) == key ||(key != null &amp;amp;&amp;amp; key.equals(k)))) {
                     node = e;
              break;
         }
         p = e;
         } while ((e = e.next) != null);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果头节点是红黑树结点，那么调用红黑树自己的遍历方法去得到这个待删结点。否则就是普通链表，我们使用 do while 循环去遍历找到待删结点。找到节点之后，接下来就是删除操作了。&lt;/p&gt;

&lt;p&gt;第三步，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||(value != null &amp;amp;&amp;amp; value.equals(v)))) {
       if (node instanceof TreeNode)
                    ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
       else if (node == p)
            tab[index] = node.next;
       else
            p.next = node.next;
       ++modCount;
       --size;
       afterNodeRemoval(node);
       return node;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除操作也很简单，如果是红黑树结点的删除，直接调用红黑树的删除方法进行删除即可，如果是待删结点就是一个头节点，那么用它的 next 结点顶替它作为头节点存放在 table[index] 中，如果删除的是普通链表中的一个节点，用该结点的前一个节点直接跳过该待删结点指向它的 next 结点即可。&lt;/p&gt;

&lt;p&gt;最后，如果 removeNode 方法删除成功将返回被删结点，否则返回 null。&lt;/p&gt;

&lt;p&gt;这样，相对复杂的 put 和 remove 方法的内部实现，我们已经完成解析了。下面看看其他常用的方法实现，它们或多或少都于这两个方法有所关联。&lt;/p&gt;

&lt;h2 id=&#34;其他常用的方法介绍&#34;&gt;其他常用的方法介绍&lt;/h2&gt;

&lt;p&gt;除了常用的 put 和 remove 两个方法外，HashMap 中还有一些好用的方法，下面我们简单的学习下它们。&lt;/p&gt;

&lt;h3 id=&#34;clear&#34;&gt;clear&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void clear() {
    Node&amp;lt;K,V&amp;gt;[] tab;
    modCount++;
    if ((tab = table) != null &amp;amp;&amp;amp; size &amp;gt; 0) {
        size = 0;
        for (int i = 0; i &amp;lt; tab.length; ++i)
            tab[i] = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法调用结束后将清除 HashMap 中存储的所有元素。&lt;/p&gt;

&lt;h3 id=&#34;keyset&#34;&gt;keySet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//实例属性 keySet
transient volatile Set&amp;lt;K&amp;gt;        keySet;

public Set&amp;lt;K&amp;gt; keySet() {
    Set&amp;lt;K&amp;gt; ks;
    return (ks = keySet) == null ? (keySet = new KeySet()) : ks;
}
final class KeySet extends AbstractSet&amp;lt;K&amp;gt; {
    public final int size()                 { return size; }
    public final void clear()               { HashMap.this.clear(); }
    public final Iterator&amp;lt;K&amp;gt; iterator()     { return new KeyIterator(); }
    public final boolean contains(Object o) { return containsKey(o); }
    public final boolean remove(Object key) {
        return removeNode(hash(key), key, null, false, true) != null;
    }
    public final Spliterator&amp;lt;K&amp;gt; spliterator() {
        return new KeySpliterator&amp;lt;&amp;gt;(HashMap.this, 0, -1, 0, 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashMap 中定义了一个 keySet 的实例属性，它保存的是整个 HashMap 中所有键的集合。上述所列出的 KeySet 类是 Set 的一个实现类，它负责为我们提供有关 HashMap 中所有对键的操作。&lt;/p&gt;

&lt;p&gt;可以看到，KeySet 中的所有的实例方法都依赖当前的 HashMap 实例，也就是说，我们对返回的 keySet 集中的任意一个操作都会直接映射到当前 HashMap 实例中，例如你执行删除一个键的操作，那么 HashMap 中将会少一个节点。&lt;/p&gt;

&lt;h3 id=&#34;values&#34;&gt;values&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Collection&amp;lt;V&amp;gt; values() {
    Collection&amp;lt;V&amp;gt; vs;
    return (vs = values) == null ? (values = new Values()) : vs;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;values 方法其实和 keySet 方法类似，它返回了所有节点的 value 属性所构成的 Collection 集合，此处不再赘述。&lt;/p&gt;

&lt;h3 id=&#34;entryset&#34;&gt;entrySet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet() {
    Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; es;
    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它返回的是所有节点的集合，或者说是所有的键值对集合。&lt;/p&gt;

&lt;h3 id=&#34;get&#34;&gt;get&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get 方法的内部实现其实是我们介绍过的 put 方法中的一部分，所以此处也不再赘述。&lt;/p&gt;

&lt;p&gt;参考文档：
&lt;a href=&#34;https://blog.csdn.net/fan2012huan/article/details/51097331&#34;&gt;HashMap源码注解 之 静态工具方法hash()、tableSizeFor()&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java中静态代码块、代码块、main()方法和构造函数加载顺序</title>
      <link>https://wangzitao6.github.io/2018-07-02-java%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A3%E7%A0%81%E5%9D%97main%E6%96%B9%E6%B3%95%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Mon, 02 Jul 2018 10:38:28 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-07-02-java%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A3%E7%A0%81%E5%9D%97main%E6%96%B9%E6%B3%95%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;静态代码块：用staitc声明，jvm加载类时执行，仅执行一次。&lt;/br&gt;
构造代码块：类中直接用{}定义，每一次创建对象时执行。&lt;/br&gt;
同一个类中，执行顺序优先级：&lt;strong&gt;静态代码块 &amp;gt; main() &amp;gt; 构造代码块 &amp;gt; 构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//构造函数
public ClassLoadDemo(){
    System.out.println(&amp;quot;这里是构造函数&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/br&gt;
1. 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。&lt;/br&gt;
2. &lt;strong&gt;构造函数的作用是用于给对象进行初始化&lt;/strong&gt;。&lt;/br&gt;
3. 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。&lt;/p&gt;

&lt;h2 id=&#34;构造代码块&#34;&gt;构造代码块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//构造代码块
{
    System.out.println(&amp;quot;这里是构造代码块&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/br&gt;
1. &lt;strong&gt;构造代码块的作用是给对象进行初始化&lt;/strong&gt;。&lt;/br&gt;
2. &lt;strong&gt;对象一建立就运行构造代码块了，而且优先于构造函数执行&lt;/strong&gt;。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的。&lt;/br&gt;
3. 构造代码块与构造函数的区别是：&lt;strong&gt;构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化&lt;/strong&gt;，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，&lt;strong&gt;构造代码块中定义的是不同对象共性的初始化内容，所以构造代码块优先于构造函数执行&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;静态代码块&#34;&gt;静态代码块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//静态代码块
public ClassLoadDemo(){
    System.out.println(&amp;quot;这里是构造函数&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/br&gt;
1. 它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。&lt;/br&gt;
2. 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。&lt;/br&gt;
3. 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。&lt;/br&gt;
4. 一个类中可以有多个静态代码块。&lt;/br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassLoadDemo {
    private static int num = 1;

    //静态代码块
    static{
        num = num + 6;
    }
    //main()
    public static void main(String[] args) {
        System.out.println(&amp;quot;num: &amp;quot;+ num);
    }
    //静态代码块
    static{
        num = num - 5;
    }
}

输出结果： num: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类初始化顺序&#34;&gt;类初始化顺序&lt;/h2&gt;

&lt;p&gt;demo1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassA {

    //构造函数
    public ClassA(){
        System.out.println(&amp;quot;这里是ClassA构造函数&amp;quot;);
    }
    //静态代码块
    static{
        System.out.println(&amp;quot;这里是ClassA静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println(&amp;quot;这里是ClassA构造代码块&amp;quot;);
    }
    //main()
    public static void main(String[] args) {
        
    }
}

运行结果: 这里是ClassA静态代码块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;demo2:对ClassA对象进行初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassA {

    //构造函数
    public ClassA(){
        System.out.println(&amp;quot;这里是ClassA构造函数&amp;quot;);
    }
    //静态代码块
    static{
        System.out.println(&amp;quot;这里是ClassA静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println(&amp;quot;这里是ClassA构造代码块&amp;quot;);
    }
    //main()
    public static void main(String[] args) {
        ClassA a = new ClassA();
    }
}


运行结果: 
这里是ClassA静态代码块
这里是ClassA构造代码块
这里是ClassA构造函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;demo3:对ClassA对象进行初始化两次。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassA {

    //构造函数
    public ClassA(){
        System.out.println(&amp;quot;这里是ClassA构造函数&amp;quot;);
    }
    //静态代码块
    static{
        System.out.println(&amp;quot;这里是ClassA静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println(&amp;quot;这里是ClassA构造代码块&amp;quot;);
    }
    //main()
    public static void main(String[] args) {
        ClassA a = new ClassA();
        ClassA b = new ClassA();
    }
}

运行结果：
这里是ClassA静态代码块
这里是ClassA构造代码块
这里是ClassA构造函数
这里是ClassA构造代码块
这里是ClassA构造函数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;对于一个类而言，按照如下顺序执行：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行静态代码块&lt;/li&gt;
&lt;li&gt;执行构造代码块&lt;/li&gt;
&lt;li&gt;执行构造函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&amp;gt;（变量、初始化块）&amp;gt;构造器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;demo4: 加入静态变量、静态对ClassA进行初始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassA {
    /* 静态变量 */
    public static String staticField = &amp;quot;静态变量&amp;quot;;
    /* 变量 */
    public String field = &amp;quot;变量&amp;quot;;

    //构造函数
    public ClassA() {
        System.out.println(&amp;quot;这里是ClassA构造函数&amp;quot;);
    }

    //静态代码块
    static {
        System.out.println( staticField );
        System.out.println(&amp;quot;这里是ClassA静态代码块&amp;quot;);
    }

    //构造代码块
    {
        System.out.println( field);
        System.out.println(&amp;quot;这里是ClassA构造代码块&amp;quot;);
    }

    //main()
    public static void main(String[] args) {
        ClassA a = new ClassA();
    }
}

运行结果:

静态变量
这里是ClassA静态代码块
变量
这里是ClassA构造代码块
这里是ClassA构造函数
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;继承下的类初始化顺序&#34;&gt;继承下的类初始化顺序&lt;/h2&gt;

&lt;p&gt;上面我们说的是单独Class下的加载顺序，下面我们讨论下继承下的加载顺序。&lt;/p&gt;

&lt;p&gt;demo5:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassA {

    //构造函数
    public ClassA() {
        System.out.println(&amp;quot;这里是ClassA构造函数&amp;quot;);
    }
    //静态代码块
    static {
        System.out.println(&amp;quot;这里是ClassA静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println(&amp;quot;这里是ClassA构造代码块&amp;quot;);
    }
}

public class ClassB extends ClassA{

    //构造函数
    public ClassB(){
        System.out.println(&amp;quot;这里是ClassB构造函数&amp;quot;);
    }
    //静态代码块
    static{
        System.out.println(&amp;quot;这里是ClassB静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println(&amp;quot;这里是ClassB代码块&amp;quot;);
    }
    //main()
    public static void main(String[] args) {
        ClassB b = new ClassB();
    }
}

运行ClassB结果：

这里是ClassA静态代码块
这里是ClassB静态代码块
这里是ClassA构造代码块
这里是ClassA构造函数
这里是ClassB代码块
这里是ClassB构造函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/br&gt;
当涉及到继承时，按照如下顺序执行：&lt;/br&gt;
1. 执行父类的静态代码块，并初始化父类静态成员变量&lt;/br&gt;
2. 执行子类的静态代码块，并初始化子类静态成员变量&lt;/br&gt;
3. 执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量&lt;/br&gt;
4. 执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量&lt;/p&gt;

&lt;p&gt;Java初始化顺序如图：
&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/09/01/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassA {
    /* 静态变量 */
    public static String p_StaticField = &amp;quot;父类--静态变量&amp;quot;;
    /* 变量 */
    public String    p_Field = &amp;quot;父类--变量&amp;quot;;
    protected int    i    = 9;
    protected int    j    = 0;

    //构造函数
    public ClassA() {
        System.out.println(&amp;quot;这里是父类构造函数&amp;quot;);
        System.out.println( &amp;quot;i=&amp;quot; + i + &amp;quot;, j=&amp;quot; + j );
        j = 20;
    }
    //静态代码块
    static {
        System.out.println( p_StaticField );
        System.out.println(&amp;quot;这里是父类静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println( p_Field);
        System.out.println(&amp;quot;这里是父类构造代码块&amp;quot;);
    }
}

public class ClassB extends ClassA{
    /* 静态变量 */
    public static String s_StaticField = &amp;quot;子类--静态变量&amp;quot;;
    /* 变量 */
    public String s_Field = &amp;quot;子类--变量&amp;quot;;

    //构造函数
    public ClassB(){
        System.out.println(&amp;quot;这里是子类构造函数&amp;quot;);
        System.out.println( &amp;quot;i=&amp;quot; + i + &amp;quot;,j=&amp;quot; + j );
    }
    //静态代码块
    static{
        System.out.println( s_StaticField );
        System.out.println(&amp;quot;这里是子类静态代码块&amp;quot;);
    }
    //构造代码块
    {
        System.out.println( s_Field );
        System.out.println(&amp;quot;这里是子类代码块&amp;quot;);
    }
    //main()
    public static void main(String[] args) {
        System.out.println( &amp;quot;子类main方法&amp;quot; );
        ClassB b = new ClassB();
    }
}

运行结果：
父类--静态变量
这里是父类静态代码块
子类--静态变量
这里是子类静态代码块
子类main方法
父类--变量
这里是父类构造代码块
这里是父类构造函数
i=9, j=0
子类--变量
这里是子类代码块
这里是子类构造函数
i=9,j=20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。静态变量、静态初始化块，变量、初始化块初始化了顺序取决于它们在类中出现的先后顺序。&lt;/p&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;运行ClassB.main(),(这是一个static方法)，于是装载器就会为你寻找已经编译的ClassB类的代码（也就是ClassB.class文件）。在装载的过程中，装载器注意到它有一个基类（也就是extends所要表示的意思），于是它再装载基类。不管你创不创建基类对象，这个过程总会发生。如果基类还有基类，那么第二个基类也会被装载，依此类推。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行根基类的static初始化，然后是下一个派生类的static初始化，依此类推。这个顺序非常重要，因为派生类的“static初始化”有可能要依赖基类成员的正确初始化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当所有必要的类都已经装载结束，开始执行main()方法体，并用new ClassB() 创建对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类ClassB存在父类，则调用父类的构造函数，你可以使用super来指定调用哪个构造函数。基类的构造过程以及构造顺序，同派生类的相同。首先基类中各个变量按照字面顺序进行初始化，然后执行基类的构造函数的其余部分。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对子类成员数据按照它们声明的顺序初始化，执行子类构造函数的其余部分。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Jvm类加载过程</title>
      <link>https://wangzitao6.github.io/2018-07-02-jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 02 Jul 2018 10:05:16 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-07-02-jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;什么是类加载&#34;&gt;什么是类加载&lt;/h2&gt;

&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。&lt;/p&gt;

&lt;h2 id=&#34;类加载的时机&#34;&gt;类加载的时机&lt;/h2&gt;

&lt;p&gt;类从被加载到虚拟内存中开始，到卸载出内存位置，它的生命周期包括：&lt;strong&gt;&lt;font color = &#34;red&#34;&gt; 加载
（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化
（Initialization）、使用（Using）和卸载（Unloading）&lt;/font&gt;&lt;/strong&gt;7个阶段。其中验证、准备、解析3
个部分统称为 &lt;strong&gt;&lt;font color = &#34;red&#34;&gt;连接（Linking）&lt;/font&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao-blog.oss-cn-hangzhou.aliyuncs.com/19/09/01/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加载&lt;/strong&gt;、&lt;strong&gt;验证&lt;/strong&gt;、&lt;strong&gt;准备&lt;/strong&gt;、&lt;strong&gt;初始化&lt;/strong&gt;和&lt;strong&gt;卸载&lt;/strong&gt;这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而&lt;strong&gt;解析阶段&lt;/strong&gt;则不一定：它在某些情况下可以在&lt;strong&gt;初始化阶段&lt;/strong&gt;之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。&lt;/p&gt;

&lt;p&gt;什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>