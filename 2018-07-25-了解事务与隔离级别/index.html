<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta name="google-site-verification" content="9vIieCe-Qpd78QOmBl63rGtIVbhY6sYyuxX3j8XWBA4" />
    <meta name="baidu-site-verification" content="LRrmH41lz7" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="王子滔的学习笔记">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://wangzitao6.github.io/images/1.jpg">
    <meta property="twitter:image" content="https://wangzitao6.github.io/images/1.jpg" />
    

    
    <meta name="title" content="死锁 - 了解事务与隔离级别" />
    <meta property="og:title" content="死锁 - 了解事务与隔离级别" />
    <meta property="twitter:title" content="死锁 - 了解事务与隔离级别" />
    

    
    <meta name="description" content="王子滔, 美食爱好者，生活探险家 | 这里是 王子滔 的学习笔记，与你一起发现更大的世界。">
    <meta property="og:description" content="王子滔, 美食爱好者，生活探险家 | 这里是 王子滔 的学习笔记，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="王子滔, 美食爱好者，生活探险家 | 这里是 王子滔 的学习笔记，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="王子滔, wangzitao, WangZiTao, 王子滔的网络日志, 王子滔的学习笔记, 学习笔记, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>死锁 - 了解事务与隔离级别</title>

    <link rel="canonical" href="/2018-07-25-%e4%ba%86%e8%a7%a3%e4%ba%8b%e5%8a%a1%e4%b8%8e%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab">

    <link rel="stylesheet" href="/css/iDisqus.min.css"/>
	
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    
    <link rel="stylesheet" href="/css/syntax.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    
    
    <script src="/js/jquery.min.js"></script>
    
    
    <script src="/js/bootstrap.min.js"></script>
    
    
    <script src="/js/hux-blog.min.js"></script>
	
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/docco.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">王子滔的学习笔记</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/categories/build">build</a>
                    </li>
                    
                    <li>
                        <a href="/categories/jvm">jvm</a>
                    </li>
                    
                    <li>
                        <a href="/categories/net">net</a>
                    </li>
                    
                    <li>
                        <a href="/categories/other">other</a>
                    </li>
                    
                    <li>
                        <a href="/categories/sql">sql</a>
                    </li>
                    

		    
                        <li><a href="/top/about/">ABOUT</a></li>
                    

                    
		    <li>
                        <a href="/search">SEARCH <img src="/img/search.png" height="15" style="cursor: pointer;" alt="Search"></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/images/1.jpg')
    }
</style>
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/%E6%AD%BB%E9%94%81" title="死锁">
                            死锁
                        </a>
                        
                        <a class="tag" href="/tags/mysql" title="MySQL">
                            MySQL
                        </a>
                        
                    </div>
                    <h1>死锁 - 了解事务与隔离级别</h1>
                    <h2 class="subheading">死锁 - 了解事务与隔离级别</h2>
                    <span class="meta">
			Posted by
			
			    WangZiTao
			
			on
			Wednesday, July 25, 2018
                        
                            <span id="/2018-07-25-了解事务与隔离级别" class="leancloud_visitors meta_data_item" data-flag-title="">
    <span class="post-meta-item-icon">
      <span class="octicon octicon-eye"></span> 
    </span>
    <i class="fa fa-eye"></i>
    <span class="old-visitors-count" style="display: none;"></span>
    <span class="leancloud-visitors-count"></span>
</span>



<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>

<script>
	AV.initialize("", "");
</script>

<script type="text/javascript">
function showTime(Counter) {
    var query = new AV.Query(Counter);
    var entries = [];
    var $visitors = $(".leancloud_visitors");

    $visitors.each(function() {
        entries.push($(this).attr("id").trim());
    });

    query.containedIn('url', entries);
    query.find()
        .done(function(results) {
            var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
            var OLD_COUNT_CONTAINER_REF = '.old-visitors-count';

            
            
            
            

            for (var i = 0; i < results.length; i++) {
                var item = results[i];
                var url = item.get('url');
                var time = item.get('time');
                var element = document.getElementById(url);

                $(element).find(COUNT_CONTAINER_REF).text(time);
            }
            for (var i = 0; i < entries.length; i++) {
                var url = entries[i];
                var element = document.getElementById(url);
                var countSpan = $(element).find(COUNT_CONTAINER_REF);
                if (countSpan.text() == '') {
                    var oldCountSpan = $(element).find(OLD_COUNT_CONTAINER_REF).text();
                    if(oldCountSpan!=''){
                        countSpan.text(0+parseInt(oldCountSpan));
                    }else{
                        countSpan.text(0);          
                    }
                }
            }
        })
        .fail(function(object, error) {
            console.log("Error: " + error.code + " " + error.message);
        });
}

function addCount(Counter) {
    var $visitors = $(".leancloud_visitors");
    var url = $visitors.attr('id').trim();
    var title = $visitors.attr('data-flag-title').trim();
    var query = new AV.Query(Counter);

    query.equalTo("url", url);
    query.find({
        success: function(results) {
            if (results.length > 0) {
                var counter = results[0];
                counter.fetchWhenSave(true);
                counter.increment("time");
                counter.save(null, {
                    success: function(counter) {
                        var $element = $(document.getElementById(url));
                        $element.find('.leancloud-visitors-count').text(counter.get('time'));
                    },
                    error: function(counter, error) {
                        console.log('Failed to save Visitor num, with error message: ' + error.message);
                    }
                });
            } else {
                var newcounter = new Counter();
                 
                var acl = new AV.ACL();
                acl.setPublicReadAccess(true);
                acl.setPublicWriteAccess(true);
                newcounter.setACL(acl);
                 
                newcounter.set("title", title);
                newcounter.set("url", url);
                var OLD_COUNT_CONTAINER_REF = '.old-visitors-count';
                var $element = $(document.getElementById(url));
                var oldCountSpan = $element.find(OLD_COUNT_CONTAINER_REF).text();
                if(oldCountSpan!=''){
                    newcounter.set("time", parseInt(oldCountSpan)+1);
                }else{
 	                    newcounter.set("time",  1);
                }
                newcounter.save(null, {
                    success: function(newcounter) {
                        var $element = $(document.getElementById(url));
                        $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                    },
                    error: function(newcounter, error) {
                        console.log('Failed to create');
                    }
                });
            }
        },
        error: function(error) {
            console.log('Error:' + error.code + " " + error.message);
        }
    });
}
$(function() {
    var Counter = AV.Object.extend("Counter");
    
    
    if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
    } else {
        showTime(Counter);
    }
});
</script>

                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <header>
                    <h2>目录</h2>
                </header>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#事务四要素-acid">事务四要素：ACID</a></li>
<li><a href="#事务并发存在的问题">事务并发存在的问题</a>
<ul>
<li><a href="#脏读-dirty-read">脏读（dirty read）</a></li>
<li><a href="#不可重复读-unrepeatable-read">不可重复读（unrepeatable read）</a></li>
<li><a href="#幻读-phantom-read">幻读（phantom read）</a></li>
<li><a href="#丢失更新-lost-update">丢失更新（lost update）</a></li>
</ul></li>
<li><a href="#隔离级别">隔离级别</a>
<ul>
<li><a href="#隔离级别的实现">隔离级别的实现</a></li>
<li><a href="#传统的隔离级别">传统的隔离级别</a></li>
<li><a href="#mysql-的隔离级别">MySQL 的隔离级别</a></li>
<li><a href="#查看和设置-mysql-的隔离级别">查看和设置 MySQL 的隔离级别</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
                
                

<p>这个月线上环境突然经常报警，排查后发现了下面这样的异常，一天出现三四次的样子。看异常信息就知道是发生了数据库死锁，由于这块对业务影响不是很大，自己以前也没接触过,决定花点时间,从网上找查找资料,将 MySQL 数据库的一些基础知识，包括事务、隔离级别、索引和锁等重新看一遍，也顺利解决了线上的死锁问题。</p>

<p>异常信息如下：</p>

<blockquote>
<p>### Error updating database.  Cause:     com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:
Deadlock found when trying to get lock; try restarting transaction</p>
</blockquote>

<p>根据日志,知道是发生了死锁,由于死锁发生的场景比较多,再加上自己刚接手这个模块,准备一边了解业务场景,一边学习死锁知识.
1. 了解事务与隔离级别
2. 了解常见锁类型
3. 掌握常见 SQL 语句的加锁分析
4. 死锁问题的分析和解决</p>

<p>说起死锁，则不得不说事务，当两个或两个以上的事务相互持有和请求锁的时候，如果形成一个循环的依赖关系，就会产生死锁。所以我们先了解事务.</p>

<h2 id="事务四要素-acid">事务四要素：ACID</h2>

<p>对于事务，我之前的理解是很粗糙的，不就是为了保证操作的原子性么？一般订单系统或者财务系统跟钱打交道的都会用到对吧？事务可以保证所有的操作一次性提交，要么全部成功，要么全部失败，譬如 A 转账给 B 100 元，先从 A 的账户里扣除 100 元，再在 B 的账户上加上 100 元，这两个操作必须同时成功，如果 A 的钱减了之后程序异常了，事务会将 A 的钱回滚回去，就是这么简单啊。</p>

<p>确实如此，原子性可以说是事务四要素中最直白的一个，也是最容易理解的一个。但是我们往往忽略了事务的另外三个要素：一致性、隔离性和持久性。这四个要素合起来就是 ACID 。</p>

<ul>
<li>原子性（Atomicity）：要么全部完成，要么全部不完成；</li>
<li>一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见；</li>
<li>隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的隔离级别，通过适度的破坏一致性，得以提高性能；</li>
<li>持久性（Durability）：事务提交后即持久化到磁盘不会丢失。</li>
</ul>

<p>对于死锁，我们还是应该把注意力放在 <strong>隔离性（Isolation）</strong> 上面，因为不同的隔离级别，可能对应的加锁过程也不一样，而正是由于引入了各种各样的隔离级别，才让锁问题变得格外复杂。解决和分析死锁问题，首先得知道当前数据库的隔离级别。那么隔离级别是个什么东西呢？其实从上面也看的出来，隔离性和一致性是有冲突的，有时候为了提高性能，会适度的破坏一致性，可能会出现一个事务还没提交，它的修改就被其他事务看见了，这其实就是传说中的 <strong>脏读</strong>，它属于最低级的隔离级别 <strong>读未提交</strong></p>

<h2 id="事务并发存在的问题">事务并发存在的问题</h2>

<p>在细讲事务的隔离级别之前，让我们先来看一下下面这张表，以及几个对这个表的操作，瞧瞧在多事务并发处理数据的时候可能会发生哪些意想不到的情况。</p>

<p>表很简单，就三个字段，主键 id、姓名 name 和余额 balance，其中 name 为二级索引，如下：
<img src="/images/post/18/06/1.jpg" alt="" /></p>

<h3 id="脏读-dirty-read">脏读（dirty read）</h3>

<p>假设有两个事务，一个在进行转账操作，将 A 账户的 100 元转到 B 账户，同时有另一个事务在对 A 和 B 的账户余额进行求和统计，如下图所示：</p>

<p>我们不考虑任何加锁机制，仅仅从程序运行的角度来看，事务 1 执行成功之后，A 成功转了 100 元到 B 账户，这时 A 余额还剩 900 元，B 余额剩 1100，总和为 2000；但是事务 2 的统计求和算出来的结果却是 A + B = 1900。这个就是上面说的，没有提交的事务被其他事务读取到了，这叫做 <strong>脏读</strong> 。
<img src="/images/post/18/06/2.png" alt="" /></p>

<p>解决办法：
把数据库的事务隔离级别调整到 <strong>读未提交</strong> 以上，可以解决脏读。</p>

<h3 id="不可重复读-unrepeatable-read">不可重复读（unrepeatable read）</h3>

<p>第二种场景叫 不可重复读，如下图所示，事务 2 第一次获取 A 的账户余额为 1000 元，这个时候事务 1 对 A 的账户余额进行操作减去了 100 元，事务 2 再去查询 A 的账户余额发现变成了 900 元，这样就出现了同一个事务对同一条记录读取两遍，两次读出来的结果竟然不一样。</p>

<p>不可重复读和脏读的区别在于，<strong>脏读是读取了另一个事务未提交的修改，而不可重复读是读取了另一个事务提交之后的修改</strong>，本质上都是其他事务的修改影响了本事务的读取。那么不可重复读有什么问题呢？假设上面的事务 2 存在着两个子例程，第一个例程是读取所有账户的余额计算总和，可以得到所有人的余额总和为 3000，第二个例程是再次读取所有账户的余额计算平均值，3 个人总和 3000 按理应该是平均每人 1000 才对，却计算出了 <sup>2900</sup>&frasl;<sub>3</sub> = 966，这就导致了数据不一致。</p>

<p><img src="/images/post/18/06/3.png" alt="" /></p>

<p>解决办法：
通过在读的时候加锁，可以解决不可重复读。</p>

<h3 id="幻读-phantom-read">幻读（phantom read）</h3>

<p>幻读就是在一个事务中一次查询之后,有另一个事务进行了插入或删除操作,插入或删除的内容是满足上述查询条件的,如果这个事务中海油同样查询条件的二次查询,会导致第二次查询的结果与第一次不一致.</p>

<p>比如:管理员A查询id大于等于2的数据发现有2,3两条，但是另外一个线程就在这个时候插入（注意是插入或者删除，不是修改））了一条新的id=4的记录，当管理员A再次查询时,发现多了一条记录，就好像发生了幻觉一样。这就叫幻读。</br>
解决办法：</p>

<p><img src="/images/post/18/06/4.png" alt="" /></p>

<p>解决办法：
通过串行化，可以解决幻读。</p>

<h3 id="丢失更新-lost-update">丢失更新（lost update）</h3>

<p>上面说的三种情况，都是一个事务写，一个事务读，由于一个事务的写导致另一个事务读到了不该读的数据；那么如果两个事务都是写，又会发生什么呢？</p>

<p>假设两个事务同时对 A 的余额进行修改，他们都查出 A 的当前余额为 1000，然后事务 2 修改 A 的余额，将 A 的余额加 100 变成 1100 并提交，这个时候 A 的余额应该是 1100，但是这个时候事务 1 并不知道 A 的余额已经变动，而是继续在 1000 的基础上进行减 100 的操作并提交事务，就这样事务 2 的提交被覆盖掉了，事务 1 提交之后 A 的余额变成了 900 元。这就是说事务 1 的提交覆盖了事务 2 的提交，事务 2 的 UPDATE 操作完全丢失了，整个过程如下图所示：</p>

<p><img src="/images/post/18/06/5.png" alt="" /></p>

<p>这就是经典的 <strong>丢失更新</strong> 问题，由于最后一步是提交操作，所以又叫做 <strong>提交覆盖</strong>，有时候又叫 Read-Modify-Write 问题。一个典型的场景是并发对某个变量进行自增或自减，譬如商品表的库存字段，每次下单之后库存值需要减 1，大概的流程如下：</p>

<ol>
<li>SELECT name, stock FROM product WHERE id = 100;</li>
<li>判断 stock 值是否足够，如果足够，则下单：if (stock &gt; n) process order;</li>
<li>更新 stock 值，减去下单的商品数量：new_stock = stock - n;</li>
<li>UPDATE product SET stock = new_stock WHERE id = 100;</li>
</ol>

<p>如果两个线程同时下单，很可能就会出现下面这样的情况：</p>

<ol>
<li>线程 A 获取库存值为 10；</li>
<li>线程 B 获取库存值为 10；</li>
<li>线程 A 需要买 5 个商品，校验通过，并下单；</li>
<li>线程 B 需要买 5 个商品，校验通过，并下单；</li>
<li>线程 A 下单完成，更新库存值为 10 - 5 = 5；</li>
<li>线程 B 下单完成，更新库存值为 10 - 5 = 5；</li>
</ol>

<p>两个线程下单结束后，商品的库存还剩 5 个，而实际上 10 个商品都已经卖光了。和提交覆盖相对的，还有另一个 <strong>丢失更新</strong> 问题，叫做 <strong>回滚覆盖</strong>，如下图所示：
<img src="/images/post/18/06/6.png" alt="" />
操作和提交覆盖情景基本上一样，只是最后一步事务 1 的提交变成了回滚，这样 A 的余额恢复成原始值 1000，事务 2 的 UPDATE 操作也完全没有生效，想一想这真的是非常可怕，一个事务的回滚操作竟然影响了另一个正常提交的事务。回滚覆盖问题可以说是程序 bug 了，因此几乎所有的数据库都不允许回滚覆盖。</p>

<p>有时候我们把回滚覆盖称之为 <strong>第一类丢失更新</strong> 问题，提交覆盖称为 <strong>第二类丢失更新</strong> 问题。</p>

<h2 id="隔离级别">隔离级别</h2>

<p>上面说了这么多并发场景下数据操作可能遇到的问题，那么要如何解决呢？我们能想到的最简单的方法就是对操作的数据进行加锁，写的时候不允许其他事务读，读的时候不允许其他事务写，这样是不是就完美解决了？确实如此。这其实就是四大隔离级别里的 序列化，在序列化隔离级别下，可以保证事务的安全执行，数据库的一致性得以保障，但是它大大降低了事务的并发能力，性能最低。</p>

<p>为了调和事务的安全性和性能之间的冲突，适当的降低隔离级别，可以有效的提高数据库的并发性能。于是便有了四种不同的隔离级别：</p>

<ul>
<li><p>读未提交（Read Uncommitted）：<strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）</strong>。会出现脏读，幻读，不可重复读，所有并发问题都可能遇到；</p></li>

<li><p>读已提交（Read Committed）：<strong>本事务读取到的是最新的数据（其他事务提交后的）</strong>。不会出现脏读现象,但是会出现幻读;不可重复读;（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）</p></li>

<li><p>可重复读（Repeatable Read）：<strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的</strong>。MySQL InnoDb 默认的隔离级别,解决了不可重复读问题,但是任然存在幻读问题;（MySQL 的实现有差异，后面介绍）</p></li>

<li><p>序列化（Serializable）：<strong>读操作会隐式获取共享锁，可以保证不同事务间的互斥</strong>。最高隔离级别，啥并发问题都没有。</p></li>
</ul>

<p>针对这四种隔离级别，应该根据具体的业务来取舍，如果某个系统的业务里根本就不会出现重复读的场景，完全可以将数据库的隔离级别设置为 RC，这样可以最大程度的提高数据库的并发性。不同的隔离级别和可能发生的并发现象如下表：</p>

<p><img src="/images/post/18/06/7.png" alt="" /></p>

<p>其中，在 <strong>可重复读（RR）</strong> 隔离级别下，是否可能出现第二类丢失更新问题（提交覆盖）比较有争议，网上对此有很多不一致的说法，其实也是因为 MySQL 的实现和 ANSI-SQL 标准之间的差异，在标准的传统实现中，RR 隔离级别是使用持续的 X 锁和持续的 S 锁来实现的（参看下面的 “隔离级别的实现” 一节），由于是持续的 S 锁，所以避免了其他事务有写操作，也就不存在提交覆盖问题。但是 MySQL 在 RR 隔离级别下，普通的 SELECT 语句只是快照读，没有任何的加锁，和标准的 RR 是不一样的。如果要让 MySQL 在 RR 隔离级别下不发生提交覆盖，可以使用 SELECT &hellip; LOCK IN SHARE MODE 或者 SELECT &hellip; FOR UPDATE 。</p>

<h3 id="隔离级别的实现">隔离级别的实现</h3>

<p>上面所说的事务和隔离级别的概念，其实都是 SQL 标准中通用的概念，但是不同的数据库产品对标准的实现也会有很大的不同。譬如在 SQL 标准中，RR 隔离级别解决了不可重复读问题，但是依然存在幻读现象；而在 MySQL 的 RR 隔离级别下，通过多版本快照读和间隙锁技术解决了幻读问题。关于这一点也有人心存质疑，譬如 <a href="https://github.com/Yhzhtk/note/issues/42">Innodb 中 RR 隔离级别能否防止幻读？</a> 和 <a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a></p>

<blockquote>
<p>可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。</p>
</blockquote>

<p>个人认为RR 隔离级别下存不存在幻读现象，取决于“幻读”的这个“读”字在 MySQL 里的歧义，这个“读”到底指的是快照读，还是当前读？（<a href="https://www.jianshu.com/p/27352449bcc0">快照读与当前读区别</a>和<a href="https://blog.csdn.net/silyvin/article/details/79280934">innodb当前读与快照读</a>）如果是快照读，MySQL 通过版本号来保证同一个事务里每次查询得到的结果集都是一致的；如果是当前读，MySQL 通过 Next-key locks 保证其他事务无法插入新的数据，从而避免幻读问题。</p>

<h3 id="传统的隔离级别">传统的隔离级别</h3>

<p>隔离级别和锁本身就是两个东西，SQL 规范中定义的四种隔离级别，分别是为了解决事务并发时可能遇到的四种问题，至于如何解决，实现方式是什么，规范中并没有严格定义。</p>

<p>锁作为最简单最显而易见的实现方式，可能被广为人知，所以大家在讨论某个隔离级别的时候，往往会说这个隔离级别的加锁方式是什么样的。其实，锁只是实现隔离级别的几种方式之一，除了锁，实现并发问题的方式还有<a href="https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control">时间戳</a>，<a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">多版本控制</a>等等，这些也可以称为<a href="https://en.wikipedia.org/wiki/Non-lock_concurrency_control">无锁的并发控制</a>。</p>

<p>传统的隔离级别是基于锁实现的，这种方式叫做 <strong>基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC）</strong>。通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。</p>

<p>传统的锁有两种：读操作通常加 <strong>共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）</strong>；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。另外，对于锁的粒度，又分为行锁和表锁，行锁只锁某行记录，对其他行的操作不受影响，表锁会锁住整张表，所有对这个表的操作都受影响。</p>

<p>归纳起来，四种隔离级别的加锁策略如下：</p>

<ul>
<li><p>读未提交（Read Uncommitted）：事务读不阻塞其他事务读和写，事务写阻塞其他事务写但不阻塞读；通过对写操作加 “持续X锁”，对读操作不加锁 实现；</p></li>

<li><p>读已提交（Read Committed）：事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写；通过对写操作加 “持续X锁”，对读操作加 “临时S锁” 实现；不会出现脏读；</p></li>

<li><p>可重复读（Repeatable Read）：事务读会阻塞其他事务事务写但不阻塞读，事务写会阻塞其他事务读和写；通过对写操作加 “持续X锁”，对读操作加 “持续S锁” 实现；</p></li>

<li><p>序列化（Serializable）：为了解决幻读问题，行级锁做不到，需使用表级锁。</p></li>
</ul>

<p>结合上面介绍的每种隔离级别分别是用来解决事务并发中的什么问题，再来看看它的加锁策略其实都挺有意思的。其中 读未提交 网上有很多人认为不需要加任何锁，这其实是错误的，我们上面讲过，有一种并发问题在任何隔离级别下都不允许存在，那就是第一类丢失更新（回滚覆盖），如果不对写操作加 X 锁，当两个事务同时去写某条记录时，可能会出现丢失更新问题，<a href="https://www.jianshu.com/p/71a79d838443">这里</a> 有一个例子可以看到写操作不加 X 锁发生了回滚覆盖。再看 读已提交，它是为了解决脏读问题，只能读取已提交的记录，要怎么做才可以保证事务中的读操作读到的记录都是已提交的呢？<strong>很简单，对读操作加上 S 锁，这样如果其他事务有正在写的操作，必须等待写操作提交之后才能读，因为 S 和 X 互斥，如果在读的过程中其他事务想写，也必须等事务读完之后才可以。这里的 S 锁是一个临时 S 锁，表示事务读完之后立即释放该锁，可以让其他事务继续写，如果事务再读的话，就可能读到不一样的记录，这就是 不可重复读 了。为了让事务可以重复读，加在读操作的 S 锁变成了持续 S 锁，也就是直到事务结束时才释放该锁，这可以保证整个事务过程中，其他事务无法进行写操作，所以每次读出来的记录是一样的</strong>。最后，序列化 隔离级别下单纯的使用行锁已经实现不了，因为行锁不能阻止其他事务的插入操作，这就会导致幻读问题，这种情况下，我们可以把锁加到表上（也可以通过范围锁来实现，但是表锁就相当于把表的整个范围锁住，也算是特殊的范围锁吧）。</p>

<p>从上面的描述可以看出，通过对锁的类型（读锁还是写锁），锁的粒度（行锁还是表锁），持有锁的时间（临时锁还是持续锁）合理的进行组合，就可以实现四种不同的隔离级别。这四种不同的加锁策略实际上又称为 封锁协议（Locking Protocol），所谓协议，就是说不论加锁还是释放锁都得按照特定的规则来。读未提交 的加锁策略又称为 一级封锁协议，后面的分别是二级，三级，序列化 的加锁策略又称为 四级封锁协议。</p>

<p>其中三级封锁协议在事务的过程中为写操作加持续 X 锁，为读操作加持续 S 锁，并且在事务结束时才对锁进行释放，像这种加锁和解锁明确的分成两个阶段我们把它称作 两段锁协议（2-phase locking，简称 2PL）。在两段锁协议中规定，加锁阶段只允许加锁，不允许解锁；而解锁阶段只允许解锁，不允许加锁。这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化的（关于串行化是一个非常重要的概念，尤其是在数据恢复和备份的时候）。在两段锁协议中，还有一种特殊的形式，叫 一次封锁，意思是指在事务开始的时候，将事务可能遇到的数据全部一次锁住，再在事务结束时全部一次释放，这种方式可以有效的避免死锁发生。但是这在数据库系统中并不适用，因为事务开始时并不知道这个事务要用到哪些数据，一般在应用程序中使用的比较多。</p>

<h3 id="mysql-的隔离级别">MySQL 的隔离级别</h3>

<p>虽然数据库的四种隔离级别通过 LBCC 技术都可以实现，但是它最大的问题是它只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低，针对这种场景，MVCC 技术应运而生。MVCC 的全称叫做 Multi-Version Concurrent Control（多版本并发控制），InnoDb 会为每一行记录增加几个隐含的“辅助字段”，（实际上是 3 个字段：一个隐式的 ID 字段，一个事务 ID，还有一个回滚指针），事务在写一条记录时会将其拷贝一份生成这条记录的一个原始拷贝，写操作同样还是会对原记录加锁，但是读操作会读取未加锁的新记录，这就保证了读写并行。要注意的是，生成的新版本其实就是 undo log，它也是实现事务回滚的关键技术。关于 InnoDb 的 MVCC 机制的实现原理推荐看下这篇文章：<a href="http://www.imooc.com/article/17290">MySQL数据库事务各隔离级别加锁情况&ndash;read committed &amp;&amp; MVCC</a>。</p>

<p>InnoDb 通过 MVCC 实现了读写并行，但是在不同的隔离级别下，读的方式也是有所区别的。首先要特别指出的是，在 read uncommit 隔离级别下，每次都是读取最新版本的数据行，所以不能用 MVCC 的多版本，而 serializable 隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC。下面我们通过两个例子，来看看这两个隔离级别下 MVCC 有什么区别。</p>

<p>还是使用上面的 account 表，首先将 MySQL 的事务隔离级别设置为 RR，然后开启一个事务，执行下面的 SQL：</p>

<pre><code class="language-sql">  mysql&gt; begin;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; select * from account where id = 1;
  +----+----------+---------+
  | id |     name | balance |
  +----+----------+---------+
  |  1 |        A |  1000   |
  +----+----------+---------+
  1 row in set (0.00 sec)

  mysql&gt; update account set balance = 2000 where id = 1;
  Query OK, 1 row affected (0.00 sec)
  Rows matched: 1  Changed: 1  Warnings: 0

  mysql&gt; select * from account where id = 1;
  +----+----------+---------+
  | id |     name | balance |
  +----+----------+---------+
  |  1 |        A |  2000   |
  +----+----------+---------+
  1 row in set (0.00 sec)
</code></pre>

<p>开启第二个事务，如下：</p>

<pre><code class="language-SQL">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account where id = 1;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  1 |        A |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
</code></pre>

<p>可以看到事务 2 查询出来的还是 A 原始的信息，这个时候事务 1 使用 commit 提交：</p>

<pre><code class="language-SQL">mysql&gt; commit;
Query OK, 0 rows affected (0.05 sec)
</code></pre>

<p>并在事务 2 中再查询一次，发现查询出来的结果不变，还是原始值：</p>

<pre><code class="language-SQL">mysql&gt; select * from account where id = 1;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  1 |        A |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
</code></pre>

<p>同样的，我们将数据库的隔离级别设置为 RC，重新做一次这个实验，第一步都是一样的，只是第二步当事务 1 commit 之后，事务 2 再查一次发现查询出来的是最新提交的记录了：</p>

<pre><code class="language-SQL">mysql&gt; select * from account where id = 1;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  1 |        A |  2000   |
+----+----------+---------+
1 row in set (0.00 sec)
</code></pre>

<p>通过这个实验可以知道，尽管 RR 和 RC 隔离级别都实现了 MVCC 来满足读写并行，但是读的实现方式是不一样的：<strong>RC 总是读取记录的最新版本，如果该记录被锁住，则读取该记录最新的一次快照，而 RR 是读取该记录事务开始时的那个版本。</strong> 虽然这两种读取方式不一样，但是它们读取的都是快照数据，并不会被写操作阻塞，所以这种读操作称为 快照读（Snapshot Read），有时候也叫做 <strong>非阻塞读（Nonlocking Read）</strong>，RR 隔离级别下的叫做 <strong>一致性非阻塞读（Consistent Nonlocking Read）</strong>。</p>

<p>除了 <strong>快照读</strong> ，MySQL 还提供了另一种读取方式：<strong>当前读（Current Read）</strong>，有时候又叫做 <strong>加锁读（Locking Read）</strong> 或者 <strong>阻塞读（Blocking Read</strong>），这种读操作读的不再是数据的快照版本，而是数据的最新版本，并会对数据加锁，根据加锁的不同，又分成两类：</p>

<ul>
<li>SELECT &hellip; LOCK IN SHARE MODE：加 S 锁</li>
<li>SELECT &hellip; FOR UPDATE：加 X 锁</li>
<li>INSERT / UPDATE / DELETE：加 X 锁</li>
</ul>

<p>当前读在 RR 和 RC 两种隔离级别下的实现也是不一样的：<strong>RC 只加记录锁，RR 除了加记录锁，还会加间隙锁，用于解决幻读问题，</strong> 关于记录锁和间隙锁的概念后面再讲，有兴趣的同学可以和上面一样，通过两个例子来感受一下。</p>

<p>首先在 RC 隔离级别下，开启一个事务，执行下面的 SQL 查询所有 id &gt; 3 的记录，使用当前读而不是快照读：
首先在 RC 隔离级别下，开启一个事务，执行下面的 SQL 查询所有 id &gt; 3 的记录，使用当前读而不是快照读：</p>

<pre><code class="language-SQL">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account where id &gt; 3 lock in share mode;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  4 |        D |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
</code></pre>

<p>同时，开启另一个事务，向 account 表中新增一条记录，然后修改 id = 4 的记录：</p>

<pre><code class="language-SQL">  mysql&gt; begin;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; insert into account(name, balance) value('E', 1000);
  Query OK, 1 row affected (6.24 sec)

  mysql&gt; update account set balance = 2000 where id = 4;
</code></pre>

<p>可以看到事务 2 在事务 1 当前读之后，仍然可以新增记录，但是在执行 update 操作的时候被阻塞，这说明了事务 1 在执行当前读的时候在 id = 4 这条记录上加了锁，但是并没有对 id &gt; 3 这个范围加锁。然后我们切换到事务 1 中，再次查询：</p>

<pre><code class="language-SQL">mysql&gt; select * from account where id &gt; 3 lock in share mode;
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
</code></pre>

<p>这个时候事务 1 直接死锁了，原因其实很简单，事务 2 在 insert 新纪录的时候（id = 5）会在新纪录上加锁，所以事务 1 再次执行当前读，想获取 id &gt; 3 的记录，就需要在 id = 4 和 id = 5 这两条记录上加锁，但是 id = 5 这条记录已经被事务 2 锁住了，于是事务 1 被事务 2 阻塞，同时事务 2 还在等待 事务 1 释放 id = 4 上的锁，于是便产生了死锁。</p>

<p>接下来把隔离级别设置成 RR，再重复事务 1 刚刚的操作：</p>

<pre><code class="language-SQL">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account where id &gt; 3 lock in share mode;
+----+----------+---------+
| id |     name | balance |
+----+----------+---------+
|  4 |        D |  1000   |
+----+----------+---------+
1 row in set (0.00 sec)
</code></pre>

<p>同时，事务 2 向 account 表中新增一条记录：</p>

<pre><code class="language-SQL">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into account(name, balance) value('E', 1000);
</code></pre>

<p>我们发现，这个时候事务 2 就被阻塞了，很显然事务 1 在执行 select &hellip; lock in share mode 的时候，不仅在 id = 4 这条记录上加了锁，而且在 id &gt; 3 这个范围上也加了锁。</p>

<p>关于 MySQL 不同的隔离级别，读操作的差异总结起来如下图所示（其中，读未提交和可序列化都和 MVCC 不兼容，可以暂且认为它们都属于当前读）：</p>

<p><img src="/images/post/18/06/8.png" alt="" /></p>

<h3 id="查看和设置-mysql-的隔离级别">查看和设置 MySQL 的隔离级别</h3>

<p>可以通过查看 MySQL 中的系统变量 tx_isolation 的值来确定当前 MySQL 正在使用什么隔离级别。使用下面的 SQL 查询当前数据库的隔离级别：</p>

<pre><code class="language-SQL">mysql&gt; select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
</code></pre>

<p>这里要注意的是在 MySQL 中变量一般分为两类：用户变量 和 系统变量，用户变量的变量名格式为 @variable，而系统变量的格式为 @@variable，tx_isolation 是系统变量，所以变量名为 @@tx_isolation。其中，系统变量又可以分为 全局变量 和 会话变量，默认情况下使用 select @@variable 查询出来的是会话变量的值，也可以写作 select @@session.variable 或者 select @@local.variable，如果要查询全局变量的值，则使用 select @@global.variable。</p>

<p>所以通常使用下面的 SQL 查询数据库的隔离级别：</p>

<pre><code class="language-SQL">mysql&gt; select @@session.tx_isolation, @@global.tx_isolation;
+------------------------+-----------------------+
| @@session.tx_isolation | @@global.tx_isolation |
+------------------------+-----------------------+
| REPEATABLE-READ        | REPEATABLE-READ       |
+------------------------+-----------------------+
</code></pre>

<p>另外可以使用 SET TRANSACTION 命令修改 MySQL 的隔离级别，譬如下面的 SQL 修改隔离级别为 RC：</p>

<pre><code class="language-SQL">mysql&gt; set transaction isolation level read committed;
</code></pre>

<p>同样其他的隔离级别可以使用下面的 SQL 进行修改：</p>

<ul>
<li><p>set transaction isolation level read uncommitted;</p></li>

<li><p>set transaction isolation level read committed;</p></li>

<li><p>set transaction isolation level repeatable read;</p></li>

<li><p>set transaction isolation level serializable;</p></li>
</ul>

<p>这里也有一个要注意的地方，默认的 SET TRANSACTION 命令 只对当前会话的下一个事务有效，当下个事务结束之后，下下个事务又会恢复到当前会话的隔离级别。我在这个地方困惑了好久，因为使用 SET TRANSACTION 命令设置完隔离级别之后，通过 select @@tx_isolation 查询当前会话的隔离级别是不会变化的，但是实际上下一个事务的隔离级别确实已经修改了.</p>

<p>找到了一种可以查看事务隔离级别的方法，那就是查 information_schema.INNODB_TRX 表。这种方式有一个不方便的地方在于，事务里必须要先执行一条 SQL 语句，才会在 INNODB_TRX 表中有记录，如下所示：</p>

<pre><code class="language-SQL">mysql&gt; select * from information_schema.INNODB_TRX\G
*************************** 1. row ***************************
                   trx_id: 282133714024240
                trx_state: RUNNING
              trx_started: 2018-07-25 23:12:58
    trx_requested_lock_id: NULL
         trx_wait_started: NULL
               trx_weight: 0
      trx_mysql_thread_id: 40
                trx_query: NULL
      trx_operation_state: NULL
        trx_tables_in_use: 0
        trx_tables_locked: 0
         trx_lock_structs: 0
    trx_lock_memory_bytes: 1136
          trx_rows_locked: 0
        trx_rows_modified: 0
  trx_concurrency_tickets: 0
      trx_isolation_level: READ COMMITTED
        trx_unique_checks: 1
   trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
trx_adaptive_hash_latched: 0
trx_adaptive_hash_timeout: 0
         trx_is_read_only: 0
trx_autocommit_non_locking: 0
1 row in set (0.00 sec)
</code></pre>

<p>如果要修改当前会话的隔离级别，而不是仅仅下一个事务的隔离级别（这在做实验时挺有用的），需要使用下面命令：</p>

<pre><code class="language-SQL">mysql&gt; set session transaction isolation level read committed;
</code></pre>

<p>另外，也可以使用修改系统变量的方法来修改隔离级别：</p>

<pre><code class="language-SQL">mysql&gt; set @@session.tx_isolation = 'READ-COMMITTED';
</code></pre>

<p>如果要修改全局变量的话，则使用命令 set global transaction isolation level &hellip; 或者 set @@global.tx_isolation = &hellip;，方法与上面类似，不再赘述。不过要注意的是，这个命令不会改变当前会话的隔离级别，而是对新的会话有影响，所以要关闭当前会话，重新开启一个会话才能看到效果。
转载自：<a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">aneasystone&rsquo;s blog</a></p>


                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018-06-12-gitment%e7%99%bb%e5%bd%95%e5%a4%b1%e8%b4%a5/" data-toggle="tooltip" data-placement="top" title="gitment登录失败">&larr;
                            上一篇</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018-07-28-%e4%ba%86%e8%a7%a3%e5%b8%b8%e8%a7%81%e7%9a%84%e9%94%81%e7%b1%bb%e5%9e%8b" data-toggle="tooltip" data-placement="top" title="死锁 - 了解常见的锁类型">下一篇 &rarr;</a>
                    </li>
                    
                </ul>

                

<div id="git-comments"></div>


<link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://www.wenjunjiang.win/js/gitment.js"></script>


<script>
  var gitment = new Gitment({
    id: '死锁了解事务与隔离级别', 
    title: '死锁了解事务与隔离级别',
    owner: 'wangzitao6',
    repo: 'wangzitao6.github.io',
    oauth: {
      client_id: 'a09fff4950f8823cd23b',
      client_secret: 'ec6b34b620c98d6b91dcbcb2b17270b38b33f6d9',
    }
  })
  gitment.render('git-comments')
</script>



            </div>
            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        <a href="/tags/blog" title="blog">
                            blog
                        </a>
                        
                        
                        
                        <a href="/tags/git" title="git">
                            git
                        </a>
                        
                        
                        
                        <a href="/tags/jvm" title="jvm">
                            jvm
                        </a>
                        
                        
                        
                        <a href="/tags/mysql" title="mysql">
                            mysql
                        </a>
                        
                        
                        
                        <a href="/tags/sql%E6%B3%A8%E5%85%A5" title="sql注入">
                            sql注入
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%85%B6%E4%BB%96" title="其他">
                            其他
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%AD%A3%E5%88%99" title="正则">
                            正则
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%AD%BB%E9%94%81" title="死锁">
                            死锁
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91" title="端口转发">
                            端口转发
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%BD%91%E7%BB%9C" title="网络">
                            网络
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
                <section>
                    <hr>
                    <h5>FRIENDS</h5>
                    <ul class="list-inline">
                        
                        <li><a target="_blank" href="https://www.ibm.com/developerworks/cn/">IBM Developer 中国 </a></li>
                        
                    </ul>
                </section>
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                   
                    
                    <li>
                        <a href="mailto:wang_zitao@foxmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    

                    
                    
                    

                    

		    
                    
                    <li>
                        <a target="_blank" href="/images/qrcode.jpg">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-wechat fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    <li>
                        <a target="_blank" href="https://github.com/wangzitao6">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 王子滔的学习笔记 2019
                    <br>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>




<script>
    
    var _baId = '28c952e35b6e860c096a2cdf52785c6f';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-135479251-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>
</html>
